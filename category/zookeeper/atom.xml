<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://silvercrow42.github.io/joker.github.io</id>
    <title>Joker • Posts by &#34;zookeeper&#34; category</title>
    <link href="https://silvercrow42.github.io/joker.github.io" />
    <updated>2024-09-24T03:39:53.000Z</updated>
    <category term="后端" />
    <category term="操作系统" />
    <category term="Linux" />
    <category term="MQ" />
    <category term="RocketMQ" />
    <category term="java" />
    <category term="spring" />
    <category term="Zookeeper" />
    <category term="数据库" />
    <category term="NoSQL" />
    <category term="缓存" />
    <category term="Redis" />
    <category term="Redisson" />
    <category term="分布式锁" />
    <entry>
        <id>https://silvercrow42.github.io/joker.github.io/2024/09/24/%E3%80%90Zookeeper%E3%80%91Zookeeper%E8%AF%A6%E8%A7%A3/</id>
        <title>【Zookeeper】Zookeeper面试题汇总与详解</title>
        <link rel="alternate" href="https://silvercrow42.github.io/joker.github.io/2024/09/24/%E3%80%90Zookeeper%E3%80%91Zookeeper%E8%AF%A6%E8%A7%A3/"/>
        <content type="html">&lt;h2 id=&#34;什么是zookeeper&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#什么是zookeeper&#34;&gt;#&lt;/a&gt; 什么是 Zookeeper&lt;/h2&gt;
&lt;p&gt;Zookeeper 是一个开源的协调服务，用于分布式应用程序，提供了诸如配置维护、域名服务、分布式同步、组服务等功能。它是一个为分布式应用提供一致性服务的软件，其内部使用了一种称为&lt;br&gt;
 Zab 的协议（在选举过程中使用 Paxos 协议）来保证分布式环境中不同节点之间的数据一致性。&lt;/p&gt;
&lt;p&gt;Zookeeper 的主要特点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高可用性：Zookeeper 可以构建为集群模式，通过多数派存活原则来保证服务的高可用性。&lt;/li&gt;
&lt;li&gt;顺序一致性：客户端请求按照发起顺序进行处理。&lt;/li&gt;
&lt;li&gt;原子性：所有事务要么全部成功，要么全部失败。&lt;/li&gt;
&lt;li&gt;单一视图：无论客户端连接到集群中的哪个服务器，看到的服务视图都是一样的。&lt;/li&gt;
&lt;li&gt;可靠性：一旦一个更新被应用并确认，该更新将一直有效，即使此时 Zookeeper 发生故障。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Zookeeper 的应用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据发布与订阅&lt;/p&gt;
&lt;p&gt;顾名思义就是将数据发布到 ZooKeeper 节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，地址列表等就非常适合使用。&lt;br&gt;
数据发布 / 订阅的一个常见的场景是配置中心，发布者把数据发布到 ZooKeeper 的一个或一系列的节点上，供订阅者进行数据订阅，达到动态获取数据的目的。&lt;br&gt;
配置信息一般有几个特点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据量小的 KV&lt;/li&gt;
&lt;li&gt;数据内容在运行时会发生动态变化&lt;/li&gt;
&lt;li&gt;集群机器共享，配置一致&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ZooKeeper 采用的是推拉结合的方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;推：服务端会推给注册了监控节点的客户端 Wathcer 事件通知&lt;/li&gt;
&lt;li&gt;拉：客户端获得通知后，然后主动到服务端拉取最新的数据&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命名服务&lt;/p&gt;
&lt;p&gt;作为分布式命名服务，命名服务是指通过指定的名字来获取资源或者服务的地址，利用 ZooKeeper 创建一个全局的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。统一命名服务的命名结构图如下所示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在分布式环境下，经常需要对应用 / 服务进行统一命名，便于识别不同服务。类似于域名与 IP 之间对应关系，IP 不容易记住，而域名容易记住。通过名称来获取资源或服务的地址，提供者等信息。&lt;/li&gt;
&lt;li&gt;按照层次结构组织服务 / 应用名称。可将服务名称以及地址信息写到 ZooKeeper 上，客户端通过 ZooKeeper 获取可用服务列表类。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分布式锁&lt;/p&gt;
&lt;p&gt;处于不同节点上不同的服务，它们可能需要顺序的访问一些资源，这里需要一把分布式的锁。&lt;br&gt;
分布式锁具有以下特性：写锁、读锁、时序锁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写锁：在 zk 上创建的一个临时的无编号的节点。由于是无序编号，在创建时不会自动编号，导致只能客户端有一个客户端得到锁，然后进行写入。&lt;/li&gt;
&lt;li&gt;读锁：在 zk 上创建一个临时的有编号的节点，这样即使下次有客户端加入是同时创建相同的节点时，他也会自动编号，也可以获得锁对象，然后对其进行读取。&lt;/li&gt;
&lt;li&gt;时序锁：在 zk 上创建的一个临时的有编号的节点根据编号的大小控制锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集群管理&lt;/p&gt;
&lt;p&gt;所谓集群管理就是：是否有机器退出和加入、选举 master。&lt;br&gt;
集群管理主要指集群监控和集群控制两个方面。前者侧重于集群运行时的状态的收集，后者则是对集群进行操作与控制。开发和运维中，面对集群，经常有如下需求:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;希望知道集群中究竟有多少机器在工作&lt;/li&gt;
&lt;li&gt;对集群中的每台机器的运行时状态进行数据收集&lt;/li&gt;
&lt;li&gt;对集群中机器进行上下线的操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;集群管理结构如下所示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;分布式环境中，实时掌握每个节点的状态是必要的，可根据节点实时状态做出一些调整。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可交由 ZooKeeper 实现。&lt;br&gt;
可将节点信息写入 ZooKeeper 上的一个 Znode。&lt;br&gt;
监听这个 Znode 可获取它的实时状态变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;典型应用&lt;/p&gt;
&lt;p&gt;Hbase 中 Master 状态监控与选举。&lt;br&gt;
利用 ZooKeeper 的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建&lt;br&gt;
 /currentMaster&lt;br&gt;
 节点，最终一定只有一个客户端请求能够创建成功&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分布式通知与协调&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分布式环境中，经常存在一个服务需要知道它所管理的子服务的状态。
&lt;ol&gt;
&lt;li&gt;NameNode 需知道各个 Datanode 的状态。&lt;/li&gt;
&lt;li&gt;JobTracker 需知道各个 TaskTracker 的状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;心跳检测机制可通过 ZooKeeper 来实现。&lt;/li&gt;
&lt;li&gt;信息推送可由 ZooKeeper 来实现，ZooKeeper 相当于一个发布 / 订阅系统。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分布式队列管理&lt;/p&gt;
&lt;p&gt;分布式队列分为两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。
&lt;ol&gt;
&lt;li&gt;一个 job 由多个 task 组成，只有所有任务完成后，job 才运行完成。&lt;/li&gt;
&lt;li&gt;可为 job 创建一个 /job 目录，然后在该目录下，为每个完成的 task 创建一个临时的 Znode，一旦临时节点数目达到 task 总数，则表明 job 运行完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="后端" />
        <category term="java" />
        <category term="Zookeeper" />
        <updated>2024-09-24T03:39:53.000Z</updated>
    </entry>
</feed>
