



<!DOCTYPE html>
<html lang="zh-CN,en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/joker.github.io/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/joker.github.io/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="Joker" href="https://silvercrow42.github.io/joker.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Joker" href="https://silvercrow42.github.io/joker.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="Joker" href="https://silvercrow42.github.io/joker.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/joker.github.io/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="后端,数据库,NoSQL,缓存,Redis" />


<link rel="canonical" href="https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/">



  <title>
【Redis】Redis面试题汇总与详解 - Redis |
Joker = Joker</title>
<meta name="generator" content="Hexo 7.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">【Redis】Redis面试题汇总与详解
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2024-09-13 13:52:28">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2024-09-13T13:52:28+08:00">2024-09-13</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/joker.github.io/" rel="start">Joker</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://api.boxmoe.com/random.php?size=large?371798"></li>
          <li class="item" data-background-image="https://api.boxmoe.com/random.php?size=large?161497"></li>
          <li class="item" data-background-image="https://api.boxmoe.com/random.php?size=large?363963"></li>
          <li class="item" data-background-image="https://api.boxmoe.com/random.php?size=large?468667"></li>
          <li class="item" data-background-image="https://api.boxmoe.com/random.php?size=large?235900"></li>
          <li class="item" data-background-image="https://api.boxmoe.com/random.php?size=large?301286"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/joker.github.io/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/joker.github.io/categories/Redis/" itemprop="item" rel="index" title="分类于 Redis"><span itemprop="name">Redis</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/joker.github.io/images/avatar.png">
    <meta itemprop="name" content="Joker">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Joker">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="概念"><a class="markdownIt-Anchor" href="#概念">#</a> 概念</h1>
<h2 id="redis-是什么"><a class="markdownIt-Anchor" href="#redis-是什么">#</a> Redis 是什么</h2>
<p>Redis（Remote Dictionary Server）是一个开源的键值存储系统，以其高性能和低延迟著称。它最初由 Salvatore<br>
Sanfilippo 编写，并于 2009 年首次发布。Redis 不仅可以作为数据库使用，还可以作为缓存和消息代理。Redis 支持多种数据结构，如字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted<br>
sets）等，这使得它非常适合用于多种应用场景</p>
<h2 id="redis-的特点"><a class="markdownIt-Anchor" href="#redis-的特点">#</a> Redis 的特点</h2>
<ul>
<li>内存存储：Redis 将所有数据都存储在内存中，这使得它能够提供非常高的读写速度，通常能够达到数十万次每秒的读写操作（QPS）。</li>
<li>持久化：尽管 Redis 主要是一个内存数据库，但它也提供了数据持久化的机制，包括 RDB（Redis Database Backup）快照和 AOF（Append Only<br>
File）日志两种方式。</li>
<li>数据结构丰富：除了基本的键值对存储之外，Redis 还支持多种复杂的数据结构，如列表、集合、有序集合等，这使得它非常适合用于构建复杂的数据模型。</li>
<li>网络透明：Redis 使用 TCP 协议，客户端可以通过网络访问 Redis 服务器，支持跨平台部署。</li>
<li>主从复制：Redis 支持主从复制机制，可以轻松地设置数据备份和读写分离。</li>
<li>Lua 脚本：Redis 支持在服务器端执行 Lua 脚本，允许用户将复杂的操作封装成一个原子性的操作。</li>
<li>事务：Redis 支持事务，允许用户将一系列操作打包成一个单独的命令序列执行。</li>
<li>发布 / 订阅模式：Redis 支持发布 / 订阅模式，可以用于构建消息队列或事件驱动的应用程序。</li>
<li>集群：Redis 3.0 之后版本支持官方的集群模式，可以实现数据的水平扩展。</li>
<li>多线程：Redis 6.0 版本引入了多线程模型，用于异步处理 I/O 和其他耗时操作，进一步提升了性能。</li>
</ul>
<h2 id="redis-的应用场景"><a class="markdownIt-Anchor" href="#redis-的应用场景">#</a> Redis 的应用场景</h2>
<p>由于其高性能和灵活性，Redis 被广泛应用于多种场景中：</p>
<ul>
<li>缓存：由于 Redis 的高速读写能力，它经常被用作 Web 应用的缓存层，以减轻后端数据库的压力。</li>
<li>会话存储：Redis 可以用来存储用户的会话信息，支持快速的读取和更新操作。</li>
<li>排行榜：Redis 的有序集合非常适合用来构建排行榜，可以高效地进行排序和范围查询。</li>
<li>消息队列：通过发布 / 订阅模式，Redis 可以作为一个轻量级的消息队列系统。</li>
<li>实时数据分析：Redis 的数据结构非常适合用于处理实时数据流，如实时统计、监控等。</li>
<li>分布式锁：Redis 可以用来实现简单的分布式锁机制，协调多个节点上的并发操作。</li>
</ul>
<h2 id="redis-的数据结构"><a class="markdownIt-Anchor" href="#redis-的数据结构">#</a> Redis 的数据结构</h2>
<h3 id="底层数据结构"><a class="markdownIt-Anchor" href="#底层数据结构">#</a> 底层数据结构</h3>
<h4 id="redisobject"><a class="markdownIt-Anchor" href="#redisobject">#</a> redisObject</h4>
<p>定义：redisObject（通常缩写为 robj）是 Redis 中用来表示数据库键值对的一个核心数据结构。每一个键值对在 Redis 内部都会被转化为一个 redisObject 实例进行管理。这个结构体不仅包含了键或值本身的数据，还提供了额外的信息来帮助 Redis 更好地管理和操作这些对象。</p>
<p>用途：redisObject 是 Redis 中键值对存储的数据结构，它封装了键和值，并提供了额外的元数据，如引用计数、过期时间等。其主要作用在于：</p>
<ul>
<li>类型和编码：它使得 Redis 能够灵活地存储不同类型的数据，并且可以根据数据的特点选择最合适的编码方式来存储，从而优化内存使用和访问速度。</li>
<li>内存管理：通过引用计数，redisObject 支持对象的共享和自动内存回收，减少了不必要的内存分配和释放操作。</li>
<li>LRU 缓存淘汰：通过记录对象的最后访问时间，Redis 可以实现基于 LRU 算法的对象淘汰，从而在内存资源有限的情况下，优先保留最近使用的对象。</li>
<li>共享对象：对于一些常用的简单对象（如数字 0 和 1，以及空字符串），Redis 会创建一次并复用，这减少了创建和销毁对象的开销。</li>
</ul>
<p>底层实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* LRU time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p>redisObject 的基本结构通常包含以下字段：</p>
<ul>
<li>type: 一个 4 位的无符号整数，用来标识对象的类型。Redis 支持多种数据类型，如字符串（string）、列表（list）、集合（set）、哈希（hash）、有序集合（sorted<br>
set）等，每种类型都有一个对应的标识符。</li>
<li>encoding: 另一个 4 位的无符号整数，表示对象的编码方式。不同的数据类型有不同的内部编码方式，例如字符串可以是普通的字符串，也可以是压缩后的字符串（embstr），列表可以是链表（list）或者快速列表（quicklist）等。</li>
<li>lru: 一个时间戳，记录了对象最后一次被访问的时间（相对于服务器的 lruclock）。这个字段用于实现 Redis 的 LRU（Least Recently<br>
Used）缓存淘汰策略。</li>
<li>refcount: 引用计数器，用来追踪有多少地方引用了这个对象。当一个对象不再被任何地方引用时，其引用计数器减至零，Redis 可以回收该对象占用的内存。</li>
<li>ptr: 一个指向实际数据的指针。这个指针指向的具体内容依赖于对象的类型和编码方式。</li>
</ul>
<h4 id="动态字符串sds"><a class="markdownIt-Anchor" href="#动态字符串sds">#</a> 动态字符串（SDS）</h4>
<p>定义：SDS（Simple Dynamic String）是一种动态字符串，它使用一个结构体来保存字符串的指针、长度和未使用的空间。</p>
<p>底层实现：使用简单动态字符串（SDS）来存储数据，SDS 是为了克服 C 字符串的一些不足而设计的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">//记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">//等于 SDS 保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">//记录 buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 SDS 保存字符串 “Redis” 具体图示如下：</p>
<img data-src="/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/1120165-20180528075607627-218845583.png" class="" title="1120165-20180528075607627-218845583.png">
<p>图片来源：《Redis 设计与实现》</p>
<p>我们看上面对于 SDS 数据类型的定义：</p>
<ul>
<li>len 保存了 SDS 保存字符串的长度</li>
<li>buf [] 数组用来保存字符串的每个元素</li>
<li>free j 记录了 buf 数组中未使用的字节数量</li>
</ul>
<p>上面的定义相对于 C 语言对于字符串的定义，有什么好处？</p>
<img data-src="/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/1120165-20180527234349672-568401853.png" class="" title="1120165-20180528075607627-218845583.png">
<ol>
<li>
<p>常数复杂度获取字符串长度：由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O (1)。而对于 C<br>
 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O (n)。通过 strlen key 命令可以获取 key 的字符串长度。</p>
</li>
<li>
<p>杜绝缓冲区溢出：我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于<br>
 SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求。如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p>
</li>
<li>
<p>减少修改字符串的内存重新分配次数:<br>
C 语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p>
<p>而对于 SDS，由于 len 属性和 free 属性的存在，对于修改字符串 SDS 实现了空间预分配和惰性空间释放两种策略：</p>
<ol>
<li>空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</li>
<li>惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free<br>
 属性将这些字节的数量记录下来，等待后续使用。（当然 SDS 也提供了相应的 API，当我们有需要时，也可以手动释放这些未使用的空间。）</li>
</ol>
</li>
<li>
<p>二进制安全</p>
<p>因为 C 字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此 C 字符串无法正确存取；而所有<br>
 SDS 的 API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len<br>
 属性表示的长度来判断字符串是否结束。</p>
</li>
<li>
<p>兼容部分 C 字符串函数</p>
<p>虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库 &lt;string.h&gt; 中的一部分函数。</p>
</li>
</ol>
<p>一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）来使用。</p>
<h4 id="压缩列表zip-list"><a class="markdownIt-Anchor" href="#压缩列表zip-list">#</a> 压缩列表（Zip List）</h4>
<p>定义：Ziplist 是一种特殊的内存紧凑型数据结构，用于存储多个相邻的元素。它主要用于实现 Redis 中的列表（List）和哈希（Hash）数据类型，当这些数据类型的数据量较小且元素较短时，使用 ziplist 可以节省内存空间。</p>
<p>底层实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> header; <span class="comment">// 标记ziplist的开始，通常是一个固定的字节（例如 0x01）</span></span><br><span class="line">    <span class="type">uint32_t</span> length; <span class="comment">// 整个ziplist的长度，包括所有条目和前缀信息。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Entries</span></span><br><span class="line">    <span class="comment">// Each entry has a length prefix and content</span></span><br><span class="line">    <span class="comment">// The number of entries is determined by the length field</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Example entry structure:</span></span><br><span class="line">    <span class="comment">// Length prefix (1 or 5 bytes)</span></span><br><span class="line">    <span class="comment">// Content (variable length)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// End marker</span></span><br><span class="line">    <span class="type">char</span> end; <span class="comment">// 标记ziplist的结束，通常是一个固定的字节（例如 0xff）。</span></span><br><span class="line">&#125; <span class="type">ziplist_t</span>;</span><br></pre></td></tr></table></figure>
<p>实现细节：</p>
<ul>
<li>前缀：每个元素的前缀包含了元素的长度信息，以及元素的类型信息。</li>
<li>长度编码：ziplist 使用可变长度编码来存储元素的长度，这样可以更高效地利用内存。</li>
<li>内存紧凑：由于 ziplist 将所有元素存储在一个连续的内存区域中，因此它可以有效地减少内存碎片。</li>
</ul>
<p>特点</p>
<ul>
<li>连续存储：ziplist 将多个元素存储在一个连续的内存块中。</li>
<li>元素和长度信息：每个元素的前面都会有一个前缀，这个前缀包含了元素的长度信息。</li>
<li>支持多种类型：ziplist 可以存储整数或字符串，整数直接存储在前缀中，字符串则存储在前缀之后。</li>
</ul>
<h4 id="双向链表linkedlist"><a class="markdownIt-Anchor" href="#双向链表linkedlist">#</a> 双向链表（linkedlist）</h4>
<p>定义：在 Redis 中，linkedlist（通常指的是 Redis 内部实现的双向链表）是 Redis 用来存储 list 键值对的一种底层数据结构。它允许 Redis 从列表的两端高效地添加和移除元素，</p>
<p>底层实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个双向链表节点</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">       <span class="comment">//前置节点</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">       <span class="comment">//后置节点</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">       <span class="comment">//节点的值</span></span><br><span class="line">       <span class="type">void</span> *value;  </span><br><span class="line">&#125;listNode</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个双向链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">     <span class="comment">//表头节点</span></span><br><span class="line">     listNode *head;</span><br><span class="line">     <span class="comment">//表尾节点</span></span><br><span class="line">     listNode *tail;</span><br><span class="line">     <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">     <span class="comment">//节点值复制函数</span></span><br><span class="line">     <span class="type">void</span> (*<span class="built_in">free</span>) (<span class="type">void</span> *ptr);</span><br><span class="line">     <span class="comment">//节点值释放函数</span></span><br><span class="line">     <span class="type">void</span> (*<span class="built_in">free</span>) (<span class="type">void</span> *ptr);</span><br><span class="line">     <span class="comment">//节点值对比函数</span></span><br><span class="line">     <span class="type">int</span> (*match) (<span class="type">void</span> *ptr,<span class="type">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<p>数据结构如下图</p>
<img data-src="/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/1120165-20180528074403440-111834793.png" class="" title="1120165-20180528074403440-111834793.png">
<p>Redis 的 linkedlist 是由一系列 listNode 节点构成的双向链表。</p>
<p>每个 listNode 包含三个主要部分：</p>
<ul>
<li>prev：指向列表中前一个节点的指针。</li>
<li>next：指向列表中后一个节点的指针。</li>
<li>value：存储实际数据的字段，这个字段实际上是指向 redisObject 的指针，redisObject 包含了实际的数据和元数据（如类型、编码等）。</li>
</ul>
<p>每个 list 包含三个主要部分：</p>
<ul>
<li>head：指向链表的第一个节点。</li>
<li>tail：指向链表的最后一个节点。</li>
<li>len：链表的长度，即链表中节点的数量。</li>
</ul>
<p>特点</p>
<ul>
<li>双向链接：每个节点都包含前驱和后继指针，这使得可以从链表的任一端开始遍历整个链表。</li>
<li>无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL, 对链表的访问都是以 NULL 结束。</li>
<li>带链表长度计数器：通过 len 属性获取链表长度的时间复杂度为 O (1)。</li>
<li>多态：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值。</li>
<li>动态增长：随着元素的增加，链表可以动态增长。</li>
</ul>
<h4 id="哈希表hashtable"><a class="markdownIt-Anchor" href="#哈希表hashtable">#</a> 哈希表（Hashtable）</h4>
<p>定义：hashtable（哈希表）是一种用于存储键值对的数据结构，它在 Redis 内部用于实现哈希（hash）类型。哈希表允许快速地插入、查找和删除键值对，并且提供了良好的性能。</p>
<p>底层实现：Redis 中的哈希表实现主要包括两个核心组件：一个数组和一个链表。数组中的每个槽（slot）都可以存储一个链表，链表中的每个节点代表一个键值对。这种设计允许哈希表处理哈希冲突，即多个键映射到同一个数组索引的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictEntry **table; <span class="comment">// 哈希桶数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size; <span class="comment">// 哈希桶数组大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used; <span class="comment">// 已使用的哈希桶数量</span></span><br><span class="line">    dictResizeFunc *resize; <span class="comment">// 重置哈希表大小的函数</span></span><br><span class="line">    <span class="type">void</span> (*rehashidx); <span class="comment">// 当前正在进行的哈希表重置索引</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> states; <span class="comment">// 哈希表状态标志</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<p>Redis 中的哈希表结构定义通常包括以下几个部分：</p>
<ul>
<li>table：一个数组，数组的每个元素都是一个链表。</li>
<li>size：数组的大小。</li>
<li>used：已使用的槽的数量，即存储键值对的链表数量。</li>
<li>resize_policy：在某些 Redis 版本中，可能还包括用于控制何时进行重新哈希（resizing）的策略。</li>
</ul>
<p>哈希表 table 中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key; <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val; <span class="comment">// 值</span></span><br><span class="line">        <span class="type">uint64_t</span> ival; <span class="comment">// 整数值</span></span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个同散列值的dictEntry</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p>每个键值对存储在一个 dictEntry 结构体中，该结构体包含：</p>
<ul>
<li>key：键的指针，指向 redisObject。</li>
<li>val：值的指针，同样指向 redisObject。</li>
<li>next：指向链表中下一个节点的指针，用于处理哈希冲突。</li>
</ul>
<h5 id="哈希冲突的优化"><a class="markdownIt-Anchor" href="#哈希冲突的优化">#</a> 哈希冲突的优化</h5>
<p>我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过 next 这个指针可以将多个哈希值相同的键值对连接在一起，用来解决哈希冲突。</p>
<img data-src="/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/1120165-20180528080655703-1600710948.png" class="" title="1120165-20180528080655703-1600710948.png">
<ol>
<li>
<p>哈希算法：Redis 计算哈希值和索引值方法如下：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1</span>、使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line">#<span class="number">2</span>、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>解决哈希冲突：这个问题上面我们介绍了，方法是链地址法。通过字典里面的 *next 指针指向下一个具有相同索引值的哈希表节点。</p>
</li>
<li>
<p>扩容和收缩：当哈希表保存的键值对太多或者太少时，就要通过 rerehash (重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：</p>
<ol>
<li>如果执行扩展操作，会基于原哈希表创建一个大小等于 ht [0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。<br>
相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。</li>
<li>重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。</li>
<li>所有键值对都迁徙完毕后，释放原哈希表的内存空间。</li>
</ol>
</li>
<li>
<p>触发扩容的条件：</p>
<ol>
<li>服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于 1。</li>
<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于 5。</li>
</ol>
<p>ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。</p>
</li>
<li>
<p>渐近式 rehash</p>
<p>什么叫渐进式 rehash？ 也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在 Redis 中的键值对只有几个几十个，那么<br>
 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行<br>
 rehash，势必会造成 Redis 一段时间内不能进行别的操作。所以 Redis 采用渐进式<br>
 rehash, 这样在进行渐进式 rehash 期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行<br>
增加操作，一定是在新的哈希表上进行的。</p>
</li>
</ol>
<h4 id="整数集合intset"><a class="markdownIt-Anchor" href="#整数集合intset">#</a> 整数集合（intset）</h4>
<p>定义：一种特殊的数据结构，主要用于存储整数类型的集合，并且这些整数集合不允许有重复的元素。</p>
<p>底层实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">     <span class="comment">//编码方式</span></span><br><span class="line">     <span class="type">uint32_t</span> encoding;</span><br><span class="line">     <span class="comment">//集合包含的元素数量</span></span><br><span class="line">     <span class="type">uint32_t</span> length;</span><br><span class="line">     <span class="comment">//保存元素的数组</span></span><br><span class="line">     <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure>
<p>intset 的数据结构定义通常包括以下几个部分：</p>
<ul>
<li>length：表示集合中元素的数量。</li>
<li>encoding：表示集合中元素的类型，可以是 int16_t、int32_t 或 int64_t，具体取决于集合中最大的整数值所需的位数。</li>
<li>contents：一个动态数组，用于存储实际的整数值。每个整数根据 encoding 字段指定的类型占用相应的字节数。</li>
</ul>
<p>动态升级</p>
<p>当尝试向 intset 中添加一个超出当前整数类型范围的整数时，Redis 会执行一个称为 “编码升级” 的过程。这个过程会将 intset 中的所有元素转换为更大类型的整数，以适应新加入的元素。例如，如果 intset 当前使用的是 int32_t 类型，而尝试插入一个 int64_t 类型的值，则所有现有的 int32_t 值会被转换成 int64_t 类型。</p>
<h4 id="跳表skip-list"><a class="markdownIt-Anchor" href="#跳表skip-list">#</a> 跳表（Skip List）</h4>
<p>定义：Skiplist 是一种线性数据结构，它提供了比传统平衡树更快的查找性能，同时实现相对简单。Redis 使用 skiplist 来实现有序集合（Sorted<br>
Set）。</p>
<p>底层实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>;</span> <span class="comment">// 跳表头部</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">tail</span>;</span> <span class="comment">// 跳表尾部</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">// 跳表长度</span></span><br><span class="line">    <span class="type">int</span> level; <span class="comment">// 跳表层级</span></span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> score; <span class="comment">// 成员的分数</span></span><br><span class="line">    <span class="type">void</span> *obj; <span class="comment">// 成员对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">// 指向前一个节点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 指向后一个节点的指针</span></span><br><span class="line">        <span class="type">int</span> span; <span class="comment">// 跨越的节点数量</span></span><br><span class="line">    &#125; level[]; <span class="comment">// 层级数组</span></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>
<p>实现细节：</p>
<ul>
<li>节点结构：skiplist 中的每个节点包含一个元素、一个分数（用于排序）、一个指向前一个节点的指针以及一个或多个指向下一层节点的指针。</li>
<li>层级：每个节点可以有多个层级，每个层级对应一个指针，指向下一个具有相同高度的节点。</li>
<li>查找：查找时，从最高层开始，沿着指针前进直到找到目标元素或到达最低层。</li>
</ul>
<p>特点：</p>
<ul>
<li>多级索引：skiplist 通过构建多级索引来加速查找，每一级索引都是前一级索引的一个子集。</li>
<li>随机高度：新插入的元素的高度是随机确定的，通常使用随机化算法来决定新节点的高度。</li>
<li>高效插入和删除：由于 skiplist 的多级索引结构，插入和删除操作也相当高效。</li>
</ul>
<h3 id="数据结构的使用"><a class="markdownIt-Anchor" href="#数据结构的使用">#</a> 数据结构的使用</h3>
<h4 id="字符串string"><a class="markdownIt-Anchor" href="#字符串string">#</a> 字符串（String）</h4>
<p>用途：存储字符串数据，如文本、数字、日期等。</p>
<p>实现：根据不同的情况下字符串对象的 encoding 有三种，分别是：int、raw、embstr。</p>
<ol>
<li>
<p>如果一个字符串对象保存的是整数值，并且这个整数值可以用 long 类型标识，那么字符串对象会讲整数值保存在 ptr 属性中，并将<br>
 encoding 设置为 int。比如 set number 10086 命令。</p>
</li>
<li>
<p>如果字符串对象保存的是一个字符串值，并且这个字符串的长度大于 44 字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为<br>
 raw。在这种情况下，ptr 字段指向一个 SDS（Simple Dynamic String）结构。S 在这种情况下，ptr 字段指向一个 SDS（Simple Dynamic<br>
String）结构。</p>
</li>
<li>
<p>如果字符串对象保存的是一个字符串值，并且这个字符串的长度小于等于 44 字节，那么字符串对象将使用 embstr<br>
 编码的方式来保存这个字符串。embstr 同样基于 SDS，是一种将 RedisObject 对象头和 SDS 对象连续存在一起，使用 malloc<br>
 方法一次分配内存的存储形式。 这种编码方式的一些优点：</p>
<ol>
<li>embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次。</li>
<li>释放 embstr 编码的字符串对象只需要调用一次内存释放函数，而释放 raw 编码的字符串对象需要调用两次内存释放函数。</li>
<li>因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起 raw<br>
 编码的字符串对象能够更好地利用缓存带来的优势。</li>
</ol>
</li>
</ol>
<p>为什么分界线是 44 字节？</p>
<p>Redis 的 embstr 编码的实现中，字符串对象头和字符串对象本身是连续的，因此需要一个字节来保存字符串的长度。<br>
embstr 最小占用空间为 19（16+3），而 64-19-1（结尾的 \0）=44，所以 embstr 只能容纳 44 字节。</p>
<p>使用场景：</p>
<ul>
<li>计数器：例如网站的访问计数，可以使用 INCR 或 INCRBY 命令来递增计数器。</li>
<li>会话存储：存储用户的登录状态或其他临时信息。</li>
<li>消息队列：使用 LPUSH 和 BRPOP 命令实现简单的消息队列。</li>
<li>缓存：存储经常访问的数据，减少数据库的访问压力。</li>
</ul>
<h4 id="列表list"><a class="markdownIt-Anchor" href="#列表list">#</a> 列表（List）</h4>
<p>用途：用于存储有序的元素列表，如队列、栈等。</p>
<p>实现：列表对象的 encoding 有 ziplist 和 linkedlist 两种。</p>
<ul>
<li>当列表的长度小于 512，并且所有元素的长度都小于 64 字节时，使用压缩列表 (ziplist) 存储</li>
<li>当列表的长度大于等于 512，或者有元素长度大于 64 字节时，使用链表 (linkedlist) 存储。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>消息队列：使用 LPUSH 和 BRPOP 命令实现先进先出（FIFO）的消息队列。</li>
<li>历史记录：保存用户的浏览历史或购买记录，可以使用 RPUSH 和 LPOP 命令。</li>
<li>排行榜：使用列表存储排名信息，通过 LREM 命令可以移除特定成员。</li>
</ul>
<h4 id="哈希hash"><a class="markdownIt-Anchor" href="#哈希hash">#</a> 哈希（Hash）</h4>
<p>用途：存储键值对，其中键是唯一的，值可以重复。</p>
<p>实现：哈希对象的 encoding 有 ziplist 和 hashtable 两种。</p>
<ul>
<li>当哈希对象保存的键值对数量小于 512，并且所有键值对的长度都小于 64 字节时，使用压缩列表存储；</li>
<li>当哈希对象保存的键值对数量大于等于 512，或者有键值对长度大于 64 字节时，使用 hashtable 存储。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>对象存储：存储复杂对象，如用户信息，每个字段对应用户的一个属性。</li>
<li>购物车：每个用户有一个购物车，购物车中的商品信息可以用哈希表来存储。</li>
<li>会话管理：存储用户的会话信息，每个会话 ID 对应一个哈希表。</li>
</ul>
<h4 id="集合set"><a class="markdownIt-Anchor" href="#集合set">#</a> 集合（Set）</h4>
<p>用途：存储不重复的元素集合，如集合、去重列表等。</p>
<p>实现：集合对象的 encoding 有 intset 和 hashtable 两种。</p>
<ul>
<li>当集合中元素数量小于 512，并且所有元素的长度都小于 64 字节时，使用 intset 存储；</li>
<li>当集合中元素数量大于等于 512，或者有元素长度大于 64 字节时，使用 hashtable 存储。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>去重：例如在一个活动中，确保每个用户只能参与一次。</li>
<li>标签系统：每个项目可以有多个标签，使用集合来存储项目的标签。</li>
<li>好友关系：存储用户的好友列表，可以快速判断两个用户是否互为好友。</li>
</ul>
<h4 id="有序集合sorted-set"><a class="markdownIt-Anchor" href="#有序集合sorted-set">#</a> 有序集合（Sorted Set）</h4>
<p>用途：存储有序的元素集合，其中元素是唯一的，并且可以按照一定的顺序排列。</p>
<p>实现：有序集合对象的 encoding 有 ziplist 和 skiplist 两种。</p>
<ol>
<li>当有序集合中的元素数量小于 512，并且所有元素的长度都小于 64 字节时，使用压缩列表 (ziplist) 存储；</li>
<li>当有序集合中的元素数量大于等于 512，或者有元素长度大于 64 字节时，使用跳表 (skiplist) 存储。</li>
</ol>
<p>使用场景：</p>
<ul>
<li>排行榜：根据分数排序的排行榜，如游戏得分、用户贡献度等。</li>
<li>优先级队列：每个元素都有一个优先级，可以按优先级取出元素。</li>
<li>时间轴：按时间戳排序的消息或帖子显示，如微博、Facebook 的时间线。</li>
<li>地理信息：存储地理位置信息，并使用 GEO 命令查询附近的地点。</li>
</ul>
<h4 id="其他数据结构"><a class="markdownIt-Anchor" href="#其他数据结构">#</a> 其他数据结构</h4>
<ul>
<li>
<p>Bitmaps：二进制位数组，适合用于存储大量稀疏数据，如用户访问记录、权限控制等。</p>
<p>使用场景：</p>
<ul>
<li>统计分析：例如统计某一天有多少独立用户访问了网站，可以使用一个位图来表示每个用户是否访问过。</li>
<li>权限管理：每个用户可以有多个权限位，使用位图来表示用户的权限。</li>
</ul>
</li>
<li>
<p>HyperLogLog：用于近似计算不重复元素的数量，非常适合处理大规模数据集。</p>
<p>使用场景：</p>
<ul>
<li>近似计数：用于估算大量数据中的不重复元素数量，例如统计网站的独立访客数。</li>
</ul>
</li>
<li>
<p>Streams：类似于消息队列，用于处理异步消息传递，可以实现类似 Kafka 的功能。</p>
<p>使用场景：</p>
<ul>
<li>事件日志：记录系统中的事件，如用户行为日志，可以使用 XADD 添加事件，XREAD 读取事件。</li>
<li>异步处理：作为消息队列的一部分，将事件发布到流中，然后由消费者异步处理。</li>
</ul>
</li>
<li>
<p>Geo：用于存储地理位置信息，并提供基于地理位置的查询功能。</p>
<p>使用场景：</p>
<ul>
<li>位置服务：存储地理位置信息，并支持基于地理位置的搜索，如查找附近的餐厅或酒店。</li>
</ul>
</li>
</ul>
<h4 id="redis-综合应用示例"><a class="markdownIt-Anchor" href="#redis-综合应用示例">#</a> Redis 综合应用示例</h4>
<p>假设我们要构建一个社交网络应用，可以使用 Redis 来实现以下功能：</p>
<ul>
<li>用户信息存储：使用 Hash 类型存储每个用户的个人信息，如用户名、头像、生日等。</li>
<li>好友关系：使用 Set 类型存储每个用户的好友列表。</li>
<li>动态时间线：使用 Sorted Set 类型存储用户的动态，根据发布时间排序。</li>
<li>消息通知：使用 List 类型作为消息队列，存储用户收到的通知消息。</li>
<li>在线状态：使用 BitMap 类型记录每天用户的在线状态。</li>
<li>热门话题：使用 HyperLogLog 类型来估计参与某个话题讨论的独立用户数量。</li>
</ul>
<h2 id="redis-的持久化"><a class="markdownIt-Anchor" href="#redis-的持久化">#</a> Redis 的持久化</h2>
<p>redis 是一个内存数据库，数据保存在内存中，但是我们都知道内存的数据变化是很快的，也容易发生丢失。幸好 Redis 还为我们提供了持久化的机制，分别是 RDB (<br>
Redis DataBase) 和 AOF (Append Only File)。</p>
<h3 id="rdb机制"><a class="markdownIt-Anchor" href="#rdb机制">#</a> RDB 机制</h3>
<p>RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为 dump.rdb。</p>
<p>Redis 提供了三种机制：save、bgsave、自动化来触发 RDB 持久化过程：</p>
<ul>
<li>
<p>save 触发方式</p>
<p>该命令会阻塞当前 Redis 服务器，执行 save 命令期间，Redis 不能处理其他命令，直到 RDB 过程完成为止。具体流程如下：</p>
<img data-src="/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg" class="" title="e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg">
<p>执行完成时候如果存在老的 RDB 文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p>
</li>
<li>
<p>bgsave 触发方式</p>
<p>执行该命令时，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：</p>
<img data-src="/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg" class="" title="023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg">
<p>具体操作是 Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短。基本上<br>
 Redis 内部所有的 RDB 操作都是采用 bgsave 命令。</p>
</li>
<li>
<p>自动触发</p>
<p>自动触发是由我们的配置文件来完成的。在 redis.conf 配置文件中，里面有如下配置，我们可以去设置：</p>
<ol>
<li>save：这里是用来配置触发 Redis 的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如 “save m<br>
n”。表示 m 秒内数据集存在 n 次修改时，自动触发 bgsave。</li>
<li>stop-writes-on-bgsave-error：默认值为 yes。<br>
当启用了 RDB 且最后一次后台保存数据失败，Redis 是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果 Redis 重启了，那么又可以重新开始接收数据了</li>
<li>rdbcompression；默认值是 yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</li>
<li>rdbchecksum：默认值是 yes。在存储快照后，我们还可以让 redis 使用 CRC64 算法来进行数据校验，但是这样做会增加大约 10% 的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</li>
<li>dbfilename：设置快照的文件名，默认是 dump.rdb</li>
<li>dir：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</li>
</ol>
<p>我们可以修改这些配置来实现我们想要的效果。</p>
</li>
</ul>
<p>因为第三种方式是配置的，所以我们对前两种进行一个对比：</p>
<img data-src="/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/1c950a7b02087bf43b4490d50ac25f2a11dfcf7e.jpeg" class="" title="1c950a7b02087bf43b4490d50ac25f2a11dfcf7e.jpeg">
<p>RDB 的优势和劣势</p>
<ul>
<li>
<p>优势</p>
<ul>
<li>RDB 文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</li>
<li>生成 RDB 文件的时候，redis 主进程会 fork () 一个子进程来处理所有保存工作，主进程不需要进行任何磁盘 IO 操作。</li>
<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
</ul>
</li>
<li>
<p>劣势</p>
<ul>
<li>RDB 快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。<br>
当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</li>
</ul>
</li>
</ul>
<h3 id="aof机制"><a class="markdownIt-Anchor" href="#aof机制">#</a> AOF 机制</h3>
<p>全量备份总是耗时的，Redis 提供一种更加高效的方式 AOF，工作机制很简单，Redis 会将每一个收到的写命令都通过 write 函数追加到文件中。通俗的理解就是日志记录。</p>
<ol>
<li>
<p>持久化原理</p>
<p>他的原理看下面这张图：</p>
<img data-src="/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/32fa828ba61ea8d3c2502e396b1b3848251f58b0.jpeg" class="" title="32fa828ba61ea8d3c2502e396b1b3848251f58b0.jpeg">
<p>每当有一个写命令过来时，就直接保存在我们的 AOF 文件中。</p>
</li>
<li>
<p>文件重写原理</p>
<p>AOF 的方式也同时带来了另一个问题：持久化文件会变的越来越大。为了解决这个问题，redis 提供了 bgrewriteaof 命令用来压缩 aof 的持久化文件。这条命令会将内存中的数据以命令的方式保存到临时文件中，同时会 fork 出一条新进程来将文件重写。</p>
<img data-src="/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/09fa513d269759ee28454d2c4cea4b106c22dfd3.jpeg" class="" title="09fa513d269759ee28454d2c4cea4b106c22dfd3.jpeg">
<p>重写 aof 文件的操作，并没有读取旧的 aof 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 aof 文件，这点和快照有点类似。</p>
</li>
</ol>
<p>AOF 也有三种触发机制</p>
<ul>
<li>每修改同步 always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</li>
<li>每秒同步 everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失</li>
<li>不同 no：从不同步</li>
</ul>
<p>三种触发机制的对比如下图</p>
<img data-src="/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/b17eca8065380cd7df69859ba056a5325982816c.jpeg" class="" title="b17eca8065380cd7df69859ba056a5325982816c.jpeg">
<p>AOF 的优势和劣势</p>
<ul>
<li>优势
<ul>
<li>AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次 fsync 操作，最多丢失 1 秒钟的数据。</li>
<li>AOF 日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</li>
<li>AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</li>
<li>AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。<br>
比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据</li>
</ul>
</li>
<li>缺点
<ul>
<li>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大</li>
<li>AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的</li>
</ul>
</li>
</ul>
<h3 id="持久化机制的选择"><a class="markdownIt-Anchor" href="#持久化机制的选择">#</a> 持久化机制的选择</h3>
<p>通常情况下我们是二者结合使用的。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>丢数据</td>
<td>取决于刷盘策略</td>
</tr>
<tr>
<td>轻重</td>
<td>重</td>
<td>轻</td>
</tr>
</tbody>
</table>
<p>RDB 使用场景</p>
<ul>
<li>数据恢复要求不高：如果应用程序可以接受在两次快照之间数据丢失的风险，那么 RDB 是一个很好的选择。</li>
<li>需要快速恢复大量数据：由于 RDB 文件是一个完整的数据库快照，因此在需要快速恢复大量数据时，RDB 提供了更快的恢复速度。</li>
<li>定期备份：RDB 适用于需要定期进行完整备份的场景，比如每天一次的全量备份。</li>
<li>数据归档：RDB 文件可以轻松地传输到远程服务器或存储设备上，用于长期的数据归档或灾难恢复。</li>
</ul>
<p>AOF 使用场景</p>
<ul>
<li>数据安全性要求高：如果应用程序不能容忍任何数据丢失，那么 AOF 是更好的选择，因为它可以保证数据的完整性。</li>
<li>频繁写入操作：对于写密集型的应用场景，AOF 可以更好地保证数据的一致性。</li>
<li>数据重放：AOF 文件可以用来重放数据，这对于调试和审计非常有用。</li>
<li>自动修复：Redis 可以定期对 AOF 文件进行重写，以压缩文件大小并移除冗余命令。</li>
</ul>
<h2 id="redis-的内存调度"><a class="markdownIt-Anchor" href="#redis-的内存调度">#</a> Redis 的内存调度</h2>
<h3 id="redis-的过期策略"><a class="markdownIt-Anchor" href="#redis-的过期策略">#</a> Redis 的过期策略</h3>
<h4 id="设置过期时间"><a class="markdownIt-Anchor" href="#设置过期时间">#</a> 设置过期时间</h4>
<p>Redis 对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置 key 的有效时间。Expires 字典保存了所有键的过期时间，Expires 也被称为过期字段。</p>
<p>一般主要包括 5 种处理过期方式，其中 expire 都是以秒为单位，pexpire 都是以毫秒为单位的。</p>
<ul>
<li><code>EXPIRE key seconds</code> ：将 key 的生存时间设置为 ttl 秒</li>
<li><code>PEXPIRE key milliseconds</code> ：将 key 的生成时间设置为 ttl 毫秒</li>
<li><code>EXPIREAT key timestamp</code> ：将 key 的过期时间设置为 timestamp 所代表的的秒数的时间戳</li>
<li><code>PEXPIREAT key milliseconds-timestamp</code> ：将 key 的过期时间设置为 timestamp 所代表的的毫秒数的时间戳</li>
<li><code>setex(String key, int seconds, String value)</code> ：字符串独有的方式，为指定的 key 设置值及其过期时间。如果 key 已经存在，<br>
SETEX 命令将会替换旧的值。</li>
</ul>
<p>注：</p>
<ul>
<li>timestamp 为 unix 时间戳（例如：timestamp=1499788800 表示将在 2017.07.12 过期）</li>
<li>1、2 两种方式是设置一个过期的时间段，就是咱们处理验证码最常用的策略，设置三分钟或五分钟后失效，把分钟数转换成秒或毫秒存储到 Redis 中。</li>
<li>3、4 两种方式是指定一个过期的时间 ，比如优惠券的过期时间是某年某月某日，只是单位不一样。</li>
<li>如果没有设置时间，那缓存就是永不过期</li>
<li>如果设置了过期时间，之后又想让缓存永不过期，使用 persist key</li>
</ul>
<h4 id="过期策略"><a class="markdownIt-Anchor" href="#过期策略">#</a> 过期策略</h4>
<ul>
<li>
<p>定时过期（Active Expiration）</p>
<p>含义：当一个键设置了过期时间时，Redis 会在键的过期时间到达时立即清除这个键。</p>
<p>优点：这种方法可以保证内存被尽快释放，过期的键不会占用内存太久。</p>
<p>缺点：定时过期需要为每个设置了过期时间的键创建一个定时器，这会占用大量的 CPU 资源来处理过期的数据，从而影响 Redis 的响应时间和吞吐量。</p>
</li>
<li>
<p>被动过期（Lazy Expiration）</p>
<p>含义：当访问一个键时，Redis 会检查这个键是否已经过期。如果过期，Redis 会删除这个键并返回相应的错误信息给客户端。</p>
<p>优点：这种方法对 CPU 资源友好，因为它只在访问键时才会检查过期情况。</p>
<p>缺点：如果过期的键没有被及时访问，那么它将继续占用内存，直到被访问或通过其他方式清理掉为止。</p>
<p>流程：</p>
<ol>
<li>在进行 get 或 setnx 等操作时，先检查 key 是否过期，</li>
<li>若过期，删除 key，然后执行相应操作；</li>
<li>若没过期，直接执行相应操作</li>
</ol>
</li>
<li>
<p>定期过期（Periodic Reaping）</p>
<p>含义：Redis 会周期性地检查过期的键，并删除一部分过期的键。这种策略试图在内存消耗和 CPU 使用之间找到一个平衡点，可以通过</p>
<ul>
<li>配置 redis.conf 的 hz 选项，默认为 10 （即 1 秒执行 10 次，100ms 一次，值越大说明刷新频率越快，对 Redis 性能损耗也越大）</li>
<li>配置 redis.conf 的 maxmemory 最大值，当已用内存超过 maxmemory 限定时，就会触发主动清理策略。</li>
</ul>
<p>优点：通过周期性地检查和删除过期键，可以有效地减少内存浪费，同时通过限制删除操作的执行时长和频率来减少对 CPU 时间的影响。</p>
<p>缺点：难以确定删除操作执行的时长和频率。如果删除操作执行得太频繁或执行的时间太长，定期删除策略就会退化成定时删除，导致占用太多的 CPU 执行时间。如果删除操作执行得太少或执行时间太短，定期删除策略又会类似于被动过期，导致内存浪费。</p>
<p>流程：其核心是对指定个数个库的每一个库随机删除小于等于指定个数个过期 key：</p>
<ol>
<li>遍历每个数据库（就是 redis.conf 中配置的 “database” 数量，默认为 16）；
<ol>
<li>检查当前库中的指定个数个 key （默认是每个库检查 20 个，相当于该循环执行 20 次）：
<ol>
<li>如果当前库中没有一个 key 设置了过期时间，直接执行下一个库的遍历；</li>
<li>随机获取一个设置了过期时间的 key，检查是否过期，如果过期则删除；</li>
<li>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<p>综合策略</p>
<p>在实际应用中，Redis 通常会结合使用上述三种策略来管理过期键。例如，Redis 可能会使用定期过期作为主要的过期策略，同时辅以被动过期来处理未被定期过期策略捕获的过期键。此外，对于一些关键操作，Redis 可能会采用定时过期来确保某些重要键在过期后能够立即被释放。</p>
<h4 id="持久化中的过期"><a class="markdownIt-Anchor" href="#持久化中的过期">#</a> 持久化中的过期</h4>
<ul>
<li>
<p>RDB 对过期 key 的处理</p>
<p>过期 key 对 RDB 没有任何影响</p>
<ul>
<li>从内存数据库持久化数据到 RDB 文件
<ul>
<li>持久化 key 之前，会检查是否过期，过期的 key 不进入 RDB 文件</li>
</ul>
</li>
<li>从 RDB 文件恢复数据到内存数据库
<ul>
<li>数据载入数据库之前，会对 key 先进行过期检查，如果过期，不导入数据库（主库情况）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>AOF 对过期 key 的处理<br>
过期 key 对 AOF 没有任何影响</p>
<ul>
<li>从内存数据库持久化数据到 AOF 文件：
<ul>
<li>当 key 过期后，还没有被删除，此时进行执行持久化操作（该 key 是不会进入 aof 文件的，因为没有发生修改命令）</li>
<li>当 key 过期后，在发生删除操作时，程序会向 aof 文件追加一条 del 命令（在将来的以 aof 文件恢复数据的时候该过期的键就会被删掉）</li>
</ul>
</li>
<li>AOF 重写
<ul>
<li>重写时，会先判断 key 是否过期，已过期的 key 不会重写到 aof 文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="pipeline"><a class="markdownIt-Anchor" href="#pipeline">#</a> Pipeline</h2>
<p>Redis 的 Pipeline 功能允许客户端将多个命令打包成一个请求发送给 Redis 服务器，而不是逐个发送命令。这样做可以显著减少客户端与服务器之间的网络往返次数，从而提高<br>
 Redis 的性能和效率。下面详细介绍 Redis Pipeline 的工作原理、使用场景以及如何使用。</p>
<p>Pipeline 的工作原理</p>
<ol>
<li>打包命令：客户端将多个 Redis 命令打包成一个请求，这个请求包含了所有命令的数据。</li>
<li>发送请求：客户端一次性将打包好的请求发送给 Redis 服务器。</li>
<li>执行命令：Redis 服务器接收到请求后，依次执行其中的所有命令。</li>
<li>返回结果：Redis 服务器将各个命令的结果保存起来，并在所有命令执行完毕后，一次性将所有结果返回给客户端。</li>
<li>处理结果：客户端接收到所有命令的结果后，按顺序处理这些结果。</li>
</ol>
<p>Pipeline 的优点</p>
<ul>
<li>减少网络延迟：通过减少客户端与服务器之间的网络往返次数，Pipeline 可以显著降低网络延迟，提高整体性能。</li>
<li>提高吞吐量：由于减少了网络交互次数，客户端可以更快地处理更多的命令。</li>
<li>事务性操作：虽然 Pipeline 不保证命令执行的原子性，但是它可以模拟事务的行为，即可以将一组命令作为一个整体发送和接收结果。</li>
</ul>
<p>使用场景</p>
<ul>
<li>批量操作：当你需要执行一系列相关联的命令时，使用 Pipeline 可以提高效率。</li>
<li>性能优化：在需要频繁与 Redis 进行交互的应用场景中，使用 Pipeline 可以减少网络开销，提升性能。</li>
<li>模拟事务：虽然 Redis 的 Pipeline 不保证命令的原子性，但是在不需要严格事务性的场景下，可以使用 Pipeline 来模拟事务行为。</li>
</ul>
<p>如何使用 Pipeline<br>
 在不同的 Redis 客户端库中，使用 Pipeline 的方式略有不同。以下是在几种常见语言中使用 Pipeline 的示例：</p>
<p>JavaScript (Node.js)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> redis = <span class="built_in">require</span>(<span class="string">&quot;redis&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> client = redis.<span class="title function_">createClient</span>();</span><br><span class="line"></span><br><span class="line">client.<span class="title function_">pipeline</span>()</span><br><span class="line">    .<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">    .<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">    .<span class="title function_">exec</span>(<span class="function">(<span class="params">err, replies</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(replies); <span class="comment">// replies is an array of responses</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>Python (redis-py)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const redis = require(<span class="string">&quot;redis&quot;</span>);</span><br><span class="line">const client = redis.createClient();</span><br><span class="line"></span><br><span class="line">client.pipeline()</span><br><span class="line">  .<span class="built_in">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">  .get(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">  .<span class="built_in">exec</span>((err, replies) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) throw err;</span><br><span class="line">    console.log(replies); // replies <span class="keyword">is</span> an array of responses</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>java (jedis)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">Jedis jedis=<span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        Pipeline pipelined=jedis.pipelined();</span><br><span class="line">        pipelined.set(<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        pipelined.get(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        List&lt;Object&gt; results=pipelined.syncAndReturnAll();</span><br><span class="line">        System.out.println(results);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>注意事项</p>
<ul>
<li>命令数量：虽然 Pipeline 可以显著提高性能，但如果打包的命令数量过多，可能会导致单个请求的体积过大，增加客户端的等待时间，并可能导致网络阻塞。</li>
<li>命令执行顺序：Pipeline 中的命令是按照发送顺序执行的，因此需要确保命令间的依赖关系不会导致错误。</li>
<li>错误处理：如果 Pipeline 中的某条命令执行失败，整个 Pipeline 的结果都会受到影响。因此，在处理 Pipeline<br>
 的结果时，需要注意检查每个命令的执行状态。</li>
</ul>
<p>原生批命令 (mset, mget) 与 Pipeline 对比</p>
<ul>
<li>原生批命令是原子性，pipeline 是非原子性</li>
<li>原生批命令一命令多个 key, 但 pipeline 支持多命令（存在事务），非原子性</li>
<li>原生批命令是服务端实现，而 pipeline 需要服务端与客户端共同完成</li>
</ul>
<h2 id="redis-事务"><a class="markdownIt-Anchor" href="#redis-事务">#</a> Redis 事务</h2>
<p>Redis 事务是 Redis 中的一个重要特性，它允许客户端在一个事务中执行多个命令，并确保这些命令要么全部执行成功，要么全部执行失败。在事务中，客户端可以提交或回滚整个事务，而不需要关心事务中的命令是否成功执行。尽管<br>
 Redis 事务并不提供传统意义上的 ACID 事务特性（原子性、一致性、隔离性、持久性），但它确实提供了一些基本的功能，使得开发者可以更方便地处理一系列相关的命令。</p>
<p>Redis 事务的主要功能包括：</p>
<ul>
<li>命令队列：客户端可以将多个命令放入一个队列中，然后通过 EXEC 命令一次性发送给 Redis 服务器执行。</li>
<li>监视（WATCH）：客户端可以监视一个或多个键，如果在执行 EXEC 命令之前这些键被其他客户端修改，则事务会被取消。</li>
<li>取消（DISCARD）：如果在事务执行之前发现某些条件不满足，客户端可以选择取消事务。</li>
</ul>
<p>Redis 事务的实现分为几个步骤：</p>
<ul>
<li>事务开始：客户端通过 MULTI 命令开始一个事务。</li>
<li>命令入队：在 MULTI 命令之后，客户端可以发送任意数量的命令，这些命令将被放入事务队列中，但不会立即执行。</li>
<li>事务执行：通过 EXEC 命令，客户端可以执行事务队列中的所有命令。如果在此之前使用了 WATCH 命令监视的键被修改，则事务会被取消。</li>
<li>取消事务：如果在执行 EXEC 命令之前，客户端想要取消事务，可以使用 DISCARD 命令。</li>
</ul>
<p>Redis 中事务的特性有：</p>
<ul>
<li>原子性：一旦事务开始执行，Redis 会保证事务中的所有命令要么全部执行成功，要么都不执行。然而，如果命令在执行过程中出现错误（如类型错误），Redis<br>
 会继续执行后续命令。</li>
<li>一致性：Redis 事务在一定程度上保证了一致性，特别是通过使用 WATCH 命令监视键的变化，可以防止脏读。</li>
<li>隔离性：由于 Redis 是单线程的，事务中的命令会按顺序执行，因此不存在并发事务之间的隔离性问题。</li>
<li>持久性：Redis 的持久化机制（如 RDB 或 AOF）保证了数据的持久性，但这与事务无关。</li>
</ul>
<p>Redis 事务的限制</p>
<ul>
<li>不支持回滚：如果事务中的某个命令失败，Redis 会继续执行剩余的命令，并不会回滚之前的命令。</li>
<li>错误处理：如果事务中的命令出现错误，Redis 会记录错误并继续执行后续命令。客户端需要处理这些错误。</li>
<li>性能考虑：虽然事务可以减少网络往返次数，但如果事务中的命令数量过多，可能会导致单个请求过大，反而影响性能。</li>
</ul>
<p>Redis 事务的使用场景</p>
<ul>
<li>批量操作：当需要执行一系列相关的命令时，可以使用事务来减少网络往返次数，提高性能。</li>
<li>乐观锁：通过 WATCH 命令监视键的变化，可以实现乐观锁机制，确保在执行事务之前键没有被其他客户端修改。</li>
<li>模拟事务：虽然 Redis 事务不提供严格的 ACID 特性，但在不需要强一致性的场景下，可以使用事务来模拟事务行为。</li>
</ul>
<h2 id="redis-多线程"><a class="markdownIt-Anchor" href="#redis-多线程">#</a> Redis 多线程</h2>
<p>Redis 作为一种高性能的键值存储系统，最初是单线程设计的，这意味着 Redis 在处理客户端的请求时，包括获取 (socket 读)<br>
、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的单线程。但如果严格来讲从 Redis 4<br>
 之后并不是单线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 key 的删除等等。<br>
这样的设计保证了数据的一致性和简单性，但也限制了 Redis 在多核 CPU 环境下的性能潜力。从 Redis 6.0 开始，Redis<br>
 引入了多线程的支持，以充分利用现代多核处理器的优势。</p>
<p>Redis 6 为何引入多线程？</p>
<p>随着目前行业内越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的<br>
 QPS。常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点，比如：</p>
<ul>
<li>
<p>要管理的 Redis 服务器太多，维护代价大；</p>
</li>
<li>
<p>某些适用于单个 Redis 服务器的命令不适用于数据分区；</p>
</li>
<li>
<p>数据分区无法解决热点读 / 写问题；</p>
</li>
<li>
<p>数据偏斜，重新分配和放大 / 缩小变得更加复杂等等。</p>
</li>
</ul>
<p>从 Redis 自身角度来说，因为读写网络的 read/write 系统调用占用了 Redis 执行期间大部分 CPU 时间，瓶颈主要在于网络的 IO 消耗，<br>
 优化主要有两个方向:</p>
<ul>
<li>
<p>提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式；</p>
</li>
<li>
<p>使用多线程充分利用多核，典型的实现比如 Memcached。</p>
</li>
</ul>
<p>协议栈优化的这种方式跟 Redis 关系不大，支持多线程是一种最有效最便捷的操作方式。所以总结起来，Redis 支持多线程主要就是两个原因：</p>
<ul>
<li>可以充分利用服务器 CPU 资源，目前主线程只能利用一个核；</li>
<li>多线程任务可以分摊 Redis 同步 IO 读写负荷。</li>
</ul>
<p>Redis 多线程的工作原理</p>
<p>在 Redis 6.0 中，多线程主要用于处理客户端的网络 I/O 操作，包括读取客户端请求、解析请求以及将响应写回到客户端。具体来说：</p>
<ul>
<li>多线程 I/O：Redis 在主线程之外创建了若干个 I/O 子线程，这些子线程负责读取客户端的请求数据，并将其传递给主线程进行处理。主线程处理完请求后，子线程再负责将响应写回到客户端。</li>
<li>命令执行：尽管引入了多线程，Redis 的命令执行仍然是单线程的。这意味着 Redis 仍然保证了数据的一致性，因为所有命令都在同一个线程中顺序执行。</li>
</ul>
<p>配置多线程</p>
<p>Redis 6.0 中的多线程支持需要在 redis.conf 文件中进行配置。Redis 6 的多线程默认是禁用的，只使用主线程。可以通过设置<br>
 io-threads-do-reads 参数来启用多线程 I/O 支持，并指定子线程的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io-threads 4  # 设置子线程的数量</span><br><span class="line">io-threads-do-reads yes  # 启用子线程读取</span><br></pre></td></tr></table></figure>
<p>官方建议线程数应小于机器的核数，并且给出了一个简单的指导原则：对于 4 核的机器，建议设置 2 或 3 个线程；对于 8 核的机器，建议设置<br>
 6 个线程。线程数并不是越多越好，一般超过 8 个线程就没有太多的意义了。</p>
<p>使用场景</p>
<ul>
<li>网络 I/O 密集型操作：当 Redis 实例面临大量的网络 I/O 负载时，多线程可以帮助减轻主线程的压力，提高系统的整体吞吐量。</li>
<li>多核 CPU 利用率：在多核处理器环境下，多线程可以让 Redis 更好地利用硬件资源，特别是在处理高并发请求时。</li>
</ul>
<p>注意事项</p>
<ul>
<li>单线程命令执行：尽管 Redis 引入了多线程支持，但命令的执行仍然是单线程的。这意味着 Redis 依然保证了数据的一致性和事务的安全性。</li>
<li>适用性：多线程功能最适合在网络 I/O 成为性能瓶颈的情况下使用。如果 Redis 实例的 CPU 占用率已经很高，那么开启多线程可能并不会带来显著的性能提升。</li>
<li>兼容性：在 Redis 的其他模式（如集群模式）中，多线程功能可能不完全适用，因此在使用时需要谨慎。</li>
</ul>
<h2 id="常见面试问题"><a class="markdownIt-Anchor" href="#常见面试问题">#</a> 常见面试问题</h2>
<h3 id="redis-为何这么快"><a class="markdownIt-Anchor" href="#redis-为何这么快">#</a> Redis 为何这么快</h3>
<ul>
<li>内存存储：Redis 将所有数据存储在内存中，而不是磁盘上。内存的读写速度远超磁盘，这使得 Redis 能够实现极低的延迟和高吞吐量。内存中的数据访问速度几乎是瞬时的，而磁盘则需要等待机械臂移动到正确的位置才能开始读写，这大大降低了速度。</li>
<li>高效的数据结构：Redis 提供了多种高效的数据结构，如跳跃表（skiplist）用于实现有序集合（Sorted<br>
Set），压缩列表（ziplist）用于节省空间，哈希表（hashtable）用于实现散列（Hash）等。这些数据结构经过优化，能够在内存中高效地存储和检索数据。</li>
<li>合理的数据编码：Redis 根据数据的不同类型和大小，使用不同的编码格式来存储数据。例如，短字符串可能会使用更为紧凑的编码方式，从而减少内存占用并加快处理速度。</li>
<li>单线程模型：Redis 采用单线程模型来处理客户端的所有请求。这意味着在任何给定的时间内，只有一个客户端请求正在被执行。虽然这限制了并发处理能力，但也消除了多线程之间上下文切换和锁的竞争，从而减少了不必要的开销。</li>
<li>非阻塞 I/O：Redis 使用事件驱动模型来处理客户端连接和请求。它使用了类似于 epoll 的 I/O 多路复用技术来监听多个客户端连接上的事件，<br>
当有事件发生时（例如，客户端发送了一个命令），Redis 会立即处理这个事件。这种方式使得 Redis 可以同时处理大量的客户端连接，而不会因为一个客户端的阻塞而影响其他客户端的响应速度。</li>
<li>异步持久化：为了防止持久化操作影响 Redis 的性能，Redis 提供了异步持久化选项。例如，RDB 快照和 AOF 日志都可以在后台进程执行，不会阻塞主线程处理客户端请求。</li>
<li>线程分离：Redis 6.0 引入了多线程处理部分 I/O 密集型任务，如 AOF 重写和 RDB 持久化，这样可以进一步提高 Redis 的性能，因为这些任务不再完全阻塞单一线程。</li>
</ul>
<h3 id="redis为何使用单线程"><a class="markdownIt-Anchor" href="#redis为何使用单线程">#</a> Redis 为何使用单线程</h3>
<p>Redis 选择单线程模型的原因有以下几个方面：</p>
<ul>
<li>内存操作速度快：Redis 的所有数据都存储在内存中，内存的读写速度非常快。因此，对于基于内存的操作而言，CPU 并不是性能瓶颈。如果使用多线程，反而需要解决多线程同步的问题，这可能会增加额外的 CPU 负担。</li>
<li>数据结构简单：Redis 中的数据结构相对简单，操作也较为迅速，这使得单线程就能够高效地处理大量的客户端请求。</li>
<li>非阻塞 I/O 模型：Redis 使用了非阻塞的 I/O 模型，即多路复用 I/O 机制（如 epoll、select 等）。<br>
这种机制使得单线程可以同时监听多个客户端连接的请求，并在有请求到达时异步地处理这些请求，从而有效地利用了单线程的能力来处理高并发连接。</li>
<li>简化设计：单线程模型简化了 Redis 的设计和实现。由于不存在多线程间的竞争和同步问题，Redis 的代码更加简洁易懂，同时也减少了潜在的 bug。</li>
<li>避免上下文切换开销：多线程模型会导致频繁的上下文切换，这会消耗大量的 CPU 资源。单线程模型避免了这种开销，使得 Redis 可以更加高效地使用 CPU 资源。</li>
<li>易于实现高一致性：单线程模型下，数据的一致性更容易保证，因为不存在多线程并发修改同一份数据的问题。</li>
<li>避免锁的竞争：在多线程环境下，为了避免数据冲突，通常需要使用锁机制。而锁的竞争会导致一部分线程处于等待状态，从而降低了系统的整体吞吐量。单线程模型避免了这种锁的竞争。</li>
</ul>
<p>然而，单线程模型也有其局限性。例如，对于 CPU 密集型的任务，单线程模型可能不是最佳选择，因为这样的任务会阻塞主线程，影响 Redis 处理其他请求的能力。为了解决这个问题，Redis 在后来的版本中引入了多线程来处理 I/O 密集型任务，如 AOF 重写和 RDB 持久化，以此来提升性能。</p>
<h3 id="缓存三大问题以及解决方案"><a class="markdownIt-Anchor" href="#缓存三大问题以及解决方案">#</a> 缓存三大问题以及解决方案？</h3>
<ol>
<li>
<p>缓存击穿：指的是当某个 key 非常热点，在并发访问量大的情况下，如果这个 key 恰好在这个时刻失效了，那么所有请求都会落到数据库上，造成数据库瞬间压力过大。</p>
<p>解决方案：</p>
<ul>
<li>设置热点数据永不过期：对于热点数据，可以将其设置为永不过期，或者设置一个较长的过期时间。
<ul>
<li>优点：
<ol>
<li>减少了因缓存失效导致的数据库压力。</li>
<li>简单易实施。</li>
</ol>
</li>
<li>缺点：
<ol>
<li>可能会导致缓存中的数据长时间不更新，影响数据的新鲜度。</li>
<li>如果数据量很大，可能会占用较多的内存资源。</li>
</ol>
</li>
<li>适用场景：
<ol>
<li>数据更新频率较低，且数据新鲜度要求不高的场景。</li>
</ol>
</li>
</ul>
</li>
<li>互斥锁：使用互斥锁（Mutex）机制来控制缓存更新的过程。当缓存失效时，先获取锁，然后检查数据库中是否有数据，如果有则更新缓存，最后释放锁。
<ul>
<li>优点：
<ol>
<li>可以确保在缓存失效时，只有一部分请求会真正落到数据库上，减少了数据库的压力。</li>
<li>数据更新及时。</li>
</ol>
</li>
<li>缺点：
<ol>
<li>锁的使用会增加系统的复杂性。</li>
<li>如果并发量极高，可能会出现锁竞争激烈的情况。</li>
</ol>
</li>
<li>适用场景：
<ol>
<li>数据更新频繁，且数据新鲜度要求较高的场景。</li>
</ol>
</li>
</ul>
</li>
<li>懒加载：当缓存失效后，可以先返回旧数据或占位符，然后异步加载最新数据并更新缓存。
<ul>
<li>优点：
<ol>
<li>用户体验较好，不会立即感知到数据陈旧。</li>
<li>减少了数据库的瞬时压力。</li>
</ol>
</li>
<li>缺点：
<ol>
<li>数据更新可能有延迟。</li>
<li>实现复杂度较高。</li>
</ol>
</li>
<li>适用场景：
<ol>
<li>数据更新频率适中，对用户体验有一定要求的场景。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>缓存穿透：是指查询一个一定不存在的数据，这个数据在缓存中不存在，同时在数据库中也不存在，每次请求都会直接穿透缓存去查询数据库，造成数据库压力巨大。</p>
<p>解决方案：</p>
<ul>
<li>设置空值缓存：当查询到数据库中不存在的数据时，可以将这个查询结果（通常是 null 或特殊标识）缓存起来，设置一定的过期时间。
<ul>
<li>优点：
<ol>
<li>直接解决了缓存穿透问题，减少了对数据库的无效请求。</li>
</ol>
</li>
<li>缺点：
<ol>
<li>如果恶意攻击者利用不存在的 key 频繁请求，可能会导致缓存中存储大量无效数据。</li>
<li>需要合理设置过期时间，避免长期占用缓存空间。</li>
</ol>
</li>
<li>适用场景：
<ol>
<li>适用于存在大量无效查询请求的场景。</li>
</ol>
</li>
</ul>
</li>
<li>布隆过滤器（Bloom Filter）：使用布隆过滤器来判断数据是否存在，可以有效地拦截那些一定不存在的数据查询。
<ul>
<li>优点：
<ol>
<li>有效拦截不存在的数据查询，减少无效请求。</li>
<li>占用空间小，查询速度快。</li>
</ol>
</li>
<li>缺点：
<ol>
<li>存在一定的误判率，即可能存在少量的假阳性（False Positive）。</li>
<li>需要合理设计布隆过滤器的容量和哈希函数数量。</li>
</ol>
</li>
<li>适用场景：
<ol>
<li>适用于数据量大且对数据精确性有一定容忍度的场景。</li>
</ol>
</li>
</ul>
</li>
<li>API 层面的验证：在业务逻辑层面增加对输入数据的校验，提前过滤掉非法或无效的查询请求。
<ul>
<li>优点：
<ol>
<li>从源头上过滤掉非法请求，减轻后续处理层的压力。</li>
<li>提升系统的安全性。</li>
</ol>
</li>
<li>缺点：
<ol>
<li>需要在业务逻辑中增加额外的验证步骤，增加了开发工作量。</li>
<li>可能需要维护一份合法 key 的列表或规则。</li>
</ol>
</li>
<li>适用场景：
<ol>
<li>适用于存在非法请求可能性的场景。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>缓存雪崩：是指当缓存中的数据集中过期，导致大量请求同时穿透缓存去查询数据库，造成数据库压力剧增甚至崩溃。</p>
<p>解决方案：</p>
<ul>
<li>分散缓存过期时间：避免大量数据同时过期，可以通过随机化设置过期时间来分散数据的过期时间。
<ul>
<li>优点：
<ol>
<li>有效避免了大量数据同时过期的情况，降低了数据库的压力。</li>
<li>实现简单。</li>
</ol>
</li>
<li>缺点：
<ol>
<li>需要合理设置随机过期时间，以确保数据分布均匀。</li>
</ol>
</li>
<li>适用场景：
<ol>
<li>适用于数据量较大且有过期时间一致性的风险的场景。</li>
</ol>
</li>
</ul>
</li>
<li>限流降级：在缓存失效前，通过限流算法来控制请求的流量，一旦超过阈值则进行降级处理，返回默认值或缓存中的旧数据。
<ul>
<li>优点：
<ol>
<li>通过限流机制保护了后端系统，避免了突发流量的影响。</li>
<li>可以根据实际情况调整限流策略。</li>
</ol>
</li>
<li>缺点：
<ol>
<li>需要设计合理的降级策略，以确保用户体验不受太大影响。</li>
<li>实现复杂度较高。</li>
</ol>
</li>
<li>适用场景：
<ol>
<li>适用于流量波动较大的场景。</li>
</ol>
</li>
</ul>
</li>
<li>备用缓存：准备一个备用缓存系统，当主缓存系统出现故障或过载时，可以切换到备用缓存继续服务。
<ul>
<li>优点：
<ol>
<li>提供了冗余保障，增强了系统的可用性。</li>
<li>可以平滑地切换到备用系统，减少服务中断时间。</li>
</ol>
</li>
<li>缺点：
<ol>
<li>需要维护两套缓存系统，增加了运维成本。</li>
<li>切换逻辑需要考虑数据同步问题。</li>
</ol>
</li>
<li>适用场景：
<ol>
<li>适用于对系统可用性要求较高的场景。</li>
</ol>
</li>
</ul>
</li>
<li>异步更新：当缓存失效时，可以先返回旧数据或占位符，然后异步加载最新数据并更新缓存。
<ul>
<li>优点：
<ol>
<li>用户体验较好，不会立即感知到数据陈旧。</li>
<li>减少了数据库的瞬时压力。</li>
</ol>
</li>
<li>缺点：
<ol>
<li>数据更新可能有延迟。</li>
<li>实现复杂度较高。</li>
</ol>
</li>
<li>适用场景：
<ol>
<li>适用于数据更新频率适中，对用户体验有一定要求的场景。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="如何保证数据库和redis缓存一致性"><a class="markdownIt-Anchor" href="#如何保证数据库和redis缓存一致性">#</a> 如何保证数据库和 Redis 缓存一致性？</h3>
<ol>
<li>
<p>最终一致性（Eventual Consistency）</p>
<p>在分布式系统中，通常追求的是最终一致性而非强一致性。最终一致性意味着在一段时间后，所有数据副本将收敛到同一个状态。对于缓存和数据库来说，这意味着在数据更新后，缓存最终会反映数据库中的最新状态。</p>
</li>
<li>
<p>双写策略</p>
<ol>
<li>
<p>先更新数据库，再删除缓存（Update Database First, Invalidate Cache）</p>
<p>原理：当数据发生变化时，首先更新数据库中的数据，然后再删除缓存中的对应条目。当下次请求该数据时，由于缓存中没有该数据，所以会重新从数据库中读取并更新缓存。</p>
<ul>
<li>优点：
<ul>
<li>简单易实现。</li>
<li>可以避免数据不一致的问题。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>如果删除缓存失败，则可能导致缓存中的数据比数据库中的数据旧。</li>
<li>删除缓存操作可能会失败，需要有重试机制。</li>
</ul>
</li>
<li>适用场景：
<ul>
<li>更新操作较少，且对数据一致性要求较高的场景。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>先删除缓存，再更新数据库（Invalidate Cache First, Update Database）</p>
<p>原理：当数据发生变化时，先删除缓存中的数据，然后再更新数据库中的数据。</p>
<ul>
<li>优点：
<ul>
<li>可以避免缓存击穿问题。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>如果更新数据库失败，而缓存已经被删除，那么这段时间内将无法从缓存中获取数据，导致请求直接访问数据库，增加数据库压力。</li>
<li>如果删除缓存和更新数据库之间有延迟，可能会导致短暂的数据不一致。</li>
</ul>
</li>
<li>适用场景：
<ul>
<li>更新操作频繁，但对数据一致性要求稍低的场景。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>延迟双删策略（Double Eviction with Delay）</p>
<p>原理：当数据更新时，先删除缓存中的数据，然后立即设置一个临时缓存项（如使用 Redis 的 EXPIRE 命令设置一个很短的过期时间），再更新数据库。当临时缓存项过期后，真正的更新操作完成。</p>
<ul>
<li>优点：
<ul>
<li>减少了直接访问数据库的概率。</li>
<li>通过设置临时缓存项，可以减少更新数据库失败导致的数据不一致问题。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>实现相对复杂。</li>
</ul>
</li>
<li>适用场景：
<ul>
<li>高并发场景下，对数据一致性要求较高的场景。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>使用消息队列</p>
<p>原理：当数据在数据库中更新后，发送一个消息到消息队列中，由另一个消费者监听消息队列并更新缓存。</p>
<ul>
<li>优点：
<ul>
<li>解耦数据库和缓存更新操作。</li>
<li>可以异步处理缓存更新，减少数据库更新时的延迟。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>增加了系统的复杂性。</li>
<li>需要处理消息队列的可靠性和消息重复消费问题。</li>
</ul>
</li>
<li>适用场景：
<ul>
<li>高并发、大数据量的场景。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>缓存预热</p>
<p>原理：在系统启动或数据更新后，主动将数据加载到缓存中。</p>
<ul>
<li>优点：
<ul>
<li>避免冷启动时大量请求直接访问数据库。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>需要额外的机制来触发预热操作。</li>
</ul>
</li>
<li>适用场景：
<ul>
<li>系统启动或数据更新后，希望尽快恢复服务的场景。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>乐观锁或版本号</p>
<p>原理：在数据库中为数据添加一个版本号字段，每次更新时都需要检查版本号是否匹配。如果不匹配，则说明数据已被其他操作更新，需要重新获取最新数据并再次尝试更新。</p>
<ul>
<li>优点：
<ul>
<li>保证了数据的一致性。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>可能会出现更新冲突，需要重试机制。</li>
</ul>
</li>
<li>适用场景：
<ul>
<li>对数据一致性要求极高的场景。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="如何保证-redis-的高并发"><a class="markdownIt-Anchor" href="#如何保证-redis-的高并发">#</a> 如何保证 Redis 的高并发？</h3>
<ol>
<li>单机优化
<ul>
<li>硬件优化：选择高性能的硬件设备，如 SSD 硬盘、高速网络接口卡以及足够的内存。</li>
<li>内存管理：合理设置 Redis 的最大内存限制，避免内存溢出导致的服务不可用。</li>
<li>持久化策略：选择合适的持久化方式（RDB 或 AOF），并调整相关的配置，以减少对性能的影响。</li>
<li>数据结构选择：根据应用场景选择合适的数据结构，以减少内存使用并提高访问效率。</li>
</ul>
</li>
<li>主从复制
<ul>
<li>读写分离：通过主从复制实现读写分离，主节点负责写操作，从节点负责读操作，可以显著提高并发处理能力。</li>
<li>自动故障转移：使用 Redis Sentinel（哨兵）机制来监控主从节点的状态，并在主节点发生故障时自动进行故障转移，保证高可用性。</li>
</ul>
</li>
<li>分布式集群
<ul>
<li>Redis Cluster：使用 Redis 集群来水平扩展 Redis，集群可以自动将数据分片存储在不同的节点上，并提供数据复制功能。这样可以支持更高的并发量和更大的数据集。</li>
<li>数据分片：手动将数据分片存储在不同的 Redis 实例上，可以减轻单个节点的压力。</li>
</ul>
</li>
<li>客户端优化
<ul>
<li>连接池：使用连接池来复用客户端连接，减少建立和销毁连接的开销。</li>
<li>批处理：批量处理请求，例如使用 MGET、MSET 等命令来一次处理多个键值对，减少网络往返次数。</li>
<li>命令管道：使用 Redis 的命令管道（pipelining）特性，将多个命令一次性发送给 Redis 服务器，减少网络延迟。</li>
</ul>
</li>
<li>调整配置
<ul>
<li>网络配置：优化网络配置，例如调整 TCP 缓冲区大小、禁用 Nagle 算法等，以提高网络传输效率。</li>
<li>I/O 多路复用：Redis 使用事件驱动模型来处理客户端请求，可以处理大量的并发连接。确保操作系统和 Redis 的事件处理机制配置得当。</li>
</ul>
</li>
<li>监控与调优
<ul>
<li>性能监控：定期监控 Redis 的性能指标，如 CPU 使用率、内存使用情况、网络延迟等，以便及时发现性能瓶颈。</li>
<li>负载均衡：使用负载均衡器来分配客户端请求，确保各个 Redis 节点的负载均衡。</li>
</ul>
</li>
<li>避免热点 Key
<ul>
<li>Key 的设计：合理设计 Key，避免热点 Key 的产生，例如使用哈希分片（Hash Ring）来分散请求。</li>
<li>过期时间：为热点 Key 设置合理的过期时间，并且可以使用随机化过期时间来避免雪崩效应。</li>
</ul>
</li>
<li>异步处理
<ul>
<li>异步持久化：使用异步的方式进行持久化操作，避免阻塞主线程。</li>
<li>多线程处理：Redis 6.0 引入了多线程模型来处理部分 I/O 密集型任务，如 AOF 重写和 RDB 持久化，可以进一步提升性能。</li>
</ul>
</li>
</ol>
<h3 id="redis-如何保证原子性"><a class="markdownIt-Anchor" href="#redis-如何保证原子性">#</a> Redis 如何保证原子性？</h3>
<ol>
<li>单线程模型: Redis 采用单线程模型来处理所有的客户端请求。这意味着在同一时间内，只有一个客户端请求被处理，因此消除了并发竞争条件，保证了命令执行的顺序性和原子性。</li>
<li>命令级别的原子性: Redis 中的大多数命令都是原子性的，这意味着它们在执行过程中不会被其他操作打断。例如，SET, GET, INCR,<br>
DECR, HSET, HGET 等命令在执行时，整个操作过程不会被中断，从而保证了操作的完整性。</li>
<li>事务机制: Redis 提供了事务机制，允许用户将多个命令打包成一个事务，通过 MULTI 命令开启事务，然后执行一系列命令，最后通过 EXEC 命令提交事务。<br>
在事务中，Redis 会将这些命令放入队列中，等到事务提交时，这些命令会按照顺序依次执行，从而保证了事务内的操作的原子性。</li>
<li>WATCH 命令: WATCH 命令可以监视一个或多个键，如果监视的键在执行 EXEC 之前被其他客户端修改了，那么事务会被取消。这实际上是一种乐观锁机制，用来保证在某些特定场景下的数据一致性。</li>
<li>Lua 脚本: Redis 允许在服务器端执行 Lua 脚本来处理复杂的操作。Lua 脚本在执行时具有原子性，即整个脚本作为一个整体执行，期间不会被打断。<br>
这意味着脚本中的多个 Redis 命令会被作为一个单独的操作来执行，从而保证了操作的原子性。</li>
<li>数据结构的设计: Redis 内部的数据结构设计也是为了支持高效的原子操作。例如，对于有序集合（Sorted<br>
Sets），Redis 使用了跳跃表（Skiplist），这是一种支持快速插入、删除和查找操作的数据结构，可以高效地支持原子性操作。</li>
</ol>
<h2 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令">#</a> 常用命令</h2>
<h3 id="cmd访问redis"><a class="markdownIt-Anchor" href="#cmd访问redis">#</a> cmd 访问 redis</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli.exe -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure>
<h3 id="字符串string相关命令"><a class="markdownIt-Anchor" href="#字符串string相关命令">#</a> 字符串 (String) 相关命令</h3>
<ul>
<li>SET key value：设置键 key 的值为 value。</li>
<li>GET key：获取键 key 的值。</li>
<li>GETSET key value：设置键 key 的值为 value，并返回键 key 的旧值。</li>
<li>INCR key：将键 key 的值加一，仅支持整数值。</li>
<li>INCRBY key increment：将键 key 的值加上指定的增量 increment。</li>
<li>DECR key：将键 key 的值减一。</li>
<li>DECRBY key decrement：将键 key 的值减去指定的减量 decrement。</li>
<li>APPEND key value：将 value 追加到键 key 的值后面。</li>
<li>STRLEN key：返回键 key 的值的长度。</li>
</ul>
<h3 id="列表list相关命令"><a class="markdownIt-Anchor" href="#列表list相关命令">#</a> 列表 (List) 相关命令</h3>
<ul>
<li>LPUSH key value [value …]：将一个或多个值 value 插入到键 key 的列表头部。</li>
<li>RPUSH key value [value …]：将一个或多个值 value 插入到键 key 的列表尾部。</li>
<li>LPOP key：移除并返回键 key 的列表的第一个元素。</li>
<li>RPOP key：移除并返回键 key 的列表的最后一个元素。</li>
<li>LRANGE key start stop：返回键 key 的列表中指定范围内的元素。</li>
<li>LREM key count value：移除键 key 的列表中等于 value 的元素，count 参数决定了移除的数量。</li>
<li>LSET key index value：将键 key 的列表中的指定位置 index 的值设为 value。</li>
<li>LLEN key：返回键 key 的列表的长度。</li>
</ul>
<h3 id="哈希hash相关命令"><a class="markdownIt-Anchor" href="#哈希hash相关命令">#</a> 哈希 (Hash) 相关命令</h3>
<ul>
<li>HSET key field value：将哈希表 key 中的域 field 的值设为 value。</li>
<li>HGET key field：返回哈希表 key 中域 field 的值。</li>
<li>HGETALL key：返回哈希表 key 中所有域的值。</li>
<li>HDEL key field [field …]：删除一个或多个哈希表 key 中的域 field。</li>
<li>HEXISTS key field：查看哈希表 key 中指定域 field 是否存在。</li>
<li>HLEN key：返回哈希表 key 中域的数量。</li>
<li>HKEYS key：返回哈希表 key 中所有域的列表。</li>
<li>HVALS key：返回哈希表 key 中所有值的列表。</li>
</ul>
<h3 id="集合set相关命令"><a class="markdownIt-Anchor" href="#集合set相关命令">#</a> 集合 (Set) 相关命令</h3>
<ul>
<li>SADD key member [member …]：将一个或多个成员 member 加入到集合 key 中。</li>
<li>SMEMBERS key：返回集合 key 中的所有成员。</li>
<li>SCARD key：返回集合 key 中的成员数。</li>
<li>SREM key member [member …]：将一个或多个成员 member 从集合 key 中移除。</li>
<li>SISMEMBER key member：判断成员 member 是否是集合 key 的成员。</li>
<li>SINTER key [key …]：返回给定多个集合的交集成员。</li>
<li>SUNION key [key …]：返回给定多个集合的并集成员。</li>
<li>SDIFF key [key …]：返回给定多个集合的差集成员。</li>
</ul>
<h3 id="有序集合sorted-set相关命令"><a class="markdownIt-Anchor" href="#有序集合sorted-set相关命令">#</a> 有序集合 (Sorted Set) 相关命令</h3>
<ul>
<li>ZADD key score member [score member …]：将一个或多个成员 member 及其分数 score 加入到有序集合 key 中。</li>
<li>ZRANGE key start stop [WITHSCORES]：返回有序集合 key 中指定范围内的成员。</li>
<li>ZREVRANGE key start stop [WITHSCORES]：返回有序集合 key 中指定范围内的成员，成员按分数值递减排列。</li>
<li>ZREM key member [member …]：将一个或多个成员 member 从有序集合 key 中移除。</li>
<li>ZCARD key：返回有序集合 key 中的成员数。</li>
<li>ZSCORE key member：返回有序集合 key 中成员 member 的分数值。</li>
<li>ZCOUNT key min max：计算在有序集合 key 中指定区间分数的成员数。</li>
</ul>
<h3 id="通用命令"><a class="markdownIt-Anchor" href="#通用命令">#</a> 通用命令</h3>
<ul>
<li>EXPIRE key seconds：为键 key 设置生存时间。</li>
<li>TTL key：返回键 key 剩余的生存时间。</li>
<li>DEL key [key …]：删除一个或多个键 key。</li>
<li>SELECT index：选择编号为 index 的数据库。</li>
<li>FLUSHDB：清除当前数据库中的所有数据。</li>
<li>FLUSHALL：清除所有数据库中的所有数据。</li>
<li>KEYS pattern：返回匹配 pattern 的所有键。</li>
<li>TYPE key：返回键 key 的类型。</li>
</ul>

      <div class="tags">
          <a href="/joker.github.io/tags/%E5%90%8E%E7%AB%AF/" rel="tag"><i class="ic i-tag"></i> 后端</a>
          <a href="/joker.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"><i class="ic i-tag"></i> 数据库</a>
          <a href="/joker.github.io/tags/NoSQL/" rel="tag"><i class="ic i-tag"></i> NoSQL</a>
          <a href="/joker.github.io/tags/%E7%BC%93%E5%AD%98/" rel="tag"><i class="ic i-tag"></i> 缓存</a>
          <a href="/joker.github.io/tags/Redis/" rel="tag"><i class="ic i-tag"></i> Redis</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2024-09-21 15:29:38" itemprop="dateModified" datetime="2024-09-21T15:29:38+08:00">2024-09-21</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/joker.github.io/images/wechatpay.png" alt="Joker 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/joker.github.io/images/alipay.png" alt="Joker 支付宝">
        <p>支付宝</p>
      </div>
      
      <div>
        <img data-src="/joker.github.io/images/paypal.png" alt="Joker 贝宝">
        <p>贝宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>Joker <i class="ic i-at"><em>@</em></i>Joker
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/" title="【Redis】Redis面试题汇总与详解">https://silvercrow42.github.io/joker.github.io/2024/09/13/【Redis】Redis面试题汇总与详解/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/joker.github.io/2024/09/13/%E3%80%90Spring%E3%80%91spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="prev" data-background-image="&#x2F;joker.github.io&#x2F;2024&#x2F;09&#x2F;13&#x2F;%E3%80%90Spring%E3%80%91spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3&#x2F;26e3bd5f237ab05ae63f5a697805b33b.png" title="【Spring】Spring面试题汇总">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> spring</span>
  <h3>【Spring】Spring面试题汇总</h3>
  </a>

    </div>
    <div class="item right">
    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text"> 概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text"> Redis 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text"> Redis 的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.</span> <span class="toc-text"> Redis 的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text"> Redis 的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 底层数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redisobject"><span class="toc-number">1.4.1.1.</span> <span class="toc-text"> redisObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds"><span class="toc-number">1.4.1.2.</span> <span class="toc-text"> 动态字符串（SDS）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8zip-list"><span class="toc-number">1.4.1.3.</span> <span class="toc-text"> 压缩列表（Zip List）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8linkedlist"><span class="toc-number">1.4.1.4.</span> <span class="toc-text"> 双向链表（linkedlist）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8hashtable"><span class="toc-number">1.4.1.5.</span> <span class="toc-text"> 哈希表（Hashtable）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.1.5.1.</span> <span class="toc-text"> 哈希冲突的优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88intset"><span class="toc-number">1.4.1.6.</span> <span class="toc-text"> 整数集合（intset）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8skip-list"><span class="toc-number">1.4.1.7.</span> <span class="toc-text"> 跳表（Skip List）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 数据结构的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2string"><span class="toc-number">1.4.2.1.</span> <span class="toc-text"> 字符串（String）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8list"><span class="toc-number">1.4.2.2.</span> <span class="toc-text"> 列表（List）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8Chash"><span class="toc-number">1.4.2.3.</span> <span class="toc-text"> 哈希（Hash）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88set"><span class="toc-number">1.4.2.4.</span> <span class="toc-text"> 集合（Set）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88sorted-set"><span class="toc-number">1.4.2.5.</span> <span class="toc-text"> 有序集合（Sorted Set）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.6.</span> <span class="toc-text"> 其他数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.2.7.</span> <span class="toc-text"> Redis 综合应用示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text"> Redis 的持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rdb%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.1.</span> <span class="toc-text"> RDB 机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aof%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text"> AOF 机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.5.3.</span> <span class="toc-text"> 持久化机制的选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E7%9A%84%E5%86%85%E5%AD%98%E8%B0%83%E5%BA%A6"><span class="toc-number">1.6.</span> <span class="toc-text"> Redis 的内存调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.1.</span> <span class="toc-text"> Redis 的过期策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">1.6.1.1.</span> <span class="toc-text"> 设置过期时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.1.2.</span> <span class="toc-text"> 过期策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%AD%E7%9A%84%E8%BF%87%E6%9C%9F"><span class="toc-number">1.6.1.3.</span> <span class="toc-text"> 持久化中的过期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pipeline"><span class="toc-number">1.7.</span> <span class="toc-text"> Pipeline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.8.</span> <span class="toc-text"> Redis 事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.9.</span> <span class="toc-text"> Redis 多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.</span> <span class="toc-text"> 常见面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-%E4%B8%BA%E4%BD%95%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="toc-number">1.10.1.</span> <span class="toc-text"> Redis 为何这么快</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.10.2.</span> <span class="toc-text"> Redis 为何使用单线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.10.3.</span> <span class="toc-text"> 缓存三大问题以及解决方案？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8Credis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.10.4.</span> <span class="toc-text"> 如何保证数据库和 Redis 缓存一致性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="toc-number">1.10.5.</span> <span class="toc-text"> 如何保证 Redis 的高并发？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.10.6.</span> <span class="toc-text"> Redis 如何保证原子性？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.11.</span> <span class="toc-text"> 常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cmd%E8%AE%BF%E9%97%AEredis"><span class="toc-number">1.11.1.</span> <span class="toc-text"> cmd 访问 redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2string%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">1.11.2.</span> <span class="toc-text"> 字符串 (String) 相关命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8list%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">1.11.3.</span> <span class="toc-text"> 列表 (List) 相关命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8Chash%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">1.11.4.</span> <span class="toc-text"> 哈希 (Hash) 相关命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88set%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">1.11.5.</span> <span class="toc-text"> 集合 (Set) 相关命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88sorted-set%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">1.11.6.</span> <span class="toc-text"> 有序集合 (Sorted Set) 相关命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.11.7.</span> <span class="toc-text"> 通用命令</span></a></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li class="active"><a href="/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/" rel="bookmark" title="【Redis】Redis面试题汇总与详解">【Redis】Redis面试题汇总与详解</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="Joker"
      data-src="/joker.github.io/images/avatar.png">
  <p class="name" itemprop="name">Joker</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/joker.github.io/archives/">
        <span class="count">5</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/joker.github.io/categories/">
        <span class="count">4</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/joker.github.io/tags/">
        <span class="count">12</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/joker.github.io/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/joker.github.io/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/joker.github.io/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/joker.github.io/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>

</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/joker.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="分类于 分布式锁">分布式锁</a>
</div>

    <span><a href="/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="【分布式】通过Zookeeper与Redisson实现Spring注解式分布式锁">【分布式】通过Zookeeper与Redisson实现Spring注解式分布式锁</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/joker.github.io/categories/RocketMQ/" title="分类于 RocketMQ">RocketMQ</a>
</div>

    <span><a href="/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/" title="【RocketMQ】安装与部署（Windows）">【RocketMQ】安装与部署（Windows）</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/joker.github.io/categories/RocketMQ/" title="分类于 RocketMQ">RocketMQ</a>
</div>

    <span><a href="/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/" title="【RocketMQ】SpringBoot整合与使用RocketMQ（Windows）">【RocketMQ】SpringBoot整合与使用RocketMQ（Windows）</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/joker.github.io/categories/Redis/" title="分类于 Redis">Redis</a>
</div>

    <span><a href="/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/" title="【Redis】Redis面试题汇总与详解">【Redis】Redis面试题汇总与详解</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/joker.github.io/categories/spring/" title="分类于 spring">spring</a>
</div>

    <span><a href="/joker.github.io/2024/09/13/%E3%80%90Spring%E3%80%91spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/" title="【Spring】Spring面试题汇总">【Spring】Spring面试题汇总</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Joker @ Joker</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2024/09/13/【Redis】Redis面试题汇总与详解/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/joker.github.io/js/app.js?v=0.2.5"></script>




</body>
</html>
