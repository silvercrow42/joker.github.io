



<!DOCTYPE html>
<html lang="zh-CN,en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/joker.github.io/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/joker.github.io/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="Joker" href="https://silvercrow42.github.io/joker.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Joker" href="https://silvercrow42.github.io/joker.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="Joker" href="https://silvercrow42.github.io/joker.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/joker.github.io/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="后端,java,Zookeeper" />


<link rel="canonical" href="https://silvercrow42.github.io/joker.github.io/2024/09/24/%E3%80%90Zookeeper%E3%80%91Zookeeper%E8%AF%A6%E8%A7%A3/">



  <title>
【Zookeeper】Zookeeper详解 - Zookeeper |
Joker = Joker</title>
<meta name="generator" content="Hexo 7.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">【Zookeeper】Zookeeper详解
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2024-09-24 11:39:53">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2024-09-24T11:39:53+08:00">2024-09-24</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/joker.github.io/" rel="start">Joker</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="/joker.github.io/2024/09/24/%E3%80%90Zookeeper%E3%80%91Zookeeper%E8%AF%A6%E8%A7%A3/5dd561b9d4fe9001f78279dd4b5af54b.jpeg">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/joker.github.io/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/joker.github.io/categories/Zookeeper/" itemprop="item" rel="index" title="分类于 Zookeeper"><span itemprop="name">Zookeeper</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://silvercrow42.github.io/joker.github.io/2024/09/24/%E3%80%90Zookeeper%E3%80%91Zookeeper%E8%AF%A6%E8%A7%A3/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/joker.github.io/images/avatar.png">
    <meta itemprop="name" content="Joker">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Joker">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h2 id="什么是zookeeper"><a class="markdownIt-Anchor" href="#什么是zookeeper">#</a> 什么是 Zookeeper</h2>
<p>Zookeeper 是一个开源的主动协调服务，用于分布式应用程序，提供了诸如配置维护、域名服务、分布式同步、组服务等功能。它是一个为分布式应用提供一致性服务的软件，其内部使用了一种称为<br>
 Zab 的协议（在选举过程中使用 Paxos 协议）来保证分布式环境中不同节点之间的数据一致性。</p>
<p>Zookeeper 的主要特点包括：</p>
<ul>
<li>高可用性：Zookeeper 可以构建为集群模式，通过多数派存活原则来保证服务的高可用性。</li>
<li>顺序一致性：客户端请求按照发起顺序进行处理。</li>
<li>原子性：所有事务要么全部成功，要么全部失败。</li>
<li>单一视图：无论客户端连接到集群中的哪个服务器，看到的服务视图都是一样的。</li>
<li>可靠性：一旦一个更新被应用并确认，该更新将一直有效，即使此时 Zookeeper 发生故障。</li>
</ul>
<p>Zookeeper 的应用场景：</p>
<ul>
<li>
<p>数据发布与订阅</p>
<p>顾名思义就是将数据发布到 ZooKeeper 节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，地址列表等就非常适合使用。<br>
数据发布 / 订阅的一个常见的场景是配置中心，发布者把数据发布到 ZooKeeper 的一个或一系列的节点上，供订阅者进行数据订阅，达到动态获取数据的目的。<br>
配置信息一般有几个特点:</p>
<ol>
<li>数据量小的 KV</li>
<li>数据内容在运行时会发生动态变化</li>
<li>集群机器共享，配置一致</li>
</ol>
<p>ZooKeeper 采用的是推拉结合的方式。</p>
<ol>
<li>推：服务端会推给注册了监控节点的客户端 Wathcer 事件通知</li>
<li>拉：客户端获得通知后，然后主动到服务端拉取最新的数据</li>
</ol>
</li>
<li>
<p>命名服务</p>
<p>作为分布式命名服务，命名服务是指通过指定的名字来获取资源或者服务的地址，利用 ZooKeeper 创建一个全局的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。统一命名服务的命名结构图如下所示：</p>
<ol>
<li>在分布式环境下，经常需要对应用 / 服务进行统一命名，便于识别不同服务。类似于域名与 IP 之间对应关系，IP 不容易记住，而域名容易记住。通过名称来获取资源或服务的地址，提供者等信息。</li>
<li>按照层次结构组织服务 / 应用名称。可将服务名称以及地址信息写到 ZooKeeper 上，客户端通过 ZooKeeper 获取可用服务列表类。</li>
</ol>
</li>
<li>
<p>分布式锁</p>
<p>处于不同节点上不同的服务，它们可能需要顺序的访问一些资源，这里需要一把分布式的锁。<br>
分布式锁具有以下特性：写锁、读锁、时序锁。</p>
<ul>
<li>写锁：在 zk 上创建的一个临时的无编号的节点。由于是无序编号，在创建时不会自动编号，导致只能客户端有一个客户端得到锁，然后进行写入。</li>
<li>读锁：在 zk 上创建一个临时的有编号的节点，这样即使下次有客户端加入是同时创建相同的节点时，他也会自动编号，也可以获得锁对象，然后对其进行读取。</li>
<li>时序锁：在 zk 上创建的一个临时的有编号的节点根据编号的大小控制锁。</li>
</ul>
</li>
<li>
<p>集群管理</p>
<p>所谓集群管理就是：是否有机器退出和加入、选举 master。<br>
集群管理主要指集群监控和集群控制两个方面。前者侧重于集群运行时的状态的收集，后者则是对集群进行操作与控制。开发和运维中，面对集群，经常有如下需求:</p>
<ol>
<li>希望知道集群中究竟有多少机器在工作</li>
<li>对集群中的每台机器的运行时状态进行数据收集</li>
<li>对集群中机器进行上下线的操作</li>
</ol>
<p>集群管理结构如下所示：</p>
<ol>
<li>
<p>分布式环境中，实时掌握每个节点的状态是必要的，可根据节点实时状态做出一些调整。</p>
</li>
<li>
<p>可交由 ZooKeeper 实现。<br>
可将节点信息写入 ZooKeeper 上的一个 Znode。<br>
监听这个 Znode 可获取它的实时状态变化。</p>
</li>
<li>
<p>典型应用</p>
<p>Hbase 中 Master 状态监控与选举。<br>
利用 ZooKeeper 的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建<br>
 /currentMaster<br>
 节点，最终一定只有一个客户端请求能够创建成功</p>
</li>
</ol>
</li>
<li>
<p>分布式通知与协调</p>
<ol>
<li>分布式环境中，经常存在一个服务需要知道它所管理的子服务的状态。
<ol>
<li>NameNode 需知道各个 Datanode 的状态。</li>
<li>JobTracker 需知道各个 TaskTracker 的状态。</li>
</ol>
</li>
<li>心跳检测机制可通过 ZooKeeper 来实现。</li>
<li>信息推送可由 ZooKeeper 来实现，ZooKeeper 相当于一个发布 / 订阅系统。</li>
</ol>
</li>
<li>
<p>分布式队列管理</p>
<p>分布式队列分为两种：</p>
<ol>
<li>当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。
<ol>
<li>一个 job 由多个 task 组成，只有所有任务完成后，job 才运行完成。</li>
<li>可为 job 创建一个 /job 目录，然后在该目录下，为每个完成的 task 创建一个临时的 Znode，一旦临时节点数目达到 task 总数，则表明 job 运行完成。</li>
</ol>
</li>
<li>队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型</li>
</ol>
</li>
</ul>
<h2 id="znode"><a class="markdownIt-Anchor" href="#znode">#</a> Znode</h2>
<p>Znode 是 Zookeeper 中的基本数据结构，用于存储数据和组织数据结构。<br>
每个 Znode 都有一个唯一的路径，路径类似于文件系统的路径，以 / 开头。</p>
<p>Znode 的属性</p>
<ul>
<li>数据内容：
<ul>
<li>data：Znode 存储的数据内容，最大为 1MB。</li>
</ul>
</li>
<li>ACL（Access Control List）：
<ul>
<li>权限控制列表：定义了对 Znode 的访问权限，包括读、写、创建子节点等权限。</li>
</ul>
</li>
<li>版本信息：
<ul>
<li>version：Znode 的版本号，用于数据一致性检查。</li>
<li>cversion：子节点的版本号。</li>
<li>aversion：ACL 的版本号。</li>
</ul>
</li>
<li>时间戳：
<ul>
<li>ctime：创建时间。</li>
<li>mtime：最后修改时间。</li>
</ul>
</li>
<li>子节点：
<ul>
<li>children：Znode 可以拥有子节点，形成树状结构。</li>
</ul>
</li>
</ul>
<p>Znode 的类型包括：</p>
<ol>
<li>
<p>持久节点（Persistent）：持久节点在 ZooKeeper 服务器重启后不会丢失，除非显式删除。Java 创建示例如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.create(<span class="string">&quot;/path&quot;</span>, data, acl, CreateMode.PERSISTENT);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>临时节点（Ephemeral）：创建后，如果创建该节点的客户端会话断开，则自动删除。且其不能有子节点。Java 创建示例如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.create(<span class="string">&quot;/path&quot;</span>, data, acl, CreateMode.EPHEMERAL);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>顺序节点（Sequential）：</p>
<ul>
<li>
<p>顺序节点在创建时自动获得一个唯一的序号，用于排序。例如，如果路径为 /path，创建的第一个顺序节点可能是<br>
 /path00000001。</p>
</li>
<li>
<p>顺序节点也包含持久节点和临时节点两种持久化类型。</p>
</li>
</ul>
<p>通过 Java 创建一个路径为 &quot;/path&quot; 的持久顺序节点示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.create(<span class="string">&quot;/path&quot;</span>, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>默认情况下创建的 Znode 为持久节点类型。</p>
<p>注意事项：</p>
<ol>
<li>创建节点时，必须要带上全路径。</li>
<li>创建节点时，如果父节点不存在，ZooKeeper 会自动创建父节点。</li>
<li>同一级节点 key 名称是唯一的。</li>
<li>delete 命令只能一层一层删除，不能删除一个节点下的所有子节点。新版本可以通过 deleteall 命令递归删除。</li>
</ol>
<h2 id="watch机制"><a class="markdownIt-Anchor" href="#watch机制">#</a> Watch 机制</h2>
<h3 id="概述"><a class="markdownIt-Anchor" href="#概述">#</a> 概述</h3>
<p>ZooKeeper 的 watch 机制是一种非常重要的特性，用于实现实时监控 ZooKeeper 中的数据变化。<br>
在 Spring Cloud 应用中，可以通过 Curator 框架结合 Spring Boot 来实现对 ZooKeeper 数据的监控。</p>
<p><strong>基本概念</strong></p>
<ul>
<li>Watch：一种一次性触发的通知机制。</li>
<li>Watcher：客户端注册的监听器，用于接收 ZooKeeper 的通知。</li>
</ul>
<p><strong>工作原理</strong></p>
<ul>
<li>注册 Watcher：客户端在执行某些操作（如获取节点数据、获取子节点列表等）时，可以注册一个 Watcher。</li>
<li>触发 Watcher：当节点数据或子节点列表发生变化时，ZooKeeper 会触发相应的 Watcher。</li>
<li>处理事件：客户端在收到 Watcher 触发的通知后，可以处理相应的事件，并重新注册 Watcher。</li>
</ul>
<p><strong>事件类型</strong></p>
<ul>
<li>NodeCreatedEvent：节点创建事件。</li>
<li>NodeDeletedEvent：节点删除事件。</li>
<li>NodeDataChangedEvent：节点数据变化事件。</li>
<li>NodeChildrenChangedEvent：子节点列表变化事件。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>配置管理：在分布式系统中，配置管理需要实时监控配置的变化，以保持配置的实时一致性。</li>
<li>监控服务：在分布式系统中，需要实时监控服务的状态，以确定服务的可用性。</li>
<li>负载均衡：在分布式系统中，需要根据负载情况动态调整服务实例的数量，以实现负载均衡。</li>
</ul>
<h3 id="在-spring-cloud-应用中的使用方法"><a class="markdownIt-Anchor" href="#在-spring-cloud-应用中的使用方法">#</a> 在 Spring Cloud 应用中的使用方法</h3>
<h4 id="curator"><a class="markdownIt-Anchor" href="#curator">#</a> Curator</h4>
<p>Curator 框架提供了简化 ZooKeeper 使用的 API，使得注册和处理 Watcher 更加方便。</p>
<ol>
<li>
<p>创建 Curator 客户端</p>
<p>在 Spring Boot 应用中，可以通过配置 Curator 客户端来管理 ZooKeeper 连接。</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">curator:</span></span><br><span class="line">    <span class="attr">connect-string:</span> <span class="string">localhost:2181</span></span><br><span class="line">    <span class="attr">session-timeout-ms:</span> <span class="number">5000</span></span><br><span class="line">    <span class="attr">connection-timeout-ms:</span> <span class="number">3000</span></span><br><span class="line">    <span class="attr">retry-policy:</span></span><br><span class="line">      <span class="attr">base-sleep-time-ms:</span> <span class="number">1000</span></span><br><span class="line">      <span class="attr">max-retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>配置 Curator 客户端</p>
<p>在 Spring Boot 应用中，可以通过 @Configuration 类来配置 Curator 客户端。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.RetryPolicy;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CuratorFramework <span class="title function_">curatorFramework</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(<span class="string">&quot;localhost:2181&quot;</span>)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">3000</span>)</span><br><span class="line">                .retryPolicy(retryPolicy)</span><br><span class="line">                .build();</span><br><span class="line">        client.start();</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注册 Watcher</p>
<p>在 Spring Boot 应用中，可以通过 Curator 框架提供的 NodeCache 和 PathChildrenCache 来注册 Watcher。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.api.ACLProvider;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.ChildData;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.NodeCache;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.NodeCacheListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.PathChildrenCache;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WatcherService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CuratorFramework curatorFramework;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchNodeData</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NodeCache</span> <span class="variable">nodeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeCache</span>(curatorFramework, <span class="string">&quot;/testNode&quot;</span>);</span><br><span class="line">        nodeCache.getListenable().addListener(<span class="keyword">new</span> <span class="title class_">NodeCacheListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">ChildData</span> <span class="variable">currentData</span> <span class="operator">=</span> nodeCache.getCurrentData();</span><br><span class="line">                <span class="keyword">if</span> (currentData != <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Node data changed: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(currentData.getData()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        nodeCache.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchChildrenChanges</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">PathChildrenCache</span> <span class="variable">childrenCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathChildrenCache</span>(curatorFramework, <span class="string">&quot;/testNode&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        childrenCache.getListenable().addListener(<span class="keyword">new</span> <span class="title class_">PathChildrenCacheListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> CHILD_ADDED:</span><br><span class="line">                        System.out.println(<span class="string">&quot;Child added: &quot;</span> + event.getData().getPath());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> CHILD_UPDATED:</span><br><span class="line">                        System.out.println(<span class="string">&quot;Child updated: &quot;</span> + event.getData().getPath());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> CHILD_REMOVED:</span><br><span class="line">                        System.out.println(<span class="string">&quot;Child removed: &quot;</span> + event.getData().getPath());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        System.out.println(<span class="string">&quot;Unknown event type: &quot;</span> + event.getType());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        childrenCache.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="zookeeper集群"><a class="markdownIt-Anchor" href="#zookeeper集群">#</a> Zookeeper 集群</h2>
<p>Zookeeper 集群是一种分布式协调服务，主要用于解决分布式系统中的一致性问题。它通过一组服务器组成集群，共同维护一个高度一致的状态。</p>
<p>Zookeeper 集群的组成和角色如下：</p>
<ol>
<li>
<p>领导者（Leader）：</p>
<p>Leader 是 Zookeeper 集群中的核心角色，负责处理客户端请求并协调其他服务器的状态。</p>
<ul>
<li>处理客户端请求：
<ul>
<li>Leader 负责接收客户端的所有读写请求，并处理这些请求。</li>
<li>对于读请求，Leader 可以直接返回结果。</li>
<li>对于写请求，Leader 会广播给所有 Follower 和 Observer。</li>
</ul>
</li>
<li>数据同步：
<ul>
<li>Leader 负责将写请求广播给所有的 Follower，并确保所有 Follower 都正确地执行了写操作。</li>
<li>Leader 通过事务日志（transaction log）和快照（snapshot）来保证数据的一致性。</li>
</ul>
</li>
<li>选举协调：
<ul>
<li>当集群中出现故障或需要重新选举时，Leader 负责协调选举过程。</li>
<li>Leader 通过投票机制来确定新的 Leader。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>跟随者（Follower）：</p>
<p>Follower 是 Zookeeper 集群中的重要角色之一，负责接收客户端请求并将请求转发给 Leader。</p>
<ul>
<li>接收客户端请求：
<ul>
<li>Follower 可以接收客户端的请求，并将请求转发给 Leader。</li>
<li>Follower 也可以直接处理客户端的读请求。</li>
</ul>
</li>
<li>数据同步：
<ul>
<li>Follower 负责同步 Leader 的状态。</li>
<li>当 Leader 发送写请求时，Follower 会执行相同的写操作，并确认操作完成。</li>
</ul>
</li>
<li>选举参与：
<ul>
<li>Follower 参与选举过程，通过投票机制选举新的 Leader。</li>
<li>当集群中出现故障时，Follower 会参与重新选举。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>观察者（Observer）：</p>
<p>Observer 是 Zookeeper 集群中的辅助角色，主要用于提高集群的吞吐量。</p>
<ul>
<li>接收客户端请求：
<ul>
<li>Observer 可以接收客户端的请求，并将请求转发给 Leader。</li>
<li>Observer 不参与选举过程，因此不会影响选举的结果。</li>
</ul>
</li>
<li>数据同步：
<ul>
<li>Observer 负责同步 Leader 的状态。</li>
<li>当 Leader 发送写请求时，Observer 会执行相同的写操作，并确认操作完成。</li>
</ul>
</li>
<li>提高吞吐量：
<ul>
<li>Observer 可以接收更多的客户端请求，从而提高集群的整体吞吐量。</li>
<li>Observer 不参与选举过程，因此不会增加选举的复杂度。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>数据一致性：Zookeeper 通过 ZAB 算法保证数据的一致性。</p>
<ul>
<li>事务日志：
<ul>
<li>每个服务器都会记录事务日志（transaction log），确保数据的一致性。</li>
<li>在选举过程中，Leader 会根据事务日志同步其他服务器的状态。</li>
</ul>
</li>
<li>快照：
<ul>
<li>定期生成快照（snapshot），减少事务日志的大小，提高性能。</li>
</ul>
</li>
</ul>
<h2 id="zookeeper的读写流程"><a class="markdownIt-Anchor" href="#zookeeper的读写流程">#</a> Zookeeper 的读写流程</h2>
<p>当客户端向 Zookeeper 发送一个数据变更请求时，请求首先到达 Leader 节点。以下是详细的流程：</p>
<ol>
<li>写入事务日志
<ol>
<li>Leader 收到变更请求：
<ul>
<li>Leader 节点首先接收到客户端发送的数据变更请求。</li>
</ul>
</li>
<li>生成事务记录：
<ul>
<li>Leader 节点生成一条事务记录，这条记录包含了变更请求的所有细节，例如操作类型（创建、删除、更新）、节点路径、数据等。</li>
</ul>
</li>
<li>写入事务日志：
<ul>
<li>Leader 节点将这条事务记录写入事务日志文件中。事务日志文件通常位于磁盘上，以确保数据的持久性。</li>
<li>事务日志文件通常以 .log 或 .txn 结尾。</li>
</ul>
</li>
</ol>
</li>
<li>写入内存
<ol>
<li>应用变更到内存：
<ul>
<li>在事务日志写入完成后，Leader 节点将变更请求应用到内存中的数据树。</li>
<li>这一步确保了数据的一致性和实时性。</li>
</ul>
</li>
</ol>
</li>
<li>广播变更请求
<ol>
<li>广播变更请求：
<ul>
<li>Leader 节点将变更请求广播给所有 Follower 节点。</li>
<li>Follower 节点接收到变更请求后，同样先写入事务日志，再写入内存。</li>
</ul>
</li>
</ol>
</li>
<li>确认变更
<ol>
<li>Follower 处理变更：
<ul>
<li>每个 Follower 节点接收到变更请求后，先将其写入自己的事务日志文件中，然后再应用到内存中的数据树。</li>
</ul>
</li>
<li>多数确认：
<ul>
<li>当大多数 Follower 节点确认收到并处理完变更请求后，Leader 节点认为变更成功。</li>
<li>这一步确保了数据的一致性和可靠性。</li>
</ul>
</li>
<li>返回结果：
<ul>
<li>Leader 节点将变更成功的消息返回给客户端。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="zookeeper的选举机制"><a class="markdownIt-Anchor" href="#zookeeper的选举机制">#</a> Zookeeper 的选举机制</h2>
<p>Zookeeper 的选举机制基于 Fast Leader Election (FLE) 算法，确保在一个分布式环境中快速且正确地选出领导者。</p>
<p>Zookeeper 集群中的选举机制通常在以下几种情况下被触发：</p>
<ul>
<li>初始启动：当集群中的所有服务器首次启动时，它们需要选举出一个 Leader。</li>
<li>Leader 故障：当当前的 Leader 发生故障（如宕机或网络分区）时，需要重新选举新的 Leader。</li>
<li>Leader 步骤落后：当 Leader 的步骤落后于其他服务器时，可能需要重新选举新的 Leader。</li>
</ul>
<p>在进行 Zookeeper 集群中，进行选举的节点具有以下状态：</p>
<ul>
<li>LOOKING
<ul>
<li>定义：节点处于寻找领导者的状态。</li>
<li>行为：节点会发起投票，并接收来自其他节点的投票信息。一旦收集到足够的投票信息，它会尝试成为领导者或者选择一个合适的领导者。</li>
</ul>
</li>
<li>LEADING
<ul>
<li>定义：节点成为领导者。</li>
<li>行为：负责协调集群中的所有事务操作，并向其他节点发送心跳信息以维持集群的一致性。</li>
</ul>
</li>
<li>FOLLOWING
<ul>
<li>定义：节点作为跟随者。</li>
<li>行为：接收领导者的心跳信息和指令，并执行相应的操作。</li>
</ul>
</li>
<li>OBSERVING
<ul>
<li>定义：节点作为观察者。</li>
<li>行为：观察者可以参与投票过程，但不参与决策制定。观察者主要用于扩展集群的读取能力。</li>
</ul>
</li>
</ul>
<p>在 ZooKeeper 的选举过程中，投票信息通常包含一个五元组，用于描述候选节点的状态和其他相关信息。这个五元组包括以下五个元素：</p>
<ul>
<li>epoch（纪元号）
<ul>
<li>定义：纪元号（epoch）是一个整数，用于标识选举周期。每次选举都会有一个新的纪元号。</li>
<li>作用：纪元号用于区分不同的选举周期，防止旧的投票信息影响新的选举。</li>
</ul>
</li>
<li>zxid（事务 ID）
<ul>
<li>定义：事务 ID（zxid）是一个 64 位的整数，用于标识事务的唯一性。</li>
<li>组成：zxid 由两部分组成：高 32 位是纪元号（epoch），低 32 位是事务编号（transaction number）。</li>
<li>作用：用于确定哪个节点具有最新的事务信息。</li>
</ul>
</li>
<li>peerId（节点 ID）
<ul>
<li>定义：节点 ID（peerId）是一个唯一的标识符，用于标识集群中的每个节点。</li>
<li>作用：用于识别投票来自哪个节点。</li>
</ul>
</li>
<li>leaderId（Leader ID）
<ul>
<li>定义：Leader ID（leaderId）是一个标识符，用于标识当前投票支持的候选 Leader。</li>
<li>作用：用于确定哪个节点被投票支持作为新的 Leader。</li>
</ul>
</li>
<li>type（投票类型）
<ul>
<li>定义：投票类型（type）是一个标识符，用于描述当前投票的类型。</li>
<li>作用：用于区分不同类型的投票，如 LOOKING、LEADING 或 LEADER。</li>
</ul>
</li>
</ul>
<p>参与运算的关键变量</p>
<ul>
<li>myid
<ul>
<li>定义：每个节点的唯一标识符。</li>
<li>作用：用于区分不同的节点，在选举过程中用于投票。</li>
</ul>
</li>
<li>zxid
<ul>
<li>定义：事务 ID，表示最后一次提交的事务编号。</li>
<li>作用：用于判断节点的状态是否最新。具有更大 zxid 的节点被认为是更 “新” 的节点。</li>
</ul>
</li>
<li>epoch
<ul>
<li>定义：选举轮次。</li>
<li>作用：防止过期的投票信息干扰当前的选举过程。每次选举开始时，epoch 增加。</li>
</ul>
</li>
<li>peerState
<ul>
<li>定义：节点的当前状态。</li>
<li>作用：记录节点当前处于哪种状态（LOOKING, LEADING, FOLLOWING, OBSERVING）。</li>
</ul>
</li>
<li>votesReceived
<ul>
<li>定义：节点接收到的投票数量。</li>
<li>作用：用于统计当前节点是否获得了大多数投票。</li>
</ul>
</li>
<li>lastVote
<ul>
<li>定义：节点上一次投票的对象。</li>
<li>作用：记录上一次投票的对象，避免重复投票。</li>
</ul>
</li>
<li>electionType
<ul>
<li>定义：选举类型（例如普通选举或重新选举）。</li>
<li>作用：用于区分不同类型的选举过程。</li>
</ul>
</li>
</ul>
<p>详细流程</p>
<ol>
<li>初始化状态：当一个节点启动时，它会进入 LOOKING 状态。这意味着它正在寻找或试图成为领导者。</li>
<li>初始化投票：每个节点在启动时会给自己投一票，并将投票信息（包括 myid 和 zxid）发送给集群中的其他节点。</li>
<li>接收投票信息：节点会接收到其他节点的投票信息。</li>
<li>比较和更新投票
<ol>
<li>比较 epoch：节点会比较接收到的投票信息中的 epoch 和自己的 epoch。
<ul>
<li>当接收到的 epoch 大于自己的 epoch，则更新自己的 epoch，并将新的投票信息再次发送给集群中的所有节点，防止投票过期。</li>
</ul>
</li>
<li>比较 zxid：节点会比较接收到的投票信息中的 zxid 和自己的 zxid。
<ul>
<li>如果接收到的投票信息中的 zxid 大于自己的 zxid，则更新自己的投票信息，并将新的投票信息再次发送给集群中的所有节点。</li>
<li>如果接收到的投票信息中的 zxid 等于自己的 zxid，则比较 myid。
<ul>
<li>如果接收到的投票信息中的 myid 大于自己的 myid，则更新自己的投票信息，并将新的投票信息再次发送给集群中的所有节点。</li>
<li>如果接收到的投票信息中的 myid 小于自己的 myid，则保持当前的投票信息不变。</li>
</ul>
</li>
<li>如果接收到的投票信息中的 zxid 小于自己的 zxid，则保持当前的投票信息不变。</li>
</ul>
</li>
</ol>
</li>
<li>统计投票结果：每个节点会统计接收到的投票信息。如果一个特定的节点得到了大多数（超过半数）的投票，那么这个节点就被认为是领导者。
<ul>
<li>大多数投票：对于奇数个节点的集群，大多数意味着 (N + 1) / 2；对于偶数个节点，则需要 N / 2 + 1 才能构成大多数。</li>
</ul>
</li>
<li>领导者确认：成功获得大多数投票的节点会向集群广播它的领导者身份。<br>
其他节点接收到这条消息后，会切换到 FOLLOWING 状态，并开始跟随新的领导者。</li>
<li>故障转移：如果当前的领导者失效了，跟随者会重新进入 LOOKING 状态并开始新一轮的选举。</li>
</ol>
<p>示例流程</p>
<p>假设有一个 Zookeeper 集群，包含三个节点 A、B 和 C：</p>
<ol>
<li>初始化状态：A、B 和 C 都进入 LOOKING 状态。</li>
<li>投票：A、B 和 C 各自给自己投一票，并将投票信息发送给其他节点。假设
<ul>
<li>A 的 zxid 是 100。</li>
<li>B 的 zxid 是 90。</li>
<li>C 的 zxid 是 110。</li>
</ul>
</li>
<li>接收投票：
<ul>
<li>A 收到 B 和 C 的投票信息。</li>
<li>B 收到 A 和 C 的投票信息。</li>
<li>C 收到 A 和 B 的投票信息。</li>
</ul>
</li>
<li>比较和更新投票：
<ul>
<li>A 发现 C 的 zxid 更大，更新自己的投票信息，并重新发送投票给 B 和 C。</li>
<li>B 发现 C 的 zxid 更大，更新自己的投票信息，并重新发送投票给 A 和 C。</li>
<li>C 发现自己的 zxid 最大，保持投票信息不变。</li>
</ul>
</li>
<li>统计投票结果：C 收到 A 和 B 的投票，统计后发现自己的投票数达到 2（超过半数）。</li>
<li>领导者确认：
<ul>
<li>C 向 A 和 B 广播自己成为领导者的信息。</li>
<li>A 和 B 收到消息后，切换到 FOLLOWING 状态。</li>
</ul>
</li>
<li>故障转移：如果 C 故障，A 和 B 重新进入 LOOKING 状态，重复上述流程。</li>
</ol>
<h2 id="zookeeper的数据同步机制"><a class="markdownIt-Anchor" href="#zookeeper的数据同步机制">#</a> Zookeeper 的数据同步机制</h2>
<p>Zookeeper 使用 ZAB（Zookeeper Atomic Broadcast）协议来保证数据的一致性和高可用性。</p>
<p>在集群中已经选举出 Leader 后，集群中的其他服务器会通过以下步骤与 Leader 保持同步：</p>
<ol>
<li>
<p>状态同步</p>
<ul>
<li>新领导者确定事务状态：新领导者需要确定哪些事务应该保留，哪些事务应该撤销。</li>
<li>事务日志检查：新领导者检查所有节点的事务日志，找出最新的事务状态。</li>
</ul>
</li>
<li>
<p>冲突解决</p>
<ul>
<li>冲突检测：新领导者检查事务日志，找出冲突的事务。</li>
<li>冲突解决策略：
<ul>
<li>基于事务编号（ZXID）：保留编号较大的事务。</li>
<li>基于事务时间戳：保留时间戳较新的事务。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Leader 同步</p>
<p>选举出新的 Leader 后，Leader 会开始与其他 Follower 进行数据同步。具体步骤如下：</p>
<ol>
<li>Leader 发送事务日志：
<ul>
<li>Leader 将最新的事务日志（transaction log）发送给所有 Follower。</li>
<li>事务日志包含了所有未提交的事务记录。</li>
</ul>
</li>
<li>Follower 接收事务日志：
<ul>
<li>Follower 接收到事务日志后，会将其应用到本地状态上。</li>
<li>Follower 会确认事务日志的正确性，并将确认信息发送回 Leader。</li>
</ul>
</li>
<li>Leader 确认同步：
<ul>
<li>Leader 收到所有 Follower 的确认信息后，会确认数据同步完成。</li>
<li>Leader 会发送确认信息给所有 Follower，表明数据同步完成。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Follower 同步</p>
<p>Follower 在同步过程中需要确保与 Leader 的状态一致。具体步骤如下：</p>
<ol>
<li>Leader 发送写请求：
<ul>
<li>当 Leader 收到客户端的写请求时，会将写请求广播给所有 Follower。</li>
<li>写请求包含具体的写操作和事务 ID（zxid）。</li>
</ul>
</li>
<li>Follower 执行写操作：
<ul>
<li>Follower 接收到写请求后，会执行相同的写操作，并记录事务日志。</li>
<li>Follower 会将确认信息发送回 Leader，表明写操作已完成。</li>
</ul>
</li>
<li>Leader 确认写操作：
<ul>
<li>Leader 收到所有 Follower 的确认信息后，会确认写操作完成。</li>
<li>Leader 会发送确认信息给所有 Follower，表明写操作完成。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Observer 同步</p>
<p>Observer 不参与选举过程，但需要同步 Leader 的数据以保持最新状态。具体步骤如下：</p>
<ol>
<li>Observer 同步数据：
<ul>
<li>Observer 从 Leader 获取最新的数据。</li>
<li>Leader 将最新的事务日志发送给 Observer。</li>
</ul>
</li>
<li>Observer 应用事务日志：
<ul>
<li>Observer 接收到事务日志后，会将其应用到本地状态上。</li>
<li>Observer 会确认事务日志的正确性，并将确认信息发送回 Leader。</li>
</ul>
</li>
<li>Leader 确认同步：
<ul>
<li>Leader 收到 Observer 的确认信息后，会确认数据同步完成。</li>
<li>Leader 会发送确认信息给 Observer，表明数据同步完成。</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>详细流程示例</p>
<p>假设集群中有三个服务器：Server A、Server B 和 Server C。Server A 成为 Leader，Server B 和 Server C 作为 Follower。此外，还有一个<br>
 Observer 服务器 Server D。</p>
<ol>
<li>Leader 同步：
<ul>
<li>Server A 发送最新的事务日志给 Server B 和 Server C。</li>
<li>Server B 和 Server C 接收到事务日志后，应用到本地状态，并发送确认信息给 Server A。</li>
<li>Server A 收到所有 Follower 的确认信息后，确认数据同步完成。</li>
</ul>
</li>
<li>Follower 同步：
<ul>
<li>当 Server A 收到客户端的写请求时，将写请求广播给 Server B 和 Server C。</li>
<li>Server B 和 Server C 执行相同的写操作，并记录事务日志。</li>
<li>Server B 和 Server C 发送确认信息给 Server A。</li>
<li>Server A 收到所有 Follower 的确认信息后，确认写操作完成。</li>
</ul>
</li>
<li>Observer 同步：
<ul>
<li>Server D 从 Server A 获取最新的事务日志。</li>
<li>Server A 发送最新的事务日志给 Server D。</li>
<li>Server D 接收到事务日志后，应用到本地状态，并发送确认信息给 Server A。</li>
<li>Server A 收到 Observer 的确认信息后，确认数据同步完成。</li>
</ul>
</li>
</ol>
<h2 id="zookeeper的持久化机制"><a class="markdownIt-Anchor" href="#zookeeper的持久化机制">#</a> Zookeeper 的持久化机制</h2>
<p>Zookeeper 的数据持久化机制是其可靠性的关键组成部分之一。为了确保数据在系统崩溃或重启后仍然可用，Zookeeper 采用了多种机制来实现数据持久化。</p>
<ol>
<li>
<p>事务日志（Transaction Log）</p>
<p>事务日志记录了所有对 Zookeeper 数据树的操作。每次写操作都会被记录在事务日志中，以便在系统崩溃后能够恢复数据。</p>
<ul>
<li>
<p>事务日志的作用</p>
<ul>
<li>记录所有写操作：每次写操作（如创建节点、删除节点、更新节点数据等）都会被记录在事务日志中。</li>
<li>支持数据恢复：在系统崩溃后，可以通过事务日志恢复数据。</li>
</ul>
</li>
<li>
<p>事务日志的存储</p>
<ul>
<li>事务日志通常存储在磁盘上，以确保数据的安全性和持久性。每个 Server 都有自己的事务日志文件，通常位于配置文件<br>
 zoo.cfg<br>
 中指定的目录下。</li>
</ul>
</li>
<li>
<p>事务日志的格式</p>
<p>事务日志文件通常以 .log 或 .txn 结尾。每个事务日志文件包含一系列事务记录，每条记录包含以下信息：</p>
<ul>
<li>事务类型：标识操作类型（如 create、delete、setData 等）。</li>
<li>事务 ID（zxid）：唯一的事务标识符。</li>
<li>操作详情：具体的操作内容（如节点路径、数据等）。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>快照（Snapshot）</p>
<p>快照是对 Zookeeper 数据树的一个完整备份。快照定期生成，以减少事务日志的大小，并提高恢复速度。</p>
<ul>
<li>
<p>快照的作用</p>
<ul>
<li>快速恢复数据：在系统崩溃后，可以通过快照快速恢复数据。</li>
<li>减少事务日志大小：定期生成快照可以减少事务日志的大小，提高系统性能。</li>
</ul>
</li>
<li>
<p>快照的存储</p>
<p>快照通常也存储在磁盘上，与事务日志文件一起存放在配置文件 zoo.cfg 中指定的目录下。</p>
</li>
<li>
<p>快照的格式</p>
<p>快照文件通常以 .snapshot 或 .snap 结尾。每个快照文件包含以下信息：</p>
<ul>
<li>数据树的完整状态：当前 Zookeeper 数据树的完整状态。</li>
<li>事务 ID（zxid）：最后一个事务的 ID，用于标识快照的时间点。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>恢复机制</p>
<p>当 Zookeeper 服务器启动时，需要从磁盘上的事务日志和快照文件中恢复数据。恢复过程如下：</p>
<ol>
<li>加载快照：服务器启动时，首先加载最新的快照文件，恢复数据树的基本状态。</li>
<li>重放事务日志：从最新的快照时间点之后的事务日志开始重放，逐条执行事务日志中的操作，直到最新的事务日志为止。</li>
<li>检查一致性：服务器会检查数据树的状态是否一致，确保没有遗漏的操作。</li>
</ol>
</li>
</ol>

      <div class="tags">
          <a href="/joker.github.io/tags/%E5%90%8E%E7%AB%AF/" rel="tag"><i class="ic i-tag"></i> 后端</a>
          <a href="/joker.github.io/tags/java/" rel="tag"><i class="ic i-tag"></i> java</a>
          <a href="/joker.github.io/tags/Zookeeper/" rel="tag"><i class="ic i-tag"></i> Zookeeper</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2024-10-08 14:15:30" itemprop="dateModified" datetime="2024-10-08T14:15:30+08:00">2024-10-08</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/joker.github.io/images/wechatpay.png" alt="Joker 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/joker.github.io/images/alipay.png" alt="Joker 支付宝">
        <p>支付宝</p>
      </div>
      
      <div>
        <img data-src="/joker.github.io/images/paypal.png" alt="Joker 贝宝">
        <p>贝宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>Joker <i class="ic i-at"><em>@</em></i>Joker
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://silvercrow42.github.io/joker.github.io/2024/09/24/%E3%80%90Zookeeper%E3%80%91Zookeeper%E8%AF%A6%E8%A7%A3/" title="【Zookeeper】Zookeeper详解">https://silvercrow42.github.io/joker.github.io/2024/09/24/【Zookeeper】Zookeeper详解/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="prev" data-background-image="&#x2F;joker.github.io&#x2F;2024&#x2F;09&#x2F;13&#x2F;%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3&#x2F;f7bb710f33356088835bc958c533c7f3.png" title="【Redis】Redis详解">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> Redis</span>
  <h3>【Redis】Redis详解</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/joker.github.io/2024/09/25/%E3%80%90Linux%E3%80%91Linux%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="next" data-background-image="&#x2F;joker.github.io&#x2F;2024&#x2F;09&#x2F;25&#x2F;%E3%80%90Linux%E3%80%91Linux%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3&#x2F;LINUX.jpg" title="【Linux】Linux命令详解">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> Linux</span>
  <h3>【Linux】Linux命令详解</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFzookeeper"><span class="toc-number">1.</span> <span class="toc-text"> 什么是 Zookeeper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#znode"><span class="toc-number">2.</span> <span class="toc-text"> Znode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#watch%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text"> Watch 机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text"> 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-spring-cloud-%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text"> 在 Spring Cloud 应用中的使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#curator"><span class="toc-number">3.2.1.</span> <span class="toc-text"> Curator</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zookeeper%E9%9B%86%E7%BE%A4"><span class="toc-number">4.</span> <span class="toc-text"> Zookeeper 集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zookeeper%E7%9A%84%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text"> Zookeeper 的读写流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zookeeper%E7%9A%84%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text"> Zookeeper 的选举机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zookeeper%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text"> Zookeeper 的数据同步机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zookeeper%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">8.</span> <span class="toc-text"> Zookeeper 的持久化机制</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li class="active"><a href="/joker.github.io/2024/09/24/%E3%80%90Zookeeper%E3%80%91Zookeeper%E8%AF%A6%E8%A7%A3/" rel="bookmark" title="【Zookeeper】Zookeeper详解">【Zookeeper】Zookeeper详解</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="Joker"
      data-src="/joker.github.io/images/avatar.png">
  <p class="name" itemprop="name">Joker</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/joker.github.io/archives/">
        <span class="count">7</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/joker.github.io/categories/">
        <span class="count">6</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/joker.github.io/tags/">
        <span class="count">14</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/joker.github.io/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/joker.github.io/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/joker.github.io/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/joker.github.io/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>

</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/joker.github.io/2024/09/25/%E3%80%90Linux%E3%80%91Linux%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/joker.github.io/categories/spring/" title="分类于 spring">spring</a>
</div>

    <span><a href="/joker.github.io/2024/09/13/%E3%80%90Spring%E3%80%91Spring%E8%AF%A6%E8%A7%A3/" title="【Spring】Spring详解">【Spring】Spring详解</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/joker.github.io/categories/Zookeeper/" title="分类于 Zookeeper">Zookeeper</a>
</div>

    <span><a href="/joker.github.io/2024/09/24/%E3%80%90Zookeeper%E3%80%91Zookeeper%E8%AF%A6%E8%A7%A3/" title="【Zookeeper】Zookeeper详解">【Zookeeper】Zookeeper详解</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/joker.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="分类于 分布式锁">分布式锁</a>
</div>

    <span><a href="/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="【分布式】通过Zookeeper与Redisson实现Spring注解式分布式锁">【分布式】通过Zookeeper与Redisson实现Spring注解式分布式锁</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/joker.github.io/categories/RocketMQ/" title="分类于 RocketMQ">RocketMQ</a>
</div>

    <span><a href="/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/" title="【RocketMQ】SpringBoot整合与使用RocketMQ（Windows）">【RocketMQ】SpringBoot整合与使用RocketMQ（Windows）</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/joker.github.io/categories/Linux/" title="分类于 Linux">Linux</a>
</div>

    <span><a href="/joker.github.io/2024/09/25/%E3%80%90Linux%E3%80%91Linux%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" title="【Linux】Linux命令详解">【Linux】Linux命令详解</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/joker.github.io/categories/RocketMQ/" title="分类于 RocketMQ">RocketMQ</a>
</div>

    <span><a href="/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/" title="【RocketMQ】安装与部署（Windows）">【RocketMQ】安装与部署（Windows）</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/joker.github.io/categories/Redis/" title="分类于 Redis">Redis</a>
</div>

    <span><a href="/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/" title="【Redis】Redis详解">【Redis】Redis详解</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Joker @ Joker</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2024/09/24/【Zookeeper】Zookeeper详解/',
    favicon: {
      show: "来辣！ヾ(´∀`o)+",
      hide: "ε = = (づ′▽`)づ走辣!"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/joker.github.io/js/app.js?v=0.2.5"></script>




</body>
</html>
