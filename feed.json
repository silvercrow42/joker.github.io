{
    "version": "https://jsonfeed.org/version/1",
    "title": "Joker",
    "description": "",
    "home_page_url": "https://silvercrow42.github.io/joker.github.io",
    "items": [
        {
            "id": "https://silvercrow42.github.io/joker.github.io/2024/10/09/%E3%80%90Mysql%E3%80%91Mysql%E8%AF%A6%E8%A7%A3/",
            "url": "https://silvercrow42.github.io/joker.github.io/2024/10/09/%E3%80%90Mysql%E3%80%91Mysql%E8%AF%A6%E8%A7%A3/",
            "title": "【Mysql】Mysql详解",
            "date_published": "2024-10-09T01:58:28.000Z",
            "content_html": "<h2 id=\"什么是mysql\"><a class=\"markdownIt-Anchor\" href=\"#什么是mysql\">#</a> 什么是 Mysql</h2>\n<p>MySQL 是一个广泛使用的开源关系型数据库管理系统（RDBMS），由 MySQL AB 公司开发，后来被 Sun Microsystems 收购，最终成为 Oracle<br>\n 公司的一部分。MySQL 被广泛应用于 Web 应用、企业应用和个人项目中。以下是关于 MySQL 的一些详细介绍：</p>\n<ol>\n<li>\n<p>特点</p>\n<ul>\n<li>高性能：MySQL 提供了高效的查询处理机制，能够处理大量的并发请求。</li>\n<li>易于使用：安装简单，配置容易，支持多种操作系统（如 Windows、Linux 和 macOS）。</li>\n<li>安全性：提供了丰富的安全特性，包括用户认证、权限管理、数据加密等。</li>\n<li>扩展性：支持多种存储引擎（如 InnoDB、MyISAM 等），可以根据不同的应用场景选择合适的存储引擎。</li>\n<li>开源免费：作为开源软件，MySQL 可以免费使用，适用于各种规模的应用。</li>\n</ul>\n</li>\n<li>\n<p>数据库结构<br>\n MySQL 使用标准的关系模型，包括表、视图、索引等基本组件：</p>\n<ul>\n<li>表：存储数据的基本单位，由行和列组成。</li>\n<li>视图：虚拟表，基于一个或多个表的查询结果。</li>\n<li>索引：用于加快数据检索速度的特殊数据结构。</li>\n</ul>\n</li>\n<li>\n<p>存储引擎<br>\n MySQL 支持多种存储引擎，其中最常用的是：</p>\n<ul>\n<li>InnoDB：支持事务处理、外键约束和行级锁定。</li>\n<li>MyISAM：不支持事务处理，但性能较高，适合读取密集型应用。</li>\n<li>Memory：将数据存储在内存中，提供极高的读写速度，但不适合持久化存储。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"mysql的数据类型\"><a class=\"markdownIt-Anchor\" href=\"#mysql的数据类型\">#</a> Mysql 的数据类型</h2>\n<h3 id=\"数值类型\"><a class=\"markdownIt-Anchor\" href=\"#数值类型\">#</a> 数值类型</h3>\n<p>MySQL 支持所有标准 SQL 数值数据类型。</p>\n<p>这些类型包括严格数值数据类型 (INTEGER、SMALLINT、DECIMAL 和 NUMERIC)，以及近似数值数据类型 (FLOAT、REAL 和 DOUBLE PRECISION)。</p>\n<p>关键字 INT 是 INTEGER 的同义词，关键字 DEC 是 DECIMAL 的同义词。</p>\n<p>BIT 数据类型保存位字段值，并且支持 MyISAM、MEMORY、InnoDB 和 BDB 表。</p>\n<p>作为 SQL 标准的扩展，MySQL 也支持整数类型 TINYINT、MEDIUMINT 和 BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>大小 (bytes)</th>\n<th>范围（有符号）</th>\n<th>范围（无符号）</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TINYINT</td>\n<td>1</td>\n<td>(-128，127)</td>\n<td>(0，255)</td>\n<td>小整数值</td>\n</tr>\n<tr>\n<td>SMALLINT</td>\n<td>2</td>\n<td>(-32 768，32 767)</td>\n<td>(0，65 535)</td>\n<td>大整数值</td>\n</tr>\n<tr>\n<td>MEDIUMINT</td>\n<td>3</td>\n<td>(-8 388 608，8 388 607)</td>\n<td>(0，16 777 215)</td>\n<td>大整数值</td>\n</tr>\n<tr>\n<td>INT 或 INTEGER</td>\n<td>4</td>\n<td>(-2 147 483 648，2 147 483 647)</td>\n<td>(0，4 294 967 295)</td>\n<td>大整数值</td>\n</tr>\n<tr>\n<td>BIGINT</td>\n<td>8</td>\n<td>(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>\n<td>(0，18 446 744 073 709 551 615)</td>\n<td>极大整数值</td>\n</tr>\n<tr>\n<td>FLOAT</td>\n<td>4</td>\n<td>(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>\n<td>0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>\n<td>单精度浮点数值</td>\n</tr>\n<tr>\n<td>DOUBLE</td>\n<td>8</td>\n<td>(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>\n<td>0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>\n<td>双精度浮点数值</td>\n</tr>\n<tr>\n<td>DECIMAL</td>\n<td>对 DECIMAL (M,D) ，如果 M&gt;D，为 M+2 否则为 D+2</td>\n<td>依赖于 M 和 D 的值</td>\n<td>依赖于 M 和 D 的值</td>\n<td>小数值</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"日期和时间类型\"><a class=\"markdownIt-Anchor\" href=\"#日期和时间类型\">#</a> 日期和时间类型</h3>\n<p>表示时间值的日期和时间类型为 DATETIME、DATE、TIMESTAMP、TIME 和 YEAR。</p>\n<p>每个时间类型有一个有效值范围和一个 &quot;零&quot; 值，当指定不合法的 MySQL 不能表示的值时使用 &quot;零&quot; 值。</p>\n<p>TIMESTAMP 类型有专有的自动更新特性，将在后面描述。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>大小 (bytes)</th>\n<th>范围</th>\n<th>格式</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DATE</td>\n<td>3</td>\n<td>1000-01-01/9999-12-31</td>\n<td>YYYY-MM-DD</td>\n<td>日期值</td>\n</tr>\n<tr>\n<td>TIME</td>\n<td>3</td>\n<td>‘-838:59:59’/‘838:59:59’</td>\n<td>HH:MM:SS</td>\n<td>时间值或持续时间</td>\n</tr>\n<tr>\n<td>YEAR</td>\n<td>1</td>\n<td>1901/2155</td>\n<td>YYYY</td>\n<td>年份值</td>\n</tr>\n<tr>\n<td>DATETIME</td>\n<td>8</td>\n<td>‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td>\n<td>YYYY-MM-DD hh:mm:ss</td>\n<td>混合日期和时间值</td>\n</tr>\n<tr>\n<td>TIMESTAMP</td>\n<td>4</td>\n<td>‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC 结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038 年 1 月 19 日 凌晨 03:14:07</td>\n<td>YYYY-MM-DD hh:mm:ss</td>\n<td>混合日期和时间值，时间戳</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"字符串类型\"><a class=\"markdownIt-Anchor\" href=\"#字符串类型\">#</a> 字符串类型</h3>\n<p>字符串类型指 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>大小 (bytes)</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CHAR</td>\n<td>0-255</td>\n<td>定长字符串</td>\n</tr>\n<tr>\n<td>VARCHAR</td>\n<td>0-65535</td>\n<td>变长字符串</td>\n</tr>\n<tr>\n<td>TINYBLOB</td>\n<td>0-255</td>\n<td>不超过 255 个字符的二进制字符串</td>\n</tr>\n<tr>\n<td>TINYTEXT</td>\n<td>0-255</td>\n<td>短文本字符串</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>0-65 535</td>\n<td>二进制形式的长文本数据</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>0-65 535</td>\n<td>长文本数据</td>\n</tr>\n<tr>\n<td>MEDIUMBLOB</td>\n<td>0-16 777 215</td>\n<td>二进制形式的中等长度文本数据</td>\n</tr>\n<tr>\n<td>MEDIUMTEXT</td>\n<td>0-16 777 215</td>\n<td>中等长度文本数据</td>\n</tr>\n<tr>\n<td>LONGBLOB</td>\n<td>0-4 294 967 295</td>\n<td>二进制形式的极大文本数据</td>\n</tr>\n<tr>\n<td>LONGTEXT</td>\n<td>0-4 294 967 295</td>\n<td>极大文本数据</td>\n</tr>\n</tbody>\n</table>\n<p>注意：char (n) 和 varchar (n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR (30) 就可以存储 30 个字符。</p>\n<p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p>\n<p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p>\n<p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p>\n<p>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p>\n<h3 id=\"枚举与集合类型enumeration-and-set-types\"><a class=\"markdownIt-Anchor\" href=\"#枚举与集合类型enumeration-and-set-types\">#</a> 枚举与集合类型（Enumeration and Set Types）</h3>\n<ul>\n<li>ENUM: 枚举类型，用于存储单一值，可以选择一个预定义的集合。</li>\n<li>SET: 集合类型，用于存储多个值，可以选择多个预定义的集合。</li>\n</ul>\n<h3 id=\"空间数据类型spatial-data-types\"><a class=\"markdownIt-Anchor\" href=\"#空间数据类型spatial-data-types\">#</a> 空间数据类型（Spatial Data Types）</h3>\n<p>GEOMETRY, POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION:<br>\n 用于存储空间数据（地理信息、几何图形等）。</p>\n<h2 id=\"索引\"><a class=\"markdownIt-Anchor\" href=\"#索引\">#</a> 索引</h2>\n<p>MySQL 中的索引是一种数据结构，它可以帮助数据库系统更快地检索数据</p>\n<ul>\n<li>\n<p>从物理结构上可以分为聚集索引和非聚集索引两类：</p>\n<ul>\n<li>聚簇索引指索引的键值的逻辑顺序与表中相应行的物理顺序一致，即每张表只能有一个聚簇索引，也就是我们常说的主键索引；\n<ul>\n<li>默认情况下，InnoDB 表的主键就是聚簇索引。</li>\n<li>如果没有显式定义主键，则 InnoDB 会自动创建一个隐藏的主键作为聚簇索引。</li>\n</ul>\n</li>\n<li>非聚簇索引的逻辑顺序则与数据行的物理顺序不一致。\n<ul>\n<li>非聚簇索引（也称为二级索引）只存储索引键值和指向实际数据行的指针。</li>\n<li>当通过非聚簇索引查找数据时，首先找到索引条目，然后通过指针访问实际的数据行。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>从应用上可以划分为一下几类：</p>\n<ul>\n<li>普通索引：MySQL 中的基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了提高查询效率。通过 ALTER<br>\nTABLE<br>\ntable_name ADD INDEX index_name (column) 创建；</li>\n<li>唯一索引：索引列中的值必须是唯一的，但是允许为空值。通过 ALTER TABLE table_name ADD UNIQUE index_name (column) 创建；</li>\n<li>主键索引：特殊的唯一索引，也成聚簇索引，不允许有空值，并由数据库帮我们自动创建；</li>\n<li>组合索引：组合表中多个字段创建的索引，遵守最左前缀匹配规则；</li>\n<li>全文索引：只有在 MyISAM 引擎上才能使用，同时只支持 CHAR、VARCHAR、TEXT 类型字段上使用。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"hash-索引\"><a class=\"markdownIt-Anchor\" href=\"#hash-索引\">#</a> Hash 索引</h3>\n<p>在 MySQL 中，哈希索引（Hash Index）是一种特殊的索引类型，主要用于快速查找数据。哈希索引利用哈希算法将索引键值映射到一个固定大小的哈希表中，从而实现快速定位数据。</p>\n<p>哈希索引的基本实现原理如下：</p>\n<ol>\n<li>哈希算法：\n<ul>\n<li>哈希算法将索引键值转换为一个固定长度的哈希值。</li>\n<li>这个哈希值被用作索引表中的索引项。</li>\n</ul>\n</li>\n<li>哈希表：\n<ul>\n<li>哈希表是一个数组，每个数组元素对应一个哈希值。</li>\n<li>查找时，通过计算键值的哈希值可以直接定位到对应的数组元素。</li>\n</ul>\n</li>\n</ol>\n<p>MySQL 中各引擎的的哈希索引实现：</p>\n<ol>\n<li>InnoDB 存储引擎<br>\n在 InnoDB 存储引擎中，哈希索引主要用于内部结构，例如辅助索引和临时表。InnoDB 并不支持用户级别的哈希索引。</li>\n<li>MyISAM 存储引擎<br>\n MyISAM 存储引擎支持用户级别的哈希索引，主要用于全表扫描和快速查找。</li>\n<li>MEMORY 存储引擎<br>\n MEMORY 存储引擎（以前称为 HEAP 存储引擎）支持哈希索引，主要用于临时表和内存中的数据存储。</li>\n</ol>\n<p>哈希索引的优点</p>\n<ul>\n<li>快速查找：\n<ul>\n<li>哈希索引可以实现常数时间复杂度 O (1) 的查找，非常快。</li>\n<li>特别适用于简单的等值查询（例如 WHERE name = ‘Alice’）。</li>\n</ul>\n</li>\n<li>内存效率：\n<ul>\n<li>哈希索引通常用于内存中的数据存储，适合临时表和小数据量的场景。</li>\n</ul>\n</li>\n</ul>\n<p>哈希索引的缺点</p>\n<ul>\n<li>不支持范围查询：哈希索引不支持范围查询（例如 WHERE name BETWEEN ‘A’ AND ‘Z’）。</li>\n<li>不支持排序：哈希索引无法用于排序操作，因为哈希值之间没有顺序关系。</li>\n<li>哈希冲突：哈希冲突可能导致性能下降，特别是在高并发场景下。</li>\n</ul>\n<h3 id=\"btree索引\"><a class=\"markdownIt-Anchor\" href=\"#btree索引\">#</a> B+Tree 索引</h3>\n<p>在 MySQL 中，B+Tree 索引是一种常用的索引类型，它被广泛地用于各种存储引擎，如 MyISAM、InnoDB 和 Memory。B+Tree<br>\n 索引提供了高效的范围查询、前缀查询和排序功能。<br>\nB+Tree 索引是在 B-Tree 基础上，通过引入指针来优化存储和检索数据。在介绍 B+Tree 索引之前，先介绍下 B-Tree 索引。</p>\n<h4 id=\"b-tree索引\"><a class=\"markdownIt-Anchor\" href=\"#b-tree索引\">#</a> B-Tree 索引</h4>\n<p>B-Tree 结构：</p>\n<ul>\n<li>B-Tree（平衡二叉查找树）是一种自平衡的树形数据结构。</li>\n<li>每个节点最多包含 M 个子节点，其中 M 是一个固定的参数，称为阶数。</li>\n<li>每个节点包含 M-1 个键值和相应的指针。</li>\n</ul>\n<img data-src=\"/joker.github.io/2024/10/09/%E3%80%90Mysql%E3%80%91Mysql%E8%AF%A6%E8%A7%A3/v2-9a8025fcd8ffdb921a6a124713fa0f7f_r.png\" class=\"\" title=\"v2-9a8025fcd8ffdb921a6a124713fa0f7f_r.png\">\n<p>节点结构：</p>\n<ul>\n<li>根节点：树的顶部节点。</li>\n<li>内部节点：包含多个键值和指针，用于指向子节点。</li>\n<li>叶子节点：包含实际的数据行或数据行的指针。</li>\n</ul>\n<p>键值顺序：</p>\n<ul>\n<li>B-Tree 中的键值是按顺序存储的，每个节点内的键值也是有序的。</li>\n<li>所有的叶子节点都位于同一层，并且通过双向链表连接。</li>\n</ul>\n<p>B-Tree 索引的特点</p>\n<ul>\n<li>高效查询：\n<ul>\n<li>B-Tree 索引支持范围查询、前缀查询和等值查询。</li>\n<li>查询时可以通过键值快速定位到相应的叶子节点。</li>\n</ul>\n</li>\n<li>自平衡：\n<ul>\n<li>B-Tree 在插入和删除操作时能够保持自平衡，确保树的高度较小，从而提高查询效率。</li>\n</ul>\n</li>\n<li>支持范围查询：\n<ul>\n<li>通过遍历叶子节点实现范围查询。</li>\n</ul>\n</li>\n<li>支持前缀查询：\n<ul>\n<li>通过遍历叶子节点实现前缀查询。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"btree-索引\"><a class=\"markdownIt-Anchor\" href=\"#btree-索引\">#</a> B+Tree 索引</h4>\n<p>B+Tree 结构：</p>\n<ul>\n<li>B+Tree 是一种改进的 B-Tree，特别适用于文件系统和数据库索引。</li>\n<li>每个节点最多包含 M 个子节点，其中 M 是一个固定的参数，称为阶数。</li>\n<li>所有数据行都存储在叶子节点中。</li>\n</ul>\n<img data-src=\"/joker.github.io/2024/10/09/%E3%80%90Mysql%E3%80%91Mysql%E8%AF%A6%E8%A7%A3/v2-9a8025fcd8ffdb921a6a124713fa0f7f_r.png\" class=\"\" title=\"v2-9a8025fcd8ffdb921a6a124713fa0f7f_r.png\">\n<p>节点结构：</p>\n<ul>\n<li>根节点：树的顶部节点。</li>\n<li>内部节点：仅包含键值和指针，用于指向子节点。</li>\n<li>叶子节点：包含实际的数据行，并通过双向链表连接。</li>\n</ul>\n<p>键值顺序：</p>\n<ul>\n<li>B+Tree 中的键值是按顺序存储的，所有叶子节点位于同一层，并通过双向链表连接。</li>\n</ul>\n<p>B+Tree 索引的特点</p>\n<ul>\n<li>高效查询：\n<ul>\n<li>支持等值查询、范围查询和前缀查询。</li>\n<li>查询时可以通过键值快速定位到相应的叶子节点。</li>\n</ul>\n</li>\n<li>自平衡：\n<ul>\n<li>在插入和删除操作时能够保持自平衡，确保树的高度较小，从而提高查询效率。</li>\n</ul>\n</li>\n<li>支持范围查询：\n<ul>\n<li>通过遍历叶子节点实现范围查询，所有叶子节点通过双向链表连接，便于遍历。</li>\n</ul>\n</li>\n<li>支持前缀查询：\n<ul>\n<li>通过遍历叶子节点实现前缀查询。</li>\n</ul>\n</li>\n<li>支持排序：\n<ul>\n<li>所有数据行都存储在叶子节点中，通过双向链表连接，便于排序和遍历。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"btree索引和b-tree索引的区别\"><a class=\"markdownIt-Anchor\" href=\"#btree索引和b-tree索引的区别\">#</a> B+Tree 索引和 B-Tree 索引的区别</h4>\n<p>数据存储位置：</p>\n<ul>\n<li>B-Tree：数据可以存储在内部节点和叶子节点中。</li>\n<li>B+Tree：所有数据只存储在叶子节点中，内部节点只包含键值和指针。</li>\n</ul>\n<p>查询性能：</p>\n<ul>\n<li>B-Tree：查询可能需要访问多个层级的节点，直到找到叶子节点。</li>\n<li>B+Tree：查询总是需要访问到叶子节点，但叶子节点通过双向链表连接，便于遍历。</li>\n</ul>\n<p>范围查询：</p>\n<ul>\n<li>\n<p>B-Tree：范围查询需要遍历多个层级的节点，直到找到所有符合条件的叶子节点。</p>\n</li>\n<li>\n<p>B+Tree：范围查询只需要遍历叶子节点即可，因为所有叶子节点通过双向链表连接。</p>\n</li>\n<li>\n<p>数据冗余：</p>\n<ul>\n<li>B-Tree：数据存储在内部节点和叶子节点中，可能存在数据冗余。</li>\n<li>B+Tree：数据只存储在叶子节点中，避免了数据冗余。</li>\n</ul>\n</li>\n</ul>\n<p>磁盘访问优化：</p>\n<ul>\n<li>B-Tree：每次查询可能需要多次磁盘访问。</li>\n<li>B+Tree：查询总是需要访问到叶子节点，但叶子节点通过双向链表连接，减少了磁盘访问次数。</li>\n</ul>\n<h4 id=\"为什么要使用btree索引\"><a class=\"markdownIt-Anchor\" href=\"#为什么要使用btree索引\">#</a> 为什么要使用 B+Tree 索引？</h4>\n<ol>\n<li>\n<p>数据存储在叶子节点</p>\n<p>在 B+Tree 中，所有数据行都存储在叶子节点中，而内部节点只包含键值和指针。这种结构有以下几个优势：</p>\n<ul>\n<li>减少磁盘 I/O 次数：在磁盘访问中，每次读取或写入一个块都需要一次 I/O 操作。由于所有数据都存储在叶子节点中，查询时只需要访问叶子节点，减少了磁盘<br>\n I/O 次数。</li>\n<li>数据一致性：所有数据存储在叶子节点中，避免了数据冗余，确保数据的一致性和完整性。</li>\n</ul>\n</li>\n<li>\n<p>高效的范围查询</p>\n<p>B+Tree 的叶子节点通过双向链表连接，这使得范围查询更加高效：</p>\n<ul>\n<li>范围查询：当执行范围查询（如 WHERE id BETWEEN 10 AND 20）时，只需要遍历叶子节点即可。由于叶子节点通过双向链表连接，可以快速遍历整个范围。</li>\n<li>排序查询：当执行排序查询（如 ORDER BY id ASC）时，同样可以通过遍历叶子节点来实现排序。</li>\n</ul>\n</li>\n<li>\n<p>自平衡性</p>\n<p>B+Tree 具有自平衡性，能够在插入和删除操作时保持树的高度较小，从而提高查询效率：</p>\n<ul>\n<li>自平衡：在插入或删除操作时，B+Tree 会自动调整节点，确保树的高度保持较小，从而提高查询效率。</li>\n</ul>\n</li>\n<li>\n<p>更好的磁盘访问优化</p>\n<p>B+Tree 在磁盘访问方面具有更好的优化：</p>\n<ul>\n<li>减少磁盘 I/O：由于所有数据都存储在叶子节点中，查询时只需要访问叶子节点，减少了磁盘 I/O 次数。</li>\n<li>高效的数据块利用：B+Tree 的节点可以容纳更多的键值和指针，提高了数据块的利用率，减少了磁盘空间浪费。</li>\n</ul>\n</li>\n<li>\n<p>支持联合索引</p>\n<p>B+Tree 支持联合索引（复合索引），可以同时使用多个字段进行索引：</p>\n<ul>\n<li>联合索引：例如，可以创建一个联合索引 (col1, col2)，在查询时可以使用这两个字段进行快速定位。</li>\n<li>多列排序：联合索引还可以用于多列排序，提高排序查询的效率。</li>\n</ul>\n</li>\n<li>\n<p>更好的并发控制</p>\n<p>B+Tree 在并发控制方面也表现出色：</p>\n<ul>\n<li>锁定机制：在并发操作中，B+Tree 可以通过锁定机制来保证数据的一致性和完整性。</li>\n<li>事务处理：B+Tree 在事务处理中能够更好地支持并发操作，提高事务处理的效率。</li>\n</ul>\n</li>\n<li>\n<p>更好的扩展性</p>\n<p>B+Tree 在扩展性方面具有优势：</p>\n<ul>\n<li>易于扩展：由于所有数据都存储在叶子节点中，B+Tree 在扩展时更容易进行数据分布和分区。</li>\n<li>分布式系统：在分布式数据库系统中，B+Tree 更容易实现数据的水平分割和分布。</li>\n</ul>\n</li>\n<li>\n<p>内存和缓存友好</p>\n<p>B+Tree 的结构更适合内存和缓存：</p>\n<ul>\n<li>内存利用：B+Tree 的内部节点只包含键值和指针，占用较少的内存空间，适合内存缓存。</li>\n<li>缓存命中率：由于所有数据都在叶子节点中，缓存命中率更高，减少了从磁盘读取数据的次数。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"btree-索引的自平衡\"><a class=\"markdownIt-Anchor\" href=\"#btree-索引的自平衡\">#</a> B+Tree 索引的自平衡</h4>\n<p>B+Tree 的自平衡主要通过以下几种方式实现：</p>\n<ol>\n<li>\n<p>节点分裂</p>\n<p>当向 B+Tree 中插入一个新的键值时，如果当前节点已满，则需要将该节点分裂成两个节点。节点分裂的具体步骤如下：</p>\n<ol>\n<li>确定分裂点：\n<ul>\n<li>如果当前节点已满（即包含 M-1 个键值），则需要将其分裂成两个节点。</li>\n<li>将中间的键值作为新的中间节点的键值。</li>\n</ul>\n</li>\n<li>创建新节点：\n<ul>\n<li>创建一个新的节点，将原节点的一部分键值移动到新节点中。</li>\n<li>新节点包含大约一半的键值。</li>\n</ul>\n</li>\n<li>更新父节点：\n<ul>\n<li>在父节点中插入一个新的键值，指向新创建的节点。</li>\n<li>如果父节点已满，则继续向上分裂。</li>\n</ul>\n</li>\n</ol>\n<p>示例</p>\n<p>假设 B+Tree 的阶数为 M=3，每个节点最多包含 2 个键值。</p>\n<ol>\n<li>初始状态： <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n</li>\n<li>插入键值 4：\n<ol>\n<li>当前节点已满，需要分裂。</li>\n<li>将中间的键值 2 提升到父节点，创建两个新节点 [1] 和 [3, 4]。</li>\n<li>更新父节点：</li>\n</ol>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> [<span class=\"number\">2</span>]</span><br><span class=\"line\"> / \\</span><br><span class=\"line\">[<span class=\"number\">1</span>] [<span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n</li>\n<li>插入键值 5：\n<ol>\n<li>当前节点已满，需要分裂。</li>\n<li>将中间的键值 4 提升到父节点，创建两个新节点 [3] 和 [5]。</li>\n<li>更新父节点：</li>\n</ol>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">  / \\ / \\</span><br><span class=\"line\">[<span class=\"number\">1</span>] [<span class=\"number\">3</span>] [<span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p>节点合并</p>\n<p>当从 B+Tree 中删除一个键值时，如果某个节点的键值数量少于最小键值数量（即小于 M/2），则需要进行节点合并。节点合并的具体步骤如下：</p>\n<ol>\n<li>确定合并条件：\n<ul>\n<li>如果当前节点的键值数量少于 M/2，则需要与相邻的兄弟节点合并。</li>\n<li>选择一个相邻的兄弟节点，将其中一个键值移动到当前节点。</li>\n</ul>\n</li>\n<li>合并节点：\n<ul>\n<li>将相邻节点的一个键值移动到当前节点，使当前节点的键值数量达到 M/2。</li>\n<li>更新父节点中的键值。</li>\n</ul>\n</li>\n<li>更新父节点：\n<ul>\n<li>如果父节点的键值数量少于 M/2，则继续向上合并。</li>\n</ul>\n</li>\n</ol>\n<p>示例</p>\n<p>假设 B+Tree 的阶数为 M=3，每个节点最多包含 2 个键值。</p>\n<ol>\n<li>初始状态：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">  / \\ / \\</span><br><span class=\"line\">[<span class=\"number\">1</span>] [<span class=\"number\">3</span>] [<span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure>\n</li>\n<li>删除键值 4：\n<ol>\n<li>删除键值 4 后，节点 [3] 的键值数量少于 M/2，需要与相邻节点合并。</li>\n<li>将 [2] 和 [3] 合并，更新父节点：</li>\n</ol>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  [<span class=\"number\">2</span>]</span><br><span class=\"line\">  / \\</span><br><span class=\"line\">[<span class=\"number\">1</span>] [<span class=\"number\">3</span>, <span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"什么情况下无法使用索引\"><a class=\"markdownIt-Anchor\" href=\"#什么情况下无法使用索引\">#</a> 什么情况下无法使用索引</h3>\n<p>在 MySQL 中，索引可以显著提高查询性能，但并不是所有的查询都能有效地利用索引。</p>\n<ol>\n<li>使用 LIKE 操作符时\n<ul>\n<li>情况描述：当 LIKE 操作符的模式以通配符（如 %）开头时，索引通常无法被有效利用。例如，SELECT * FROM table WHERE column<br>\nLIKE ‘%abc%’。</li>\n<li>原因：索引通常是按照键值顺序存储的，而以通配符开头的模式会导致 MySQL 无法直接定位到特定的位置，因此需要进行全表扫描。</li>\n</ul>\n</li>\n<li>使用函数或表达式\n<ul>\n<li>情况描述：当查询条件中包含函数或表达式时，索引通常无法被利用。例如，SELECT * FROM table WHERE UPPER (column) = ‘ABC’ 或<br>\n SELECT * FROM table WHERE column + 1 = 5。</li>\n<li>原因：函数或表达式改变了索引键值的形式，导致索引无法直接匹配。</li>\n</ul>\n</li>\n<li>使用 OR 连接多个条件\n<ul>\n<li>情况描述：当查询条件中包含多个 OR 逻辑时，索引可能无法被有效利用。例如，SELECT * FROM table WHERE column1 = ‘A’ OR<br>\ncolumn2 = ‘B’。</li>\n<li>原因：多个 OR 条件可能导致 MySQL 需要扫描多个索引或进行全表扫描。</li>\n</ul>\n</li>\n<li>使用 NOT IN 或 NOT EXISTS\n<ul>\n<li>情况描述：当查询条件中包含 NOT IN 或 NOT EXISTS 时，索引可能无法被有效利用。例如，SELECT * FROM table WHERE column NOT<br>\nIN (‘A’, ‘B’, ‘C’) 或 SELECT * FROM table WHERE NOT EXISTS (SELECT 1<br>\nFROM other_table WHERE other_table.id = <span class=\"exturl\" data-url=\"aHR0cDovL3RhYmxlLmlk\">table.id</span>)。</li>\n<li>原因：NOT IN 和 NOT EXISTS 可能导致 MySQL 需要进行多次查找或全表扫描。</li>\n</ul>\n</li>\n<li>使用 IS NULL 或 IS NOT NULL\n<ul>\n<li>情况描述：当查询条件中包含 IS NULL 或 IS NOT NULL 时，索引可能无法被有效利用。例如，SELECT * FROM table WHERE column<br>\nIS NULL 或 SELECT * FROM table WHERE column IS NOT NULL。</li>\n<li>原因：索引通常不包含 NULL 值，因此在这种情况下索引无法直接定位到特定的位置。</li>\n</ul>\n</li>\n<li>使用 IN 语句且参数较多\n<ul>\n<li>情况描述：当查询条件中包含 IN 语句且参数较多时，索引可能无法被有效利用。例如，SELECT * FROM table WHERE column IN (’<br>\nA’, ‘B’, ‘C’, …, ‘Z’)。</li>\n<li>原因：大量的 IN 参数可能导致 MySQL 需要进行多次查找或全表扫描。</li>\n</ul>\n</li>\n<li>使用 ORDER BY 或 GROUP BY 未覆盖索引\n<ul>\n<li>情况描述：当查询条件中包含 ORDER BY 或 GROUP BY 但未覆盖索引时，索引可能无法被有效利用。例如，SELECT * FROM table<br>\nORDER BY column1, column2。</li>\n<li>原因：如果索引没有包含所有排序或分组的列，MySQL 可能需要额外的排序操作。</li>\n</ul>\n</li>\n<li>使用 LIMIT 但未指定排序\n<ul>\n<li>情况描述：当查询条件中包含 LIMIT 但未指定排序时，索引可能无法被有效利用。例如，SELECT * FROM table LIMIT 10。</li>\n<li>原因：如果没有指定排序，MySQL 可能需要全表扫描来获取前几条记录。</li>\n</ul>\n</li>\n<li>使用 JOIN 但未指定合适的索引\n<ul>\n<li>情况描述：当查询条件中包含 JOIN 但未指定合适的索引时，索引可能无法被有效利用。例如，SELECT * FROM table1 JOIN table2<br>\nON <span class=\"exturl\" data-url=\"aHR0cDovL3RhYmxlMS5pZA==\">table1.id</span> = <span class=\"exturl\" data-url=\"aHR0cDovL3RhYmxlMi5pZA==\">table2.id</span>。</li>\n<li>原因：如果没有合适的索引，MySQL 可能需要进行全表扫描或多次查找。</li>\n</ul>\n</li>\n<li>使用 BETWEEN 但未覆盖索引\n<ul>\n<li>情况描述：当查询条件中包含 BETWEEN 但未覆盖索引时，索引可能无法被有效利用。例如，SELECT * FROM table WHERE column<br>\nBETWEEN ‘A’ AND ‘Z’。</li>\n<li>原因：如果索引没有包含所有查询条件的列，MySQL 可能需要额外的查找操作。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"最左匹配原则\"><a class=\"markdownIt-Anchor\" href=\"#最左匹配原则\">#</a> 最左匹配原则</h3>\n<p>最左匹配原则是指在复合索引中，查询条件必须从索引的最左边开始匹配，才能有效地利用索引。具体来说：</p>\n<ul>\n<li>复合索引：由多个列组成的索引。</li>\n<li>最左匹配：查询条件必须从索引的第一个列开始，依次向右匹配。</li>\n</ul>\n<p>示例说明</p>\n<p>假设有一个复合索引 (col1, col2, col3)，那么查询条件必须从 col1 开始，然后依次向右匹配 col2 和 col3。</p>\n<ul>\n<li>\n<p>有效的查询条件</p>\n<ul>\n<li>SELECT * FROM table WHERE col1 = ‘value1’</li>\n<li>SELECT * FROM table WHERE col1 = ‘value1’ AND col2 = ‘value2’</li>\n<li>SELECT * FROM table WHERE col2 = ‘value2’ AND col1 = ‘value1’</li>\n</ul>\n<p>这些查询条件都能够有效地利用索引 (col1, col2, col3)。</p>\n</li>\n<li>\n<p>无效的查询条件</p>\n<ul>\n<li>SELECT * FROM table WHERE col2 = ‘value2’</li>\n<li>SELECT * FROM table WHERE col2 = ‘value2’ AND col3 = ‘value3’</li>\n<li>SELECT * FROM table WHERE col3 = ‘value3’</li>\n</ul>\n<p>这些查询条件无法有效地利用索引 (col1, col2, col3)，因为它们没有从索引的最左边开始匹配。</p>\n</li>\n</ul>\n<p>最左匹配原则的例外情况</p>\n<p>尽管最左匹配原则是一个基本规则，但在某些情况下，MySQL 仍可以部分地利用索引：</p>\n<ol>\n<li>使用 OR 但条件相同<br>\n有效示例： <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">WHERE</span> col1 <span class=\"operator\">=</span> <span class=\"string\">&#x27;value1&#x27;</span> <span class=\"keyword\">OR</span> col1 <span class=\"operator\">=</span> <span class=\"string\">&#x27;value2&#x27;</span>;</span><br></pre></td></tr></table></figure>\n这种查询条件虽然使用了 OR，但条件相同，可以从索引的最左边开始匹配，可以有效地利用索引 (col1, col2, col3)。</li>\n<li>使用 IN 语句<br>\n有效示例： <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">WHERE</span> col1 <span class=\"keyword\">IN</span> (<span class=\"string\">&#x27;value1&#x27;</span>, <span class=\"string\">&#x27;value2&#x27;</span>);</span><br></pre></td></tr></table></figure>\n这种查询条件虽然使用了 IN 语句，但可以从索引的最左边开始匹配，可以有效地利用索引 (col1, col2, col3)。</li>\n</ol>\n<p>最左匹配原则的优化建议</p>\n<ul>\n<li>合理设计索引：根据查询需求设计合理的复合索引，确保查询条件能够从索引的最左边开始匹配。</li>\n<li>避免使用函数或表达式：查询条件中尽量避免使用函数或表达式，因为它们可能会导致索引失效。</li>\n<li>使用 EXPLAIN 查看执行计划：使用 EXPLAIN 命令查看查询的执行计划，检查是否有效地利用了索引。</li>\n</ul>\n<h2 id=\"事务\"><a class=\"markdownIt-Anchor\" href=\"#事务\">#</a> 事务</h2>\n<p>事务可以理解为一组相关操作的集合，这些操作作为一个整体执行。事务的主要目的是确保数据的一致性和完整性，即使在出现故障的情况下也能保证数据的正确性。</p>\n<p>事务通常具备四个主要特性，称为 ACID 特性：</p>\n<ul>\n<li>原子性（Atomicity）：事务中的所有操作要么全部成功，要么全部失败。如果事务中的任何一部分失败，则整个事务都会回滚，恢复到事务开始之前的状态。</li>\n<li>一致性（Consistency）：事务执行后，数据库必须处于一致性的状态。这意味着事务执行前后，数据库的状态必须满足预定的约束和业务规则。</li>\n<li>隔离性（Isolation）：事务之间相互独立，一个事务的操作不会影响其他事务的结果。每个事务看起来像是在单独的系统中执行一样。</li>\n<li>持久性（Durability）：一旦事务提交（commit），其结果就会永久保存在数据库中，即使系统发生故障也不会丢失。</li>\n</ul>\n<p>事务通常包括以下基本操作：</p>\n<ol>\n<li>开始事务（BEGIN TRANSACTION）：开始一个新的事务，标记事务的起点。</li>\n<li>提交事务（COMMIT）：提交事务，将事务中的所有更改永久保存到数据库中。</li>\n<li>回滚事务（ROLLBACK）：回滚事务，撤销事务中的所有更改，恢复到事务开始之前的状态。</li>\n<li>保存点（SAVEPOINT）：在事务中设置一个保存点，可以在后续操作中回滚到这个保存点。</li>\n</ol>\n<h3 id=\"并发事务\"><a class=\"markdownIt-Anchor\" href=\"#并发事务\">#</a> 并发事务</h3>\n<p>并发事务是指多个事务同时对同一个数据进行操作，可能导致数据不一致的情况。<br>\n以下是一些常见的并发事务问题：</p>\n<ul>\n<li>\n<p>脏读：一个事务读取到另一个事务尚未提交的数据。 事务 A 读取事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。</p>\n</li>\n<li>\n<p>不可重复读：一个事务中两次读取的数据的内容不一致。 事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务<br>\n A 多次读取同一数据时，结果 不一致。</p>\n</li>\n<li>\n<p>幻读：一个事务中两次读取的数据量不一致。 系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B<br>\n 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p>\n</li>\n</ul>\n<p>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。 解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p>\n<p>如何解决并发事务问题？</p>\n<p>MySQL 事务的隔离级别定义了事务之间相互隔离的程度，不同的隔离级别有不同的效果：</p>\n<ul>\n<li>读未提交（Read Uncommitted）：\n<ul>\n<li>最低的隔离级别，允许事务读取未提交的数据。</li>\n<li>容易产生脏读、不可重复读和幻读。</li>\n</ul>\n</li>\n<li>读已提交（Read Committed）：\n<ul>\n<li>允许事务读取已提交的数据。</li>\n<li>防止脏读，但仍然可能出现不可重复读和幻读。</li>\n</ul>\n</li>\n<li>可重复读（Repeatable Read）：\n<ul>\n<li>事务在整个执行期间读取的数据始终不变。</li>\n<li>防止脏读和不可重复读，但仍然可能出现幻读。</li>\n</ul>\n</li>\n<li>序列化（Serializable）：\n<ul>\n<li>最高的隔离级别，完全隔离事务，防止所有并发问题。</li>\n<li>可能导致性能下降，但确保了最高的数据一致性。</li>\n</ul>\n</li>\n</ul>\n<p>不同的隔离级别对性能和数据准确性的影响均不相同，需要根据具体的业务场景来做出取舍。顺带一提，在 MySQL<br>\n 中，默认的事务隔离级别是可重复读（Repeatable Read）。</p>\n<h2 id=\"锁\"><a class=\"markdownIt-Anchor\" href=\"#锁\">#</a> 锁</h2>\n<p>MySQL 中的锁机制是数据库管理系统中非常重要的一部分，用于确保并发操作的一致性和数据的完整性。锁机制可以防止多个事务同时修改同一份数据，从而避免数据冲突和不一致的问题。</p>\n<h3 id=\"mysql-中的锁类型\"><a class=\"markdownIt-Anchor\" href=\"#mysql-中的锁类型\">#</a> MySQL 中的锁类型</h3>\n<ol>\n<li>\n<p>表级锁（Table-Level Locks）</p>\n<p>表级锁是最粗粒度的锁，对整个表进行锁定。这种锁简单且易于实现，但在高并发环境下性能较差。</p>\n<p>类型</p>\n<ul>\n<li>读锁（READ LOCK）：\n<ul>\n<li>只允许读取数据，不允许写入数据。</li>\n<li>多个读锁可以同时存在。</li>\n</ul>\n</li>\n<li>写锁（WRITE LOCK）：\n<ul>\n<li>独占锁，不允许读取和写入数据。</li>\n<li>只有一个写锁可以存在。</li>\n</ul>\n</li>\n</ul>\n<p>应用场景</p>\n<ul>\n<li>备份和恢复：在备份或恢复数据时，可以使用表级锁确保数据的一致性。</li>\n<li>低并发环境：在并发较低的环境中，可以使用表级锁简化锁管理。</li>\n</ul>\n</li>\n<li>\n<p>行级锁（Row-Level Locks）</p>\n<p>行级锁是对表中的单个行进行锁定，粒度较细，适用于高并发环境。</p>\n<p>存储引擎支持</p>\n<ul>\n<li>InnoDB：支持行级锁，广泛应用于高并发环境。</li>\n<li>MyISAM：不支持行级锁，只支持表级锁。</li>\n</ul>\n<p>类型</p>\n<ul>\n<li>共享锁（Shared Lock，S 锁）：\n<ul>\n<li>多个事务可以同时读取同一行数据。</li>\n<li>读取操作可以并行执行。</li>\n</ul>\n</li>\n<li>排他锁（Exclusive Lock，X 锁）：\n<ul>\n<li>排他锁独占，不允许其他事务读取或写入同一行数据。</li>\n<li>写入操作独占执行。</li>\n</ul>\n</li>\n</ul>\n<p>应用场景</p>\n<ul>\n<li>并发读写：在高并发环境中，行级锁可以允许多个事务同时读取数据，提高并发性能。</li>\n<li>事务处理：在事务处理中，行级锁可以确保数据的一致性和完整性。</li>\n</ul>\n</li>\n<li>\n<p>页面级锁（Page-Level Locks）</p>\n<p>页面级锁是对表中的一页数据进行锁定，粒度介于表级锁和行级锁之间。</p>\n<p>存储引擎支持</p>\n<ul>\n<li>BDB（Berkeley DB）：支持页面级锁。</li>\n<li>InnoDB：支持页面级锁，但在实际应用中更常用的是行级锁。</li>\n</ul>\n<p>应用场景</p>\n<ul>\n<li>中等并发环境：在中等并发环境中，页面级锁可以提高并发性能，减少锁的竞争。</li>\n</ul>\n</li>\n<li>\n<p>意向锁（Intention Locks）</p>\n<p>意向锁是一种辅助锁，用于指示事务打算对数据进行的操作类型。</p>\n<p>类型</p>\n<ul>\n<li>意向共享锁（Intention Shared Lock，IS 锁）：\n<ul>\n<li>表示事务打算获取某一行的共享锁。</li>\n</ul>\n</li>\n<li>意向排他锁（Intention Exclusive Lock，IX 锁）：\n<ul>\n<li>表示事务打算获取某一行的排他锁。</li>\n</ul>\n</li>\n</ul>\n<p>应用场景</p>\n<ul>\n<li>事务管理：在事务管理中，意向锁帮助数据库管理系统预测事务的操作类型，提前准备相应的锁资源。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"mysql-中的锁机制\"><a class=\"markdownIt-Anchor\" href=\"#mysql-中的锁机制\">#</a> MySQL 中的锁机制</h3>\n<p>InnoDB 存储引擎广泛应用于 MySQL 中，其支持多种锁机制。<br>\n锁与事务隔离级别的关系如下：</p>\n<ul>\n<li>读未提交（Read Uncommitted）：不使用任何锁。</li>\n<li>读已提交（Read Committed）：使用行级锁，读取时不加锁。</li>\n<li>可重复读（Repeatable Read）：使用行级锁，读取时加锁。</li>\n<li>序列化（Serializable）：使用行级锁，读取时加锁，确保最高隔离级别。</li>\n</ul>\n<p>间隙锁（Gap Locks）</p>\n<ul>\n<li>定义：间隙锁锁定行之间的 “间隙”，防止插入新的行。</li>\n<li>应用场景：在可重复读隔离级别下，InnoDB 使用间隙锁防止插入新的行。</li>\n</ul>\n",
            "tags": [
                "后端",
                "数据库",
                "关系型数据库",
                "Mysql"
            ]
        },
        {
            "id": "https://silvercrow42.github.io/joker.github.io/2024/09/25/%E3%80%90Linux%E3%80%91Linux%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/",
            "url": "https://silvercrow42.github.io/joker.github.io/2024/09/25/%E3%80%90Linux%E3%80%91Linux%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/",
            "title": "【Linux】Linux命令详解",
            "date_published": "2024-09-25T01:54:17.000Z",
            "content_html": "<h2 id=\"设计理念\"><a class=\"markdownIt-Anchor\" href=\"#设计理念\">#</a> 设计理念</h2>\n<h3 id=\"什么是linux\"><a class=\"markdownIt-Anchor\" href=\"#什么是linux\">#</a> 什么是 Linux</h3>\n<p>Linux 是一种基于 Unix 的开源操作系统，其内核由 Linus Torvalds 在 1991 年创建。<br>\nLinux 操作系统以其稳定性和安全性著称，并且由于它是开源的，任何人都可以查看和修改其源代码，这使得 Linux 成为了一个非常灵活且可定制的操作系统。<br>\nLinux 可以运行在从嵌入式设备到超级计算机的各种硬件平台上，并且支持多用户、多任务、多线程和多 CPU。</p>\n<p>Linux 发行版指的是基于 Linux 内核构建的完整操作系统，它们通常包括了图形用户界面（GUI）、实用工具、文档以及安装程序等。<br>\n不同的发行版可能有不同的目标用户群、默认的应用程序集、系统配置工具以及软件包管理系统等。以下是一些常见的 Linux 发行版：</p>\n<ul>\n<li>Ubuntu - 这是一个非常流行的面向桌面用户的发行版，也是许多服务器的选择。Ubuntu 强调易用性和社区支持，并且拥有一个庞大的软件仓库，用户可以通过<br>\n APT (Advanced Package Tool) 轻松地安装软件。</li>\n<li>Red Hat Enterprise Linux (RHEL) - 这是一个商业化的发行版，主要用于企业环境中的服务器。RHEL 提供了长期的支持和服务，确保了企业的稳定运行。</li>\n<li>Fedora - Fedora 是 Red Hat 的社区版本，它经常作为新技术的试验场，为 RHEL 提供技术基础。Fedora 更新频繁，适合喜欢尝试新技术的用户。</li>\n<li>CentOS - 这是一个基于 RHEL 构建的免费发行版，旨在尽可能地兼容 RHEL。CentOS 通常用于那些希望使用类似 RHEL<br>\n 的稳定系统但又不想支付许可费用的场景。</li>\n<li>openSUSE - 这是一个德国的发行版，在欧洲尤其受欢迎。openSUSE 提供了一个稳定的平台，支持多种桌面环境，并且有一个强大的软件管理工具<br>\n YaST。</li>\n<li>Arch Linux - Arch Linux 以其滚动发布模式和高度可定制性而闻名，适合高级用户和那些希望从头开始构建自己系统的用户。</li>\n<li>Debian - Debian 是一个社区驱动的项目，致力于创造一个自由的操作系统。Debian 以其稳定性著称，并且是许多其他发行版的基础。</li>\n</ul>\n<h3 id=\"什么叫一切皆文件\"><a class=\"markdownIt-Anchor\" href=\"#什么叫一切皆文件\">#</a> 什么叫一切皆文件</h3>\n<p>在 Linux 系统中，“一切皆文件” 是一种设计理念，它来源于 Unix<br>\n 的设计哲学。这一理念的核心思想是将系统中的各种资源抽象成文件的形式，从而简化了对这些资源的操作。具体来说，这意味着无论是普通的文件、目录、硬件设备（如键盘、显示器、硬盘等）、网络连接还是进程间通信机制（如管道、套接字等），在<br>\n Linux 中都可以通过文件接口来访问和控制。<br>\n以下是 Linux 中一些被视为 “文件” 的资源的例子：</p>\n<ul>\n<li>普通文件 - 包含数据的文件，如文本文件、图片文件等。</li>\n<li>目录 - 在 Linux 中，目录也是一种特殊的文件，它包含的是指向其他文件或目录的索引节点。</li>\n<li>符号链接 - 又称为软链接，相当于 Windows 中的快捷方式，指向另一个文件的引用。</li>\n<li>硬链接 - 指向文件 inode（文件索引节点）的多个文件名，允许一个文件有多个路径名。</li>\n<li>设备文件 - 分为块设备文件（如硬盘、光驱）和字符设备文件（如串口、声卡），它们代表了物理设备，可以通过读写这些文件来与硬件交互。</li>\n<li>管道 - 一种进程间通信的方式，可以视为一种特殊的文件，用来在进程之间传递数据。</li>\n<li>套接字（Socket） - 用于网络通信或者本地进程间通信的一种机制，也可以通过文件系统来访问。</li>\n</ul>\n<p>这种 “一切皆文件” 的设计理念带来的好处是统一了对不同资源的操作方式，开发者只需要掌握一套 API 和工具就可以操作几乎所有的系统资源。<br>\n例如，打开一个硬件设备的操作和打开一个普通文件的操作在接口上是类似的，都是通过 open (), read (), write (), close ()<br>\n 这样的系统调用来完成。</p>\n<p>然而，这种设计也有一定的复杂性，特别是对于初学者来说，理解各种 “文件” 的概念和用途可能需要一定的时间。此外，使用任何硬件设备都需要将其挂载到文件系统的某个位置，否则无法访问。这种挂载机制确保了文件系统的灵活性和扩展性。</p>\n<h2 id=\"基础知识\"><a class=\"markdownIt-Anchor\" href=\"#基础知识\">#</a> 基础知识</h2>\n<h3 id=\"linux-文件结构\"><a class=\"markdownIt-Anchor\" href=\"#linux-文件结构\">#</a> Linux 文件结构</h3>\n<p>Linux 文件系统采用了一种倒置的树形结构，所有的文件和目录都从唯一的根目录 / 开始。这种结构使得文件组织变得非常清晰，并且易于理解和维护。<br>\n以下是 Linux 文件系统中一些主要目录的作用和内容概述：</p>\n<ul>\n<li><code>/ (根目录)</code>  - 所有其他文件和目录的起点。通常不直接存放文件。</li>\n<li><code>/bin</code>  - 存放必要的用户二进制文件（可执行文件），这些文件对于系统的启动和运行至关重要，任何用户都可以执行这些二进制文件。</li>\n<li><code>/boot</code>  - 存放启动系统所需的文件，如内核映像文件、引导加载程序等。</li>\n<li><code>/dev</code>  - 存放设备文件，即代表硬件设备的特殊文件，如硬盘、键盘、鼠标等。</li>\n<li><code>/etc</code>  - 存放系统配置文件的地方，大部分配置文件都是文本文件，可以被编辑以调整系统行为。</li>\n<li><code>/home</code>  - 存放普通用户的主目录，每个用户都有自己的目录，用于存储个人文件和设置。</li>\n<li><code>/lib</code>  - 存放系统启动和执行 /bin 和 /sbin 目录下的命令所需要的共享库文件。通常包含 32 位和 64 位的库文件，具体取决于系统配置。</li>\n<li><code>/lib64</code>  - 专门存放 64 位的库文件，特别是在 64 位的 Linux 系统中。 仅包含 64 位的库文件。</li>\n<li><code>/lost+found</code>  - 通常出现在文件系统挂载点，用于存放 fsck（文件系统检查工具）在修复文件系统时发现的丢失文件。</li>\n<li><code>/media</code>  - 用于挂载可移动媒体，如 USB 闪存盘、CD/DVD 驱动器等。</li>\n<li><code>/mnt</code>  - 用于挂载外部设备或文件系统，如 USB 驱动器、CD-ROM 等。</li>\n<li><code>/opt</code>  - 用于存放可选的第三方应用程序，这些应用程序通常是由厂商提供的。</li>\n<li><code>/proc</code>  - 一个虚拟文件系统，用于提供关于当前运行的进程的信息，以及系统内核的状态。这个目录的内容是由内核动态生成的。</li>\n<li><code>/sbin</code>  - 存放系统管理员使用的二进制文件，这些文件通常是只有 root 用户才有权限执行的。</li>\n<li><code>/sys</code>  - 类似于 /proc，但用于提供内核对象（如设备驱动程序）的接口。</li>\n<li><code>/tmp</code>  - 用于存放临时文件，这些文件通常在系统重启之后会被清除。</li>\n<li><code>/usr</code>  - 用于存放用户程序和数据，包括应用程序的二进制文件、帮助文件、文档等。/usr 下还有 /usr/bin 和 /usr/sbin<br>\n 目录，分别存放用户和系统管理员的程序。</li>\n<li><code>/usr/local</code>  - 用于存放本地管理员自行编译安装的软件和数据，避免与系统自带的软件发生冲突。</li>\n<li><code>/var</code>  - 存放系统产生的变动数据，如日志文件、邮件、打印队列、缓存等。</li>\n</ul>\n<p>这些目录构成了 Linux 文件系统的主体结构，每个目录都有其特定的功能和用途，有助于保持文件系统的整洁和高效。<br>\n了解这些基本目录及其作用对于管理和维护 Linux 系统非常重要。</p>\n<h3 id=\"linux-文件权限\"><a class=\"markdownIt-Anchor\" href=\"#linux-文件权限\">#</a> Linux 文件权限</h3>\n<p>在 Linux 系统中，文件权限是一个重要的概念，它决定了用户能够对文件或目录进行哪些操作。<br>\n文件权限是基于用户和组来管理的，每个文件都有一个所有者和一个所属组，并且有三种类型的权限：读（read, r）、写（write,<br>\nw）和执行（execute, x）。</p>\n<p>文件权限的基本构成</p>\n<p>文件权限由三组权限组成，每组权限对应不同的用户类别：</p>\n<ul>\n<li>所有者权限（User）：文件的所有者可以设置的权限。</li>\n<li>组权限（Group）：文件所属组的成员可以设置的权限。</li>\n<li>其他用户权限（Others）：不属于文件所有者也不属于文件所属组的其他用户可以设置的权限。</li>\n</ul>\n<p>每组权限又分为三种：</p>\n<ul>\n<li>读权限（r）：允许读取文件的内容或列出目录的内容。</li>\n<li>写权限（w）：允许修改文件的内容或在目录中添加 / 删除文件。</li>\n<li>执行权限（x）：允许执行文件（如果文件是可执行的程序或脚本）或访问目录内的内容。</li>\n</ul>\n<p>文件权限可以用两种方式表示：</p>\n<ul>\n<li>符号表示法：使用字母 rwx 或 -（表示无权限）来表示权限。</li>\n<li>数字表示法：使用数字 4（读）、2（写）、1（执行）来表示权限，每组权限的数字相加得到最终的权限值。</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li>符号表示法：rwxr-xr-- 表示文件所有者有读写执行权限，所属组有读和执行权限，其他用户只有读权限。</li>\n<li>数字表示法：754 表示文件所有者有读写执行权限（4 + 2 + 1 = 7），所属组有读和执行权限（4 + 1 = 5），其他用户只有读权限（4 = 4）。</li>\n</ul>\n<p>Linux 还有一些特殊的权限位，比如 SUID（Set User ID）、SGID（Set Group ID）和 Sticky Bit（粘滞位），这些权限位通常用于特定的情况：</p>\n<ul>\n<li>SUID：如果一个可执行文件设置了 SUID 位，那么当非所有者执行这个文件时，该进程将具有文件所有者的权限。</li>\n<li>SGID：类似于 SUID，但对于目录而言，如果设置了 SGID 位，则在该目录中创建的新文件将继承目录的所属组。</li>\n<li>Sticky Bit：如果一个目录设置了 Sticky Bit，那么只有文件的所有者才能删除或重命名该目录中的文件。</li>\n</ul>\n<h2 id=\"linux命令\"><a class=\"markdownIt-Anchor\" href=\"#linux命令\">#</a> Linux 命令</h2>\n<h3 id=\"命令行含义\"><a class=\"markdownIt-Anchor\" href=\"#命令行含义\">#</a> 命令行含义</h3>\n<p>示例： <code>root@app00:~#</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root    #用户名，root为超级用户</span><br><span class=\"line\">@       #分隔符</span><br><span class=\"line\">app00   #主机名称</span><br><span class=\"line\">~       #当前所在目录，默认用户目录为~，会随着目录切换而变化，例如：（root@app00:/bin# ，当前位置在bin目录下）</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">      <span class=\"comment\">#表示当前用户是超级用户，普通用户为$，例如：（&quot;yao@app00:/root$&quot; ，表示使用用户&quot;yao&quot;访问/root文件夹）</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"命令行快捷键\"><a class=\"markdownIt-Anchor\" href=\"#命令行快捷键\">#</a> 命令行快捷键</h3>\n<p>Linux 命令行中的快捷键主要用于提高在 Shell 中输入命令的效率。以下是一些常用的 Linux 命令行快捷键：</p>\n<ul>\n<li>Ctrl+A：移动光标到行首。</li>\n<li>Ctrl+E：移动光标到行尾。</li>\n<li>Ctrl+B 或 左箭头：向左移动一个字符。</li>\n<li>Ctrl+F 或 右箭头：向右移动一个字符。</li>\n<li>Ctrl+D：删除光标所在位置的字符。</li>\n<li>Ctrl+H 或 退格键：删除光标前的一个字符。</li>\n<li>Ctrl+T：交换光标前两个字符的位置。</li>\n<li>Ctrl+U：删除（剪切）光标前的所有字符。</li>\n<li>Ctrl+K：删除（剪切）光标及光标后的所有字符。</li>\n<li>Ctrl+W：删除（剪切）光标前的一个单词。</li>\n<li>Ctrl+Y：粘贴当前寄存器中的字符。</li>\n<li>Ctrl+L：清除屏幕，类似于 clear 命令。</li>\n<li>Ctrl+C：中断正在运行的命令。</li>\n<li>Ctrl+R：逆向搜索历史命令，即从最近的命令开始搜索。</li>\n<li>Ctrl+S：暂停终端（在某些终端中，这可能会导致屏幕锁定，使用 Ctrl+Q 解除）。</li>\n<li>Ctrl+Q：退出当前状态，如解除因 Ctrl+S 引起的屏幕锁定。</li>\n<li>Ctrl+D：如果没有输入任何命令就按此组合键，将会退出当前终端。</li>\n<li>Ctrl+Z：将当前正在运行的命令挂起，并返回到命令行提示符，可以使用 bg 或 fg 命令恢复任务。</li>\n<li>Ctrl+P 和 Ctrl+N：向上和向下翻阅命令历史。</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>使用 Ctrl+S 和 Ctrl+Q：这两个快捷键在某些终端模拟器中可能会导致屏幕锁定，如果遇到这种情况，可以使用 Ctrl+Q 来解除锁定。</li>\n<li>使用 Ctrl+D：如果没有输入任何命令就按 Ctrl+D，将会退出当前的 Shell 会话。如果不想退出，可以在按 Ctrl+D 之前输入一些字符，比如空格，然后再按<br>\n Ctrl+D。</li>\n</ul>\n<h3 id=\"文件和目录操作\"><a class=\"markdownIt-Anchor\" href=\"#文件和目录操作\">#</a> 文件和目录操作</h3>\n<h4 id=\"切换目录cd\"><a class=\"markdownIt-Anchor\" href=\"#切换目录cd\">#</a> 切换目录（cd）</h4>\n<p>cd（change directory）命令在 Linux 和 Unix-like 操作系统中用于更改当前工作目录。这是一个非常基础且常用的命令，用于导航文件系统中的不同目录。</p>\n<p>基本语法： <code>cd [目录路径]</code></p>\n<p>参数</p>\n<ul>\n<li>目录路径：指定要切换到的目录路径。如果省略，则默认切换到用户的主目录。</li>\n</ul>\n<p>选项</p>\n<p>cd 命令本身没有太多选项，但有一些特殊的路径符号和约定：</p>\n<ul>\n<li>~：表示用户的主目录。</li>\n<li>-：表示上次所在的目录。</li>\n<li>…：表示当前目录的父目录。</li>\n<li>.：表示当前目录。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>切换到用户的主目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br></pre></td></tr></table></figure>\n</li>\n<li>切换到指定目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /path/to/directory</span><br></pre></td></tr></table></figure>\n</li>\n<li>切换到当前目录的父目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ..</span><br></pre></td></tr></table></figure>\n</li>\n<li>切换到当前目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd .</span><br></pre></td></tr></table></figure>\n</li>\n<li>切换到上次所在的目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd -</span><br></pre></td></tr></table></figure>\n</li>\n<li>切换到多个目录层级：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ../../directory</span><br></pre></td></tr></table></figure>\n</li>\n<li>切换到相对路径：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd relative/path/to/directory</span><br></pre></td></tr></table></figure>\n</li>\n<li>切换到绝对路径：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /absolute/path/to/directory</span><br></pre></td></tr></table></figure>\n</li>\n<li>切换到特定用户的主目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~username</span><br></pre></td></tr></table></figure>\n</li>\n<li>切换到当前目录的上两级目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ../../../</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>路径解析：cd 命令会解析相对路径和绝对路径。相对路径是从当前目录开始计算的路径，而绝对路径是从根目录 / 开始的路径。</li>\n<li>主目录：使用～符号可以方便地切换到用户的主目录。如果后面跟一个用户名，如～username，则切换到指定用户的主目录。</li>\n<li>父目录：使用 … 符号可以方便地切换到当前目录的父目录。</li>\n<li>当前目录：使用。符号可以方便地切换到当前目录，尽管这样做通常没有实际意义。</li>\n<li>上次目录：使用 - 符号可以切换到上次所在的目录，这对于快速在多个目录之间切换非常有用。</li>\n<li>路径错误：如果指定的路径不存在或者没有权限访问，cd 命令将会失败，并显示相应的错误信息。</li>\n<li>环境变量：可以使用环境变量来构建路径。例如，cd $HOME/project 可以切换到 $HOME 目录下的 project 子目录。</li>\n<li>多级路径：可以使用多个 … 符号来切换到多级父目录，如 cd …/…/…/。</li>\n<li>相对路径：相对路径可以简化路径表达，尤其是在脚本中使用时。</li>\n<li>绝对路径：绝对路径从根目录 / 开始，可以明确指定任何目录路径。</li>\n</ul>\n<h4 id=\"查看当前目录pwd\"><a class=\"markdownIt-Anchor\" href=\"#查看当前目录pwd\">#</a> 查看当前目录（pwd）</h4>\n<p>pwd（print working directory）命令在 Linux 和 Unix-like 操作系统中用于显示当前工作目录的完整路径。<br>\n这是一个非常简单但常用的命令，对于确定当前所在目录的位置非常有帮助。</p>\n<p>基本语法： <code>pwd [选项]</code></p>\n<p>参数</p>\n<ul>\n<li>pwd 命令通常不需要额外的参数，但可以使用一些选项来定制输出。</li>\n</ul>\n<p>选项</p>\n<ul>\n<li>-P 或 --physical：显示物理路径，即不解析符号链接。</li>\n<li>-L 或 --logical：显示逻辑路径，即解析符号链接（默认行为）。</li>\n<li>-W 或 --win：使用 Windows 格式的路径（适用于 Cygwin 环境）。</li>\n<li>-h 或 --help：显示帮助信息。</li>\n<li>-V 或 --version：显示版本信息。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>显示当前工作目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwd</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示当前工作目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwd -P</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示当前工作目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwd -L</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示当前工作目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwd -W</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示当前工作目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwd -h</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示当前工作目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwd -V</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>默认行为：pwd 命令默认显示逻辑路径，即解析符号链接。</li>\n<li>物理路径：使用 -P 选项可以显示物理路径，即不解析符号链接。这对于处理包含符号链接的目录非常有用。</li>\n<li>Windows 格式：使用 -W 选项可以在 Cygwin 环境下显示 Windows 格式的路径。</li>\n<li>帮助信息：使用 -h 选项可以显示帮助信息，了解更多的选项和用法。</li>\n<li>版本信息：使用 -V 选项可以显示 pwd 命令的版本信息。</li>\n<li>路径解析：在包含符号链接的环境中，pwd 命令的行为可能会有所不同。使用 -P 或 -L 选项可以根据需要选择不同的路径解析方式。</li>\n<li>环境兼容性：在不同的 Linux 发行版和 Unix-like 系统中，pwd 命令的选项可能略有不同。建议查看具体的帮助文档或手册页。</li>\n</ul>\n<h4 id=\"列出目录内容ls\"><a class=\"markdownIt-Anchor\" href=\"#列出目录内容ls\">#</a> 列出目录内容（ls）</h4>\n<p>ls（list directory contents）命令在 Linux 和 Unix-like 操作系统中用于列出目录的内容，包括文件、目录和其他文件系统对象。<br>\n它是一个非常基础且常用的命令，几乎在任何 Linux 系统管理任务中都会用到。</p>\n<p>基本语法： <code>ls [选项] [文件或目录]</code></p>\n<p>参数</p>\n<ul>\n<li>文件或目录：指定要列出的文件或目录。如果省略，则默认列出当前目录的内容。</li>\n</ul>\n<p>常用选项</p>\n<ul>\n<li>-a：显示所有文件，包括隐藏文件（以。开头的文件）。</li>\n<li>-l：以长格式输出，显示文件的详细信息（权限、链接数、所有者、组、大小、修改时间）。</li>\n<li>-h：以人类可读的格式显示文件大小（KB、MB、GB 等）。</li>\n<li>-r：反向排序（默认为正序）。</li>\n<li>-R：递归列出子目录的内容。</li>\n<li>-t：按照文件的最后修改时间排序。</li>\n<li>-S：按照文件大小排序。</li>\n<li>-1：每行只显示一个文件名。</li>\n<li>-d：显示目录本身而不是其内容。</li>\n<li>-i：显示文件的索引节点（inode）号。</li>\n<li>-s：显示文件的块大小。</li>\n<li>-A：显示除当前目录（.）和父目录（…）之外的所有文件。</li>\n<li>-F：在文件名末尾添加指示符（如 / 表示目录，* 表示可执行文件）。</li>\n<li>-X：按扩展属性排序。</li>\n</ul>\n<p>其他选项</p>\n<ul>\n<li>–color：使用颜色高亮显示不同类型的文件。</li>\n<li>–time-style=STYLE：指定时间格式（如 long-iso 显示完整日期和时间）。</li>\n<li>–group-directories-first：首先列出目录，然后列出文件。</li>\n<li>–almost-all：同 -A，显示除当前目录（.）和父目录（…）之外的所有文件。</li>\n<li>–help：显示帮助信息。</li>\n<li>–version：显示版本信息。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>列出当前目录的内容：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls</span><br></pre></td></tr></table></figure>\n</li>\n<li>列出所有文件，包括隐藏文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -a</span><br></pre></td></tr></table></figure>\n</li>\n<li>以长格式列出文件详细信息：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l</span><br></pre></td></tr></table></figure>\n</li>\n<li>以长格式并以人类可读的格式显示文件大小：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -R</span><br></pre></td></tr></table></figure>\n</li>\n<li>递归列出子目录的内容：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -R</span><br></pre></td></tr></table></figure>\n</li>\n<li>按照文件的最后修改时间排序：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -lt</span><br></pre></td></tr></table></figure>\n</li>\n<li>按照文件大小排序：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -lS</span><br></pre></td></tr></table></figure>\n</li>\n<li>每行只显示一个文件名：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -1</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示目录本身而不是其内容：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -d /path/to/directory</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示文件的索引节点号：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -li</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示文件的块大小：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -ls</span><br></pre></td></tr></table></figure>\n</li>\n<li>在文件名末尾添加指示符：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -F</span><br></pre></td></tr></table></figure>\n</li>\n<li>使用颜色高亮显示不同类型的文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls --color</span><br></pre></td></tr></table></figure>\n</li>\n<li>指定时间格式：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls --time-style=long-iso</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>隐藏文件：使用 -a 选项可以显示隐藏文件（以。开头的文件）。在日常使用中，经常需要查看隐藏文件，特别是在配置文件和系统文件夹中。</li>\n<li>长格式输出：使用 -l 选项可以显示文件的详细信息，这对于了解文件的权限、所有者、大小等非常有用。</li>\n<li>递归列出子目录：使用 -R 选项可以递归列出子目录的内容，这对于查看复杂目录结构非常有帮助。</li>\n<li>排序方式：可以根据需要选择不同的排序方式，如按时间 (-t)、按大小 (-S) 等。</li>\n<li>颜色高亮：使用 --color 选项可以让不同类型的文件以不同的颜色显示，便于快速识别。</li>\n<li>文件大小：使用 -h 选项可以将文件大小转换为人类可读的格式，如 KB、MB、GB 等。</li>\n<li>目录本身：使用 -d 选项可以显示目录本身而不是其内容，这对于处理目录路径非常有用。</li>\n</ul>\n<h4 id=\"创建目录mkdir\"><a class=\"markdownIt-Anchor\" href=\"#创建目录mkdir\">#</a> 创建目录（mkdir）</h4>\n<p>mkdir（make directory）命令在 Linux 和 Unix-like 操作系统中用于创建新的目录。这是一个非常基础且常用的命令，用于组织文件系统中的文件和目录结构。</p>\n<p>基本语法： <code>mkdir [选项] 目录路径...</code></p>\n<p>参数</p>\n<ul>\n<li>目录路径：指定要创建的一个或多个目录路径。可以是相对路径或绝对路径。</li>\n</ul>\n<p>选项</p>\n<ul>\n<li>-p 或 --parents：即使中间目录不存在，也创建整个路径。<br>\n例如，mkdir -p /path/to/newdir 会创建 /path、/path/to 和 /path/to/newdir。</li>\n<li>-m 或 --mode = 模式：指定新目录的权限模式。例如，mkdir -m 755 newdir 将新目录的权限设置为 755。</li>\n<li>-v 或 --verbose：详细输出每个操作的结果。</li>\n<li>-Z 或 --context = 上下文：设置 SELinux 上下文。</li>\n<li>-h 或 --help：显示帮助信息。</li>\n<li>-V 或 --version：显示版本信息。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>创建单个目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir newdir</span><br></pre></td></tr></table></figure>\n</li>\n<li>创建多个目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir dir1 dir2 dir3</span><br></pre></td></tr></table></figure>\n</li>\n<li>创建带有父目录的目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /path/to/newdir</span><br></pre></td></tr></table></figure>\n</li>\n<li>创建带有特定权限的目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -m 755 newdir</span><br></pre></td></tr></table></figure>\n</li>\n<li>创建多个带有特定权限的目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -m 755 dir1 dir2</span><br></pre></td></tr></table></figure>\n</li>\n<li>详细输出创建结果：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -v newdir</span><br></pre></td></tr></table></figure>\n</li>\n<li>创建带有 SELinux 上下文的目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -Z unconfined_u:object_r:admin_home_t:s0 newdir</span><br></pre></td></tr></table></figure>\n</li>\n<li>创建多级目录结构：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /path/to/subdir1/subdir2</span><br></pre></td></tr></table></figure>\n</li>\n<li>创建多个多级目录结构：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /path/to/subdir1 /path/to/subdir2</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>目录存在性检查：如果指定的目录已经存在，mkdir 命令不会创建新的目录，并且会显示错误信息。使用 -p 选项可以避免这种错误。</li>\n<li>权限问题：如果当前用户没有足够的权限创建目录，mkdir 命令会失败并显示错误信息。</li>\n<li>相对路径和绝对路径：可以使用相对路径或绝对路径来创建目录。相对路径相对于当前工作目录，而绝对路径从根目录 / 开始。</li>\n<li>多级目录：使用 -p 选项可以创建多级目录结构，即使中间目录不存在也会自动创建。</li>\n<li>权限设置：使用 -m 选项可以设置新目录的权限模式。例如，755 表示所有用户都有读和执行权限，但只有所有者有写权限。</li>\n<li>详细输出：使用 -v 选项可以详细输出每个操作的结果，这对于调试和确认创建过程非常有用。</li>\n<li>SELinux 上下文：在使用 SELinux 的系统中，可以使用 -Z 选项设置新目录的 SELinux 上下文。</li>\n<li>帮助信息：使用 -h 选项可以显示帮助信息，了解更多的选项和用法。</li>\n<li>版本信息：使用 -V 选项可以显示 mkdir 命令的版本信息。</li>\n</ul>\n<h4 id=\"文件权限控制chmod\"><a class=\"markdownIt-Anchor\" href=\"#文件权限控制chmod\">#</a> 文件权限控制（chmod）</h4>\n<p>chmod 命令用于更改文件或目录的权限。它是 Linux 和 Unix 系统中一个非常重要的命令，用于控制用户对文件或目录的操作权限。</p>\n<p>基本语法： <code>chmod [选项] 模式 文件或目录</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-R, --recursive：递归地更改目录及其子目录下的所有文件和目录的权限。</li>\n<li>-c, --changes：仅报告更改的文件。</li>\n<li>-v, --verbose：详细报告更改的文件。</li>\n<li>–reference=FILE：将指定文件的权限应用到其他文件或目录。</li>\n</ul>\n<h5 id=\"权限模式\"><a class=\"markdownIt-Anchor\" href=\"#权限模式\">#</a> 权限模式</h5>\n<p>chmod 支持两种方式设置权限：符号模式和数字模式。</p>\n<h6 id=\"符号模式\"><a class=\"markdownIt-Anchor\" href=\"#符号模式\">#</a> 符号模式</h6>\n<ul>\n<li>u：用户（文件所有者）。</li>\n<li>g：组（文件所属组的成员）。</li>\n<li>o：其他人。</li>\n<li>a：所有用户（等同于 ugo）。</li>\n<li>+：添加权限。</li>\n<li>-：移除权限。</li>\n<li>=：设置权限。</li>\n<li>常见的权限有：</li>\n<li>r：读权限。</li>\n<li>w：写权限。</li>\n<li>x：执行权限。</li>\n</ul>\n<p>例如：</p>\n<ul>\n<li>chmod u+x filename：为文件所有者添加执行权限。</li>\n<li>chmod go-w filename：为组和其他人移除写权限。</li>\n<li>chmod a=rwx filename：为所有用户设置读、写、执行权限。</li>\n</ul>\n<h6 id=\"数字模式\"><a class=\"markdownIt-Anchor\" href=\"#数字模式\">#</a> 数字模式</h6>\n<ul>\n<li>4：读权限。</li>\n<li>2：写权限。</li>\n<li>1：执行权限。</li>\n</ul>\n<p>组合权限的数值计算方法：</p>\n<ul>\n<li>4 + 2 + 1：读、写、执行权限。</li>\n<li>4 + 0 + 1：读、无、执行权限。</li>\n<li>0 + 2 + 0：无、写、无权限。</li>\n</ul>\n<p>例如：</p>\n<ul>\n<li>chmod 755 filename：为文件所有者设置读、写、执行权限；为组和其他人设置读、执行权限。</li>\n<li>chmod 644 filename：为文件所有者设置读、写权限；为组和其他人设置读权限。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>为文件所有者添加执行权限：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod u+x filename</span><br></pre></td></tr></table></figure>\n</li>\n<li>为组和其他人移除写权限：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod go-w filename</span><br></pre></td></tr></table></figure>\n</li>\n<li>为所有用户设置读、写、执行权限：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod a=rwx filename</span><br></pre></td></tr></table></figure>\n</li>\n<li>设置文件权限为 755：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 755 filename</span><br></pre></td></tr></table></figure>\n</li>\n<li>递归设置目录及其子目录的权限：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod -R 755 directory</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>递归设置权限时要谨慎：使用 -R 选项递归设置权限时，确保你了解其影响范围，以免误操作导致安全问题。</li>\n<li>权限冲突检查：在设置权限时，确保权限不会导致冲突或安全隐患。例如，不要随意给所有用户执行权限。</li>\n<li>使用符号模式更直观：使用符号模式（如 u+x）通常比数字模式更直观，更容易理解权限的变化。</li>\n<li>备份权限配置：在批量修改权限之前，最好先备份原始权限配置，以便出现问题时能够恢复。</li>\n<li>避免过度放宽权限：尽量避免给不必要的用户或组过多的权限，以保证系统的安全性。</li>\n<li>查看当前权限：使用 ls -l 命令查看文件或目录的当前权限，以便更好地理解 chmod 的效果。</li>\n</ul>\n<h4 id=\"搜索目录find\"><a class=\"markdownIt-Anchor\" href=\"#搜索目录find\">#</a> 搜索目录（find）</h4>\n<p>find 命令在 Linux 和 Unix-like 操作系统中用于查找文件系统中的文件和目录。这是一个非常强大且灵活的命令，可以基于多种条件进行搜索。</p>\n<p>基本语法： <code>find [路径] [表达式]</code></p>\n<p>参数</p>\n<ul>\n<li>路径：指定查找的起始目录。</li>\n<li>表达式：指定查找的条件。</li>\n</ul>\n<p>表达式选项</p>\n<ul>\n<li>-name：按文件名匹配。</li>\n<li>-iname：按文件名匹配，不区分大小写。</li>\n<li>-type：按文件类型匹配（d: 目录，f: 文件，l: 符号链接）。</li>\n<li>-mtime：按修改时间匹配（天数）。</li>\n<li>-atime：按访问时间匹配（天数）。</li>\n<li>-ctime：按状态改变时间匹配（天数）。</li>\n<li>-size：按文件大小匹配（单位：b, k, M, G）。</li>\n<li>-user：按文件所有者用户名匹配。</li>\n<li>-group：按文件所属组名匹配。</li>\n<li>-perm：按文件权限匹配。</li>\n<li>-newer：按文件是否比给定文件新。</li>\n<li>-empty：查找空文件或空目录。</li>\n<li>-exec：对找到的文件执行命令。</li>\n<li>-print：打印找到的文件或目录路径。</li>\n<li>-print0：打印找到的文件或目录路径，并以 null 字符分隔。</li>\n<li>-ok：提示用户确认是否执行命令。</li>\n</ul>\n<p>连接符</p>\n<ul>\n<li>-and 或 &amp;&amp;：逻辑与。</li>\n<li>-or 或 ||：逻辑或。</li>\n<li>-not 或！：逻辑非。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>按文件名匹配：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /path/to/start -name &quot;file.txt&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li>按文件名匹配（不区分大小写）：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /path/to/start -iname &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li>按文件类型匹配：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /path/to/start -type d</span><br></pre></td></tr></table></figure>\n</li>\n<li>按修改时间匹配：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /path/to/start -mtime -7</span><br></pre></td></tr></table></figure>\n</li>\n<li>按访问时间匹配：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /path/to/start -atime +30</span><br></pre></td></tr></table></figure>\n</li>\n<li>按状态改变时间匹配：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /path/to/start -ctime 10</span><br></pre></td></tr></table></figure>\n</li>\n<li>按文件大小匹配：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /path/to/start -size +10M</span><br></pre></td></tr></table></figure>\n</li>\n<li>按文件所有者匹配：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /path/to/start -user alice</span><br></pre></td></tr></table></figure>\n</li>\n<li>按文件所属组匹配：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /path/to/start -group developers</span><br></pre></td></tr></table></figure>\n</li>\n<li>按文件权限匹配：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /path/to/start -perm 755</span><br></pre></td></tr></table></figure>\n</li>\n<li>按文件是否比给定文件新：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /path/to/start -newer file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>查找空文件或空目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /path/to/start -empty</span><br></pre></td></tr></table></figure>\n</li>\n<li>对找到的文件执行命令：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /path/to/start -name &quot;*.txt&quot; -exec chmod 644 &#123;&#125; \\;</span><br></pre></td></tr></table></figure>\n</li>\n<li>打印找到的文件或目录路径：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /path/to/start -name &quot;*.txt&quot; -print</span><br></pre></td></tr></table></figure>\n</li>\n<li>打印找到的文件或目录路径，并以 null 字符分隔：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /path/to/start -name &quot;*.txt&quot; -print0</span><br></pre></td></tr></table></figure>\n</li>\n<li>提示用户确认是否执行命令：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /path/to/start -name &quot;*.txt&quot; -ok rm &#123;&#125; \\;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"删除目录rmdir\"><a class=\"markdownIt-Anchor\" href=\"#删除目录rmdir\">#</a> 删除目录（rmdir）</h4>\n<p>rmdir 命令用于删除空目录。它是一种安全的方式来删除目录，因为它不会删除非空目录，从而避免意外删除重要文件。</p>\n<p>基本语法： <code>rmdir [选项] 目录...</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-p: 删除目录及其父目录，前提是它们都是空的。</li>\n<li>-v: 显示每个被删除的目录。</li>\n<li>–help: 显示帮助信息。</li>\n<li>–version: 显示版本信息。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>删除名为 directory_name 的空目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rmdir directory_name</span><br></pre></td></tr></table></figure>\n</li>\n<li>删除多个空目录 directory1、directory2 和 directory3：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rmdir directory1 directory2 directory3</span><br></pre></td></tr></table></figure>\n</li>\n<li>删除 subdirectory 及其父目录 directory，前提是它们都是空的：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rmdir -p directory/subdirectory</span><br></pre></td></tr></table></figure>\n</li>\n<li>删除 directory_name 并显示删除过程中的详细信息：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rmdir -v directory_name</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>目录必须为空：rmdir 只能删除空目录。如果目录中有文件或子目录，rmdir 将会失败。</li>\n<li>递归删除：使用 -p 选项时，只有当所有中间目录也是空的，才会递归删除。</li>\n<li>权限问题：删除目录需要相应的权限。如果当前用户没有足够的权限，可以使用 sudo 命令。</li>\n<li>确认提示：在删除目录之前，最好先确认目录确实是空的。可以使用 ls 命令查看目录内容。</li>\n<li>错误处理：如果删除失败，可以查看具体的错误信息以了解原因。</li>\n<li>备份：在删除重要目录之前，建议先备份相关文件或目录。</li>\n</ul>\n<h4 id=\"删除文件rm\"><a class=\"markdownIt-Anchor\" href=\"#删除文件rm\">#</a> 删除文件（rm）</h4>\n<p>rm（remove）命令在 Linux 和 Unix-like 操作系统中用于删除文件或目录。这是一个非常基础且常用的命令，用于清理文件系统中的文件和目录。</p>\n<p>基本语法： <code>rm [选项] 文件或目录...</code></p>\n<p>参数</p>\n<ul>\n<li>文件或目录：指定要删除的一个或多个文件或目录路径。可以是相对路径或绝对路径。</li>\n</ul>\n<p>选项</p>\n<ul>\n<li>-i 或 --interactive：在删除每个文件前提示用户确认。</li>\n<li>-f 或 --force：强制删除文件，忽略不存在的文件，不提示用户确认。</li>\n<li>-r 或 --recursive：递归删除目录及其内容。</li>\n<li>-R 或 --recursive：与 -r 相同，递归删除目录及其内容。</li>\n<li>-v 或 --verbose：详细输出每个操作的结果。</li>\n<li>-P 或 --preserve-root：禁止删除 / 目录。</li>\n<li>-W 或 --no-wildcards：禁用通配符扩展。</li>\n<li>-h 或 --help：显示帮助信息。</li>\n<li>-V 或 --version：显示版本信息。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>删除单个文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>删除多个文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm file1.txt file2.txt file3.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>删除目录及其内容：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -r dir1</span><br></pre></td></tr></table></figure>\n</li>\n<li>删除目录及其内容（使用 -R 选项）：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -R dir1</span><br></pre></td></tr></table></figure>\n</li>\n<li>交互式确认删除：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -i file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>强制删除文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -f file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>详细输出删除结果：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -v file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>递归删除多个目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -r dir1 dir2</span><br></pre></td></tr></table></figure>\n</li>\n<li>删除多个文件和目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf file1.txt file2.txt dir1</span><br></pre></td></tr></table></figure>\n</li>\n<li>禁用通配符扩展：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -W file*.txt</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>交互式确认：使用 -i 选项会在删除每个文件前提示用户确认，这有助于防止误删重要文件。</li>\n<li>强制删除：使用 -f 选项可以强制删除文件，忽略不存在的文件，不提示用户确认。这在批量删除文件时非常有用，但也容易导致误删。</li>\n<li>递归删除目录：使用 -r 或 -R 选项可以递归删除目录及其内容。这在删除整个目录树时非常有用，但也容易导致误删。</li>\n<li>详细输出：使用 -v 选项可以详细输出每个操作的结果，这对于调试和确认删除过程非常有用。</li>\n<li>路径问题：确保提供的路径是正确的，否则 rm 命令可能会删除错误的文件或目录。</li>\n<li>权限问题：如果当前用户没有足够的权限删除文件或目录，rm 命令会失败并显示错误信息。</li>\n<li>通配符扩展：默认情况下，rm 命令会扩展通配符（如 file*.txt）。使用 -W 选项可以禁用通配符扩展。</li>\n<li>保护根目录：使用 -P 选项可以禁止删除 / 目录。</li>\n<li>帮助信息：使用 -h 选项可以显示帮助信息，了解更多的选项和用法。</li>\n<li>版本信息：使用 -V 选项可以显示 rm 命令的版本信息。</li>\n</ul>\n<h4 id=\"拷贝目录cp\"><a class=\"markdownIt-Anchor\" href=\"#拷贝目录cp\">#</a> 拷贝目录（cp）</h4>\n<p>cp（copy）命令在 Linux 和 Unix-like 操作系统中用于复制文件或目录。这是一个非常基础且常用的命令，用于备份文件、创建副本或复制整个目录结构。</p>\n<p>基本语法： <code>cp [选项] 源路径 目标路径</code></p>\n<p>参数</p>\n<ul>\n<li>源路径：要复制的文件或目录路径。</li>\n<li>目标路径：复制后的目标位置或新名称。</li>\n</ul>\n<p>选项</p>\n<ul>\n<li>-i 或 --interactive：在覆盖现有文件之前提示用户确认。</li>\n<li>-f 或 --force：强制覆盖现有文件，不提示用户确认。</li>\n<li>-r 或 --recursive：递归复制目录及其内容。</li>\n<li>-p 或 --preserve = 属性：保留源文件的属性（如权限、时间戳等）。</li>\n<li>-v 或 --verbose：详细输出每个操作的结果。</li>\n<li>-l 或 --link：创建硬链接而不是复制文件。</li>\n<li>-s 或 --symbolic-link：创建符号链接而不是复制文件。</li>\n<li>-u 或 --update：仅当源文件比目标文件更新时才复制。</li>\n<li>-a 或 --archive：等价于 -dpR，用于递归复制并保留所有属性。</li>\n<li>-H 或 --dereference-argument-directories：将目标目录视为普通文件。</li>\n<li>-L 或 --dereference：递归复制符号链接的目标。</li>\n<li>-S 或 --suffix=SUFFIX：指定备份文件的后缀。</li>\n<li>-n 或 --no-clobber：禁止覆盖现有文件。</li>\n<li>-h 或 --help：显示帮助信息。</li>\n<li>-V 或 --version：显示版本信息。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>复制单个文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp file.txt newfile.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>复制多个文件到同一目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp file1.txt file2.txt /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n<li>复制目录及其内容：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -r dir1 /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n<li>复制目录及其内容（使用 -R 选项）：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -R dir1 /path/to/newdir/   </span><br></pre></td></tr></table></figure>\n</li>\n<li>交互式确认覆盖：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -i file.txt /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n<li>强制覆盖现有文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -f file.txt /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n<li>保留源文件属性：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -p file.txt newfile.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>详细输出复制结果：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -v file.txt /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n<li>创建硬链接：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -l file.txt linkfile.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>创建符号链接：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -s file.txt symlink.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>仅当源文件更新时复制：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -u file.txt /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n<li>递归复制并保留所有属性：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -a dir1 /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n<li>递归复制符号链接的目标：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -L dir1 /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n<li>指定备份文件的后缀：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -S .bak file.txt /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n<li>禁止覆盖现有文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -n file.txt /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>交互式确认：使用 -i 选项会在覆盖现有文件前提示用户确认，这有助于防止误覆盖重要文件。</li>\n<li>强制覆盖：使用 -f 选项可以强制覆盖现有文件，不提示用户确认。这在批量复制文件时非常有用，但也容易导致误覆盖。</li>\n<li>递归复制目录：使用 -r 或 -R 选项可以递归复制目录及其内容。这在复制整个目录树时非常有用，但也容易导致误覆盖。</li>\n<li>保留源文件属性：使用 -p 选项可以保留源文件的所有属性（如权限、时间戳等）。</li>\n<li>详细输出：使用 -v 选项可以详细输出每个操作的结果，这对于调试和确认复制过程非常有用。</li>\n<li>硬链接：使用 -l 选项可以创建硬链接而不是复制文件。</li>\n<li>符号链接：使用 -s 选项可以创建符号链接而不是复制文件。</li>\n<li>仅当源文件更新时复制：使用 -u 选项可以仅当源文件比目标文件更新时才复制。</li>\n<li>递归复制并保留所有属性：使用 -a 选项可以递归复制并保留所有属性，相当于 -dpR。</li>\n<li>路径问题：确保提供的路径是正确的，否则 cp 命令可能会复制错误的文件或目录。</li>\n<li>权限问题：如果当前用户没有足够的权限复制文件或目录，cp 命令会失败并显示错误信息。</li>\n<li>备份文件：使用 -S 选项可以指定备份文件的后缀。</li>\n<li>禁止覆盖现有文件：使用 -n 选项可以禁止覆盖现有文件。</li>\n<li>帮助信息：使用 -h 选项可以显示帮助信息，了解更多的选项和用法。</li>\n<li>版本信息：使用 -V 选项可以显示 cp 命令的版本信息。</li>\n</ul>\n<h4 id=\"移动目录mv\"><a class=\"markdownIt-Anchor\" href=\"#移动目录mv\">#</a> 移动目录（mv）</h4>\n<p>mv（move or rename files）命令在 Linux 和 Unix-like 操作系统中用于移动或重命名文件和目录。这是一个非常基础且常用的命令，用于文件系统的管理和组织。</p>\n<p>基本语法： <code>mv [选项] 源路径 目标路径</code></p>\n<p>参数</p>\n<ul>\n<li>源路径：要移动或重命名的文件或目录路径。</li>\n<li>目标路径：移动后的新位置或重命名后的新名称。</li>\n</ul>\n<p>选项</p>\n<ul>\n<li>-i 或 --interactive：在覆盖现有文件之前提示用户确认。</li>\n<li>-f 或 --force：强制覆盖现有文件，不提示用户确认。</li>\n<li>-u 或 --update：仅当源文件比目标文件更新时才移动。</li>\n<li>-v 或 --verbose：详细输出每个操作的结果。</li>\n<li>-t 或 --target-directory=DIR：指定目标目录。</li>\n<li>-T 或 --no-target-directory：即使目标看起来像目录，也不将其视为目录。</li>\n<li>-b 或 --backup=CONTROL：在覆盖现有文件时创建备份。</li>\n<li>-n 或 --no-clobber：禁止覆盖现有文件。</li>\n<li>-h 或 --help：显示帮助信息。</li>\n<li>-V 或 --version：显示版本信息。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>重命名文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv oldfile newfile</span><br></pre></td></tr></table></figure>\n</li>\n<li>移动文件到另一个目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv file.txt /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n<li>重命名目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv olddir newdir</span><br></pre></td></tr></table></figure>\n</li>\n<li>移动目录到另一个目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv dir1 /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n<li>交互式确认覆盖：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv -i file.txt /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n<li>强制覆盖现有文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv -f file.txt /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n<li>仅当源文件更新时移动：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv -u file.txt /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n<li>详细输出每个操作的结果：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv -v file.txt /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n<li>指定目标目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv -t /path/to/newdir/ file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>不将目标视为目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv -T file.txt newdir</span><br></pre></td></tr></table></figure>\n</li>\n<li>创建备份文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv -b file.txt /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n<li>禁止覆盖现有文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv -n file.txt /path/to/newdir/</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>重命名文件：使用 mv 命令可以轻松地重命名文件或目录。例如，mv oldfile newfile 将 oldfile 重命名为 newfile。</li>\n<li>移动文件或目录：使用 mv 命令可以将文件或目录移动到另一个位置。<br>\n例如，mv file.txt/path/to/newdir/ 将 file.txt 移动到 /path/to/newdir/。</li>\n<li>覆盖现有文件：默认情况下，如果目标文件已存在，mv 命令会提示用户确认是否覆盖。<br>\n使用 -i 选项可以启用交互式确认，使用 -f 选项可以强制覆盖。</li>\n<li>仅当源文件更新时移动：使用 -u 选项可以仅当源文件比目标文件更新时才移动。</li>\n<li>详细输出：使用 -v 选项可以详细输出每个操作的结果，这对于调试和确认移动过程非常有用。</li>\n<li>指定目标目录：使用 -t 选项可以指定目标目录，例如 mv -t /path/to/newdir/file.txt。</li>\n<li>不将目标视为目录：使用 -T 选项可以防止将目标视为目录，即使目标看起来像目录。</li>\n<li>创建备份文件：使用 -b 选项可以在覆盖现有文件时创建备份文件。</li>\n<li>禁止覆盖现有文件：使用 -n 选项可以禁止覆盖现有文件。</li>\n<li>路径问题：确保提供的路径是正确的，否则 mv 命令可能会失败或产生意外的结果。</li>\n<li>权限问题：如果当前用户没有足够的权限移动文件或目录，mv 命令会失败并显示错误信息。</li>\n</ul>\n<h4 id=\"创建文件touch\"><a class=\"markdownIt-Anchor\" href=\"#创建文件touch\">#</a> 创建文件（touch）</h4>\n<p>touch 命令在 Linux 和 Unix-like 操作系统中用于创建一个文件，如果文件已经存在，则更新其访问时间。</p>\n<p>基本语法： <code>touch [选项] 文件名...</code></p>\n<p>参数</p>\n<ul>\n<li>文件名…：可以是一个或多个文件名，也可以是包含文件名的目录。</li>\n</ul>\n<p>选项</p>\n<ul>\n<li>-a：只改变文件的访问时间（access time）而不改变修改时间（modification time）。</li>\n<li>-m：只改变文件的修改时间而不改变访问时间。</li>\n<li>-c 或 --no-create：如果文件不存在，则不创建新文件。</li>\n<li>-d DATE 或 --date=DATE：使用指定的日期而非当前日期作为时间戳。</li>\n<li>-r FILE 或 --reference=FILE：将指定文件的时间戳复制到目标文件。</li>\n<li>-t TIMESTAMP 或 --time=TIMESTAMP：直接设置时间戳，而不是使用当前时间。时间戳格式为 YYYYMMDDhhmm [.ss]。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>创建一个名为 example.txt 的新文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch example.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>更新 example.txt 的访问时间和修改时间：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch example.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>更新 example.txt 的访问时间，而不更新修改时间：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch -a example.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>使用特定日期更新 example.txt 的时间戳<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch -d &quot;2024-01-01 00:00:00&quot; example.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>将 reference.txt 的时间戳复制给 example.txt：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch -r reference.txt example.txt</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>当使用 touch 命令创建新文件时，请确保你有足够的权限在指定目录中创建文件。</li>\n<li>如果你想更新多个文件的时间戳，可以一次传递多个文件名给 touch 命令。</li>\n<li>使用 -t 选项时，确保你提供的 TIMESTAMP 格式正确，否则命令将失败。</li>\n<li>在脚本中使用 touch 时，考虑文件可能已经存在的场景，并决定是否需要 -c 选项来避免不必要的文件创建。</li>\n</ul>\n<h4 id=\"创建硬链接或符号链接ln\"><a class=\"markdownIt-Anchor\" href=\"#创建硬链接或符号链接ln\">#</a> 创建硬链接或符号链接（ln）</h4>\n<p>ln 命令在 Linux 系统中用于创建文件的硬链接或符号链接（软链接）。这对于文件系统管理非常有用，特别是当需要指向同一个文件的不同名称或路径时。</p>\n<p>基本语法： <code>ln [选项] 源文件 目标文件</code></p>\n<p>参数和选项</p>\n<ul>\n<li>-s 或 --symbolic：创建符号链接而不是默认的硬链接。</li>\n<li>-f 或 --force：如果目标文件已经存在，则删除后重新创建链接。</li>\n<li>-v 或 --verbose：显示操作过程的信息。</li>\n<li>-i 或 --interactive：交互模式下询问用户是否覆盖已存在的目标文件。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>创建一个名为 link_file.txt 的硬链接，指向 file.txt 的相同数据块。<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln file.txt link_file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>创建一个符号链接 link_file.txt，指向 file.txt 的位置。<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s file.txt link_file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>强制创建符号链接：如果 link_file.txt 已经存在，将会被删除并重新创建为指向 file.txt 的符号链接。<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -sf file.txt link_file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>在创建链接前会询问用户是否继续。<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -is file.txt link_file.txt</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>硬链接 只能用于文件，不能用于目录。如果你尝试对目录创建硬链接，会收到错误提示。</li>\n<li>符号链接 可以用于文件和目录，并且可以跨文件系统创建，而硬链接不可以。</li>\n<li>当删除原文件时，硬链接依然有效，因为它们指向相同的文件数据块。但是，如果所有指向该数据块的链接都被删除了，那么该数据块会被回收。</li>\n<li>符号链接在原文件被删除后会变成无效链接，除非通过绝对路径创建符号链接。</li>\n<li>使用 -f 选项时要小心，因为它会无提示地删除已存在的目标文件。</li>\n</ul>\n<h4 id=\"文件打包解包tar\"><a class=\"markdownIt-Anchor\" href=\"#文件打包解包tar\">#</a> 文件打包解包（tar）</h4>\n<p>tar (Tape Archive) 是一个广泛使用的文件打包和解包工具。它可以将多个文件和目录打包成一个单一的归档文件，并支持多种压缩格式。</p>\n<p>命令格式： <code>tar [选项] [文件] [文件] ...</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-c: 创建新的归档文件。</li>\n<li>-x: 解包现有的归档文件。</li>\n<li>-t: 列出归档文件的内容。</li>\n<li>-r: 将文件添加到现有的归档文件。</li>\n<li>-u: 更新归档文件中的文件。</li>\n<li>-a: 自动选择压缩方式。</li>\n<li>-z: 使用 gzip 压缩。</li>\n<li>-j: 使用 bzip2 压缩。</li>\n<li>-J: 使用 xz 压缩。</li>\n<li>-v: 显示详细信息。</li>\n<li>-f: 指定归档文件名。</li>\n<li>-p: 保留文件权限。</li>\n<li>-P: 使用绝对路径。</li>\n<li>-m: 保留符号链接。</li>\n<li>-g: 使用全局索引文件。</li>\n<li>-T: 从文件中读取文件名列表。</li>\n<li>-C: 指定目录作为工作目录。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>创建归档文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -czvf archive.tar.gz /path/to/directory</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-c: 创建新的归档文件。</li>\n<li>-z: 使用 gzip 压缩。</li>\n<li>-v: 显示详细信息。</li>\n<li>-f: 指定归档文件名为 archive.tar.gz。</li>\n</ul>\n</li>\n<li>解包归档文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xzvf archive.tar.gz -C /destination/path</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-x: 解包归档文件。</li>\n<li>-z: 使用 gzip 压缩。</li>\n<li>-v: 显示详细信息。</li>\n<li>-f: 指定归档文件名为 archive.tar.gz。</li>\n<li>-C: 指定解包的目标目录为 /destination/path。</li>\n</ul>\n</li>\n<li>列出归档文件内容：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -tvf archive.tar.gz</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-t: 列出归档文件的内容。</li>\n<li>-v: 显示详细信息。</li>\n<li>-f: 指定归档文件名为 archive.tar.gz。</li>\n</ul>\n</li>\n<li>将文件添加到现有归档文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -rvf archive.tar /path/to/newfile</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-r: 将文件添加到现有的归档文件。</li>\n<li>-v: 显示详细信息。</li>\n<li>-f: 指定归档文件名为 archive.tar。</li>\n</ul>\n</li>\n<li>更新归档文件中的文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -uvf archive.tar /path/to/newfile</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-u: 更新归档文件中的文件。</li>\n<li>-v: 显示详细信息。</li>\n<li>-f: 指定归档文件名为 archive.tar。</li>\n</ul>\n</li>\n<li>使用 bzip2 压缩：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -cjvf archive.tar.bz2 /path/to/directory</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-c: 创建新的归档文件。</li>\n<li>-j: 使用 bzip2 压缩。</li>\n<li>-v: 显示详细信息。</li>\n<li>-f: 指定归档文件名为 archive.tar.bz2。</li>\n</ul>\n</li>\n<li>使用 xz 压缩：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -cJvf archive.tar.xz /path/to/directory</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-c: 创建新的归档文件。</li>\n<li>-J: 使用 xz 压缩。</li>\n<li>-v: 显示详细信息。</li>\n<li>-f: 指定归档文件名为 archive.tar.xz。</li>\n</ul>\n</li>\n<li>保留文件权限：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -cvpf archive.tar /path/to/directory</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-c: 创建新的归档文件。</li>\n<li>-v: 显示详细信息。</li>\n<li>-p: 保留文件权限。</li>\n<li>-f: 指定归档文件名为 archive.tar。</li>\n</ul>\n</li>\n<li>使用绝对路径：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -cvPf archive.tar /path/to/directory</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-c: 创建新的归档文件。</li>\n<li>-v: 显示详细信息。</li>\n<li>-P: 使用绝对路径。</li>\n<li>-f: 指定归档文件名为 archive.tar。</li>\n</ul>\n</li>\n<li>从文件中读取文件名列表：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -cvf archive.tar -T list.txt</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-c: 创建新的归档文件。</li>\n<li>-v: 显示详细信息。</li>\n<li>-f: 指定归档文件名为 archive.tar。</li>\n<li>-T: 从 list.txt 文件中读取文件名列表。</li>\n</ul>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>压缩格式：tar 支持多种压缩格式，如 gzip (-z)、bzip2 (-j) 和 xz (-J)。选择合适的压缩格式可以根据具体需求优化存储空间和压缩速度。</li>\n<li>文件权限：使用 -p 选项可以保留文件权限，避免解包后的文件权限不一致。</li>\n<li>绝对路径：使用 -P 选项可以保留绝对路径，避免解包时路径混乱。</li>\n<li>符号链接：使用 -m 选项可以保留符号链接，避免解包时丢失符号链接信息。</li>\n<li>文件名列表：从文件中读取文件名列表时，确保文件名列表文件中的路径正确。</li>\n<li>备份策略：在创建备份文件时，建议定期备份，并确保备份文件的安全性和完整性。</li>\n<li>解包路径：解包文件时，使用 -C 选项指定目标目录，避免解包到当前目录造成混乱。</li>\n<li>资源管理：长时间运行 tar 命令时，注意监控系统资源使用情况，避免占用过多带宽和磁盘空间。</li>\n</ul>\n<h4 id=\"解压缩文件unzip\"><a class=\"markdownIt-Anchor\" href=\"#解压缩文件unzip\">#</a> 解压缩文件（unzip）</h4>\n<p>unzip 是一个用于解压缩 ZIP 格式文件的命令行工具。它可以处理各种 ZIP 文件，并支持多种压缩算法。unzip 常用于解压从互联网下载的各种软件包和其他文件。</p>\n<p>基本格式： <code>unzip [选项] [压缩文件]</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-l: 列出 ZIP 文件中的内容。</li>\n<li>-t: 测试 ZIP 文件中的内容是否完整。</li>\n<li>-v: 显示详细信息。</li>\n<li>-d: 指定解压的目标目录。</li>\n<li>-n: 不覆盖已存在的文件。</li>\n<li>-o: 强制覆盖已存在的文件。</li>\n<li>-p: 输出指定文件到标准输出。</li>\n<li>-j: 解压时不保留路径信息。</li>\n<li>-q: 安静模式，不显示任何信息。</li>\n<li>-x: 排除指定的文件或目录。</li>\n<li>-a: 将文本文件转换为当前系统的编码。</li>\n<li>-u: 更新 ZIP 文件中的文件。</li>\n<li>-m: 将提取的文件移动到当前目录。</li>\n<li>-Z: 显示帮助信息。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>解压 ZIP 文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip archive.zip</span><br></pre></td></tr></table></figure>\n<ul>\n<li>默认情况下，unzip 会将文件解压到当前目录。</li>\n</ul>\n</li>\n<li>解压 ZIP 文件到指定目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip archive.zip -d /destination/path</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-d: 指定解压的目标目录为 /destination/path。</li>\n</ul>\n</li>\n<li>列出 ZIP 文件内容：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip -l archive.zip</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-l: 列出 ZIP 文件中的内容。</li>\n</ul>\n</li>\n<li>测试 ZIP 文件内容是否完整：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip -t archive.zip</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-t: 测试 ZIP 文件中的内容是否完整。</li>\n</ul>\n</li>\n<li>提取指定文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip archive.zip file1.txt file2.txt</span><br></pre></td></tr></table></figure>\n<ul>\n<li>提取 archive.zip 中的 file1.txt 和 file2.txt 文件。</li>\n</ul>\n</li>\n<li>不覆盖已存在的文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip -n archive.zip</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-n: 不覆盖已存在的文件。</li>\n</ul>\n</li>\n<li>强制覆盖已存在的文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip -o archive.zip</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-o: 强制覆盖已存在的文件。</li>\n</ul>\n</li>\n<li>输出指定文件到标准输出：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip -p archive.zip file1.txt</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-p: 输出 file1.txt 到标准输出。</li>\n</ul>\n</li>\n<li>解压时不保留路径信息：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip -j archive.zip</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-j: 解压时不保留路径信息。</li>\n</ul>\n</li>\n<li>安静模式：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip -q archive.zip</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-q: 安静模式，不显示任何信息。</li>\n</ul>\n</li>\n<li>排除指定的文件或目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip -x &quot;file*.txt&quot; archive.zip</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-x: 排除 file*.txt 文件。</li>\n</ul>\n</li>\n<li>将文本文件转换为当前系统的编码：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip -a archive.zip</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-a: 将文本文件转换为当前系统的编码。</li>\n</ul>\n</li>\n<li>更新 ZIP 文件中的文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip -u archive.zip</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-u: 更新 ZIP 文件中的文件。</li>\n</ul>\n</li>\n<li>将提取的文件移动到当前目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip -m archive.zip</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-m: 将提取的文件移动到当前目录。</li>\n</ul>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>文件路径：解压时，默认会保留 ZIP 文件中的路径信息。如果不需要路径信息，可以使用 -j 选项。</li>\n<li>文件覆盖：默认情况下，unzip 会覆盖已存在的文件。如果不希望覆盖文件，可以使用 -n 选项；如果希望强制覆盖，可以使用 -o 选项。</li>\n<li>文件编码：如果 ZIP 文件中的文本文件编码与当前系统不一致，可以使用 -a 选项将其转换为当前系统的编码。</li>\n<li>文件测试：使用 -t 选项可以测试 ZIP 文件中的内容是否完整，这对于检测损坏的文件非常有用。</li>\n<li>文件排除：使用 -x 选项可以排除指定的文件或目录，避免解压不必要的文件。</li>\n<li>解压目标目录：使用 -d 选项可以指定解压的目标目录，避免解压到当前目录导致混乱。</li>\n<li>资源管理：长时间运行 unzip 命令时，注意监控系统资源使用情况，避免占用过多带宽和磁盘空间。</li>\n<li>错误处理：如果遇到解压失败或其他错误，可以查看详细信息或使用 -v 选项获取更多信息。</li>\n</ul>\n<h4 id=\"下载文件wget\"><a class=\"markdownIt-Anchor\" href=\"#下载文件wget\">#</a> 下载文件（wget）</h4>\n<p>wget (Web GET) 是一个强大的命令行工具，用于从网络上下载文件。它支持多种协议（如 HTTP、HTTPS 和 FTP），并且具有断点续传、镜像站点等功能。</p>\n<p>基本语法： <code>wget [选项] [URL]</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-O: 将下载的文件保存为指定的名字。</li>\n<li>-c: 继续下载未完成的部分。</li>\n<li>-r: 递归下载（递归模式）。</li>\n<li>-p: 下载页面指向的所有文件（包括图片、CSS 等）。</li>\n<li>-k: 将远程链接转换为本地链接。</li>\n<li>-N: 只下载比本地文件更新的文件。</li>\n<li>-t: 设置重试次数。</li>\n<li>-T: 设置超时时间（单位为秒）。</li>\n<li>-P: 将下载的文件保存到指定目录。</li>\n<li>–mirror: 创建一个完整的镜像站点。</li>\n<li>–wait: 在下载文件之间等待指定的时间（单位为秒）。</li>\n<li>–random-wait: 在下载文件之间随机等待一段时间。</li>\n<li>–spider: 测试链接是否可达而不实际下载文件。</li>\n<li>–user-agent: 设置用户代理字符串。</li>\n<li>–proxy: 设置代理服务器。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>下载单个文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://example.com/file.zip</span><br></pre></td></tr></table></figure>\n</li>\n<li>将下载的文件保存为指定的名字：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -O my_file.zip https://example.com/file.zip</span><br></pre></td></tr></table></figure>\n</li>\n<li>继续下载未完成的部分：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -c https://example.com/large_file.zip</span><br></pre></td></tr></table></figure>\n</li>\n<li>递归下载整个网站：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -r -p -k -N http://example.com</span><br></pre></td></tr></table></figure>\n</li>\n<li>递归下载并保存到指定目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -r -P /path/to/download http://example.com</span><br></pre></td></tr></table></figure>\n</li>\n<li>设置重试次数和超时时间：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -t 3 -T 60 http://example.com</span><br></pre></td></tr></table></figure>\n</li>\n<li>创建一个完整的镜像站点：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --mirror http://example.com</span><br></pre></td></tr></table></figure>\n</li>\n<li>在下载文件之间等待指定的时间：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --wait=5 http://example.com</span><br></pre></td></tr></table></figure>\n</li>\n<li>在下载文件之间随机等待一段时间：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --random-wait http://example.com</span><br></pre></td></tr></table></figure>\n</li>\n<li>测试链接是否可达而不实际下载文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --spider http://example.com</span><br></pre></td></tr></table></figure>\n</li>\n<li>设置用户代理字符串：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --user-agent=&quot;Mozilla/5.0&quot; http://example.com</span><br></pre></td></tr></table></figure>\n</li>\n<li>设置代理服务器：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --proxy=http://proxy.example.com:8080 http://example.com</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>权限问题：下载较大的文件或需要特殊权限的文件时，建议使用 sudo 或以 root 用户身份运行 wget。</li>\n<li>网络稳定性：在下载过程中，如果网络不稳定，可以使用 -c 选项进行断点续传。</li>\n<li>递归下载：使用递归下载时，注意限制递归深度，避免下载不必要的文件。例如，可以使用 -l 选项设置最大递归深度。</li>\n<li>镜像站点：创建镜像站点时，确保有足够的磁盘空间，并遵守目标网站的版权和使用条款。</li>\n<li>代理设置：如果需要通过代理服务器下载文件，确保正确设置了代理地址和端口。</li>\n<li>安全问题：下载文件时，尽量从可信的源下载，并检查文件的完整性（如 MD5 或 SHA256 校验）。</li>\n<li>资源消耗：长时间运行大量下载任务时，注意监控系统资源使用情况，避免占用过多带宽和磁盘空间。</li>\n</ul>\n<h3 id=\"文件内容操作\"><a class=\"markdownIt-Anchor\" href=\"#文件内容操作\">#</a> 文件内容操作</h3>\n<h4 id=\"显示文件内容cat\"><a class=\"markdownIt-Anchor\" href=\"#显示文件内容cat\">#</a> 显示文件内容（cat）</h4>\n<p>cat 命令用于将多个文件内容合并到一个文件中，并显示在屏幕上。</p>\n<p>基本语法： <code>cat [选项] [文件名]</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-A, --show-all：显示所有字符，包括不可见字符如制表符、换行符等。</li>\n<li>-b, --number-nonblank：为非空输出行编号。</li>\n<li>-n, --number：为所有输出行编号。</li>\n<li>-s, --squeeze-blank：当遇到有多个相邻空行时，cat 在输出时只表示为一个空行。</li>\n<li>-E, --show-ends：在每行结束处显示 $ 符号。</li>\n<li>-T, --show-tabs：将 Tab 字符显示为 ^I。</li>\n<li>-v, --show-nonprinting：使用 ^ 和 M- 符号显示非打印 ASCII 字符。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>查看文件内容：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat filename.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>合并两个文件到一个新的文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat file1.txt file2.txt &gt; newfile.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>向文件追加内容：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;附加的文本&quot; &gt;&gt; filename.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示文件中的特殊字符：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat -A filename.txt</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>使用 cat 处理大文件时需谨慎，因为它会一次性加载整个文件到内存中。</li>\n<li>当直接从终端输入数据给 cat 命令时，使用 Ctrl+D 表示输入结束。</li>\n<li>在脚本中使用 cat 输出内容时，注意避免不必要的性能开销，特别是在循环中频繁读取文件时。</li>\n</ul>\n<h4 id=\"分页显示文件内容less\"><a class=\"markdownIt-Anchor\" href=\"#分页显示文件内容less\">#</a> 分页显示文件内容（less）</h4>\n<p>less 命令与 more 类似，也是分页显示文件内容，但与 more 不同的是，less 支持搜索功能，可以快速定位到指定内容。</p>\n<p>基本语法： <code>less [选项] [文件名]</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-S：节省屏幕空间，删除多余的空行。</li>\n<li>-X：不使用临时文件。</li>\n<li>-R：显示颜色和格式控制字符。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>查看文件内容：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">less filename.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>查看管道输出的内容：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls | less</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>less 支持前后翻页和搜索功能，更加灵活。</li>\n<li>less 在查看文件时，可以通过键盘操作进行导航：\n<ul>\n<li>q：退出 less。</li>\n<li>b：向上滚动一页。</li>\n<li>f：向下滚动一页。</li>\n<li>/：搜索字符串。</li>\n<li>n：跳到下一个匹配项。</li>\n<li>N：跳到上一个匹配项。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"分页显示文件内容more\"><a class=\"markdownIt-Anchor\" href=\"#分页显示文件内容more\">#</a> 分页显示文件内容（more）</h4>\n<p>more 命令用于分页显示文件内容，在屏幕上显示一页内容，用户可以上下移动，按空格键或回车键继续显示下一页。</p>\n<p>基本语法： <code>more [选项] [文件名]</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-d：显示帮助信息。</li>\n<li>-f：忽略换行符，强制将文件作为一个整体显示。</li>\n<li>-s：将连续的空白行压缩为一行。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>查看文件内容：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">more filename.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>查看管道输出的内容：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls | more</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>more 只能向前翻页，不能向后翻页。</li>\n<li>more 不支持搜索功能。</li>\n</ul>\n<h4 id=\"显示文件的前几行head\"><a class=\"markdownIt-Anchor\" href=\"#显示文件的前几行head\">#</a> 显示文件的前几行（head）</h4>\n<p>head 命令在 Linux 系统中用于显示文本文件的开头部分内容。它通常用于查看大文件的前几行，而无需加载整个文件到内存中。</p>\n<p>基本语法： <code>head [选项] 文件名</code></p>\n<p>参数和选项</p>\n<ul>\n<li>-n 或 --lines：指定显示的行数，默认为 10 行。</li>\n<li>-q 或 --quiet：不打印文件名。</li>\n<li>-v 或 --version：显示版本信息。</li>\n<li>-h 或 --help：显示帮助信息。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>显示文件的前 10 行<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示文件的前 5 行<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head -n 5 file.txt</span><br></pre></td></tr></table></figure>\n或者<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head --lines=5 file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示多个文件的前 10 行，并在每个文件前加上文件名<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head file1.txt file2.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示多个文件的前 5 行，不打印文件名<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head -n 5 -q file1.txt file2.txt</span><br></pre></td></tr></table></figure>\n或者<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head --lines=5 --quiet file1.txt file2.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>先通过 cat 命令读取 file.txt 的全部内容，然后通过 head 命令显示前 10 行<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat file.txt | head -n 10</span><br></pre></td></tr></table></figure>\n</li>\n<li>将 file.txt 的前 10 行输出到 output.txt 文件中<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head file.txt &gt; output.txt</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>默认显示行数：如果不指定 -n 选项，默认显示 10 行。</li>\n<li>文件名显示：当处理多个文件时，默认会显示每个文件的名称。如果不需要显示文件名，可以使用 -q 选项。</li>\n<li>空文件处理：如果文件为空，head 将不会输出任何内容。</li>\n<li>管道结合使用：head 常常与 cat、grep、sort 等命令结合使用，处理文本文件的前几行数据。</li>\n<li>性能考虑：对于非常大的文件，使用 head 可以避免加载整个文件到内存中，提高效率。</li>\n</ul>\n<h4 id=\"显示文件后几行tail\"><a class=\"markdownIt-Anchor\" href=\"#显示文件后几行tail\">#</a> 显示文件后几行（tail）</h4>\n<p>tail 命令在 Linux 系统中用于显示文本文件的末尾部分内容。它通常用于查看大文件的最后几行，而无需加载整个文件到内存中。</p>\n<p>基本语法： <code>tail [选项] 文件名</code></p>\n<p>参数和选项</p>\n<ul>\n<li>-n 或 --lines：指定显示的行数，默认为 10 行。</li>\n<li>-f 或 --follow：实时跟踪文件的变化。</li>\n<li>-q 或 --quiet：不打印文件名。</li>\n<li>-v 或 --version：显示版本信息。</li>\n<li>-h 或 --help：显示帮助信息。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>显示文件的最后 10 行<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示文件的最后 5 行<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail -n 5 file.txt</span><br></pre></td></tr></table></figure>\n或者<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail --lines=5 file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示多个文件的最后 10 行，并在每个文件前加上文件名。<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail file1.txt file2.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示多个文件的最后 5 行，不打印文件名<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail -n 5 -q file1.txt file2.txt</span><br></pre></td></tr></table></figure>\n或者<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail --lines=5 --quiet file1.txt file2.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>实时显示 file.txt 的新内容，直到手动中断（通常使用 Ctrl+C）<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail -f file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>先通过 cat 命令读取 file.txt 的全部内容，然后通过 tail 命令显示最后 10 行<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat file.txt | tail -n 10</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示文件的最后 10 行，并输出到另一个文件<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail file.txt &gt; output.txt</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>默认显示行数：如果不指定 -n 选项，默认显示 10 行。</li>\n<li>文件名显示：当处理多个文件时，默认会显示每个文件的名称。如果不需要显示文件名，可以使用 -q 选项。</li>\n<li>空文件处理：如果文件为空，tail 将不会输出任何内容。</li>\n<li>实时监控：使用 -f 选项可以实时监控文件的变化，非常适合监控日志文件。</li>\n<li>性能考虑：对于非常大的文件，使用 tail 可以避免加载整个文件到内存中，提高效率。</li>\n<li>中断实时监控：实时监控文件时，可以通过按下 Ctrl+C 来中断监控。</li>\n</ul>\n<h4 id=\"文件搜索grep\"><a class=\"markdownIt-Anchor\" href=\"#文件搜索grep\">#</a> 文件搜索（grep）</h4>\n<p>grep 是一个强大的文本搜索工具，用于在文件中查找特定的字符串或模式。它支持正则表达式的匹配，可以在单个文件或多个文件中进行搜索。</p>\n<p>基本语法： <code>grep [选项] 模式 [文件名]</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-i, --ignore-case：忽略大小写差异。</li>\n<li>-v, --invert-match：显示不匹配模式的行。</li>\n<li>-n, --line-number：显示匹配行的行号。</li>\n<li>-l, --files-with-matches：只列出包含匹配行的文件名。</li>\n<li>-L, --files-without-matches：只列出不包含匹配行的文件名。</li>\n<li>-r, --recursive：递归地搜索目录及其子目录。</li>\n<li>-H, --with-filename：在输出中显示文件名。</li>\n<li>-A NUM, --after-context=NUM：显示匹配行之后的 NUM 行。</li>\n<li>-B NUM, --before-context=NUM：显示匹配行之前的 NUM 行。</li>\n<li>-C NUM, --context=NUM：显示匹配行周围的 NUM 行。</li>\n<li>-e PATTERN, --regexp=PATTERN：指定一个或多个模式。</li>\n<li>-E, --extended-regexp：使用扩展正则表达式。</li>\n<li>-F, --fixed-strings：将模式视为固定字符串，而不是正则表达式。</li>\n<li>-m NUM, --max-count=NUM：最多显示 NUM 个匹配行。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>在文件中搜索特定字符串：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep &quot;example&quot; filename.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>忽略大小写搜索：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -i &quot;example&quot; filename.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示匹配行的行号：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -n &quot;example&quot; filename.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示不匹配模式的行：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -v &quot;example&quot; filename.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>只列出包含匹配行的文件名：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -l &quot;example&quot; filename1.txt filename2.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>递归搜索目录及其子目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -r &quot;example&quot; /path/to/directory</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示匹配行周围的上下文：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -C 5 &quot;example&quot; filename.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>使用扩展正则表达式：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -E &quot;example|test&quot; filename.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>将模式视为固定字符串：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -F &quot;example&quot; filename.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>搜索多个模式：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -e &quot;example&quot; -e &quot;test&quot; filename.txt</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>正则表达式的正确使用：确保正则表达式的正确性和效率，避免复杂的正则表达式导致性能问题。</li>\n<li>递归搜索时要谨慎：使用 -r 选项递归搜索目录时，确保范围适当，避免搜索不必要的文件或目录。</li>\n<li>忽略大小写的使用：如果不需要区分大小写，可以使用 -i 选项，使搜索更加宽松。</li>\n<li>上下文显示：使用 -A, -B, -C 选项可以显示匹配行周围的上下文，有助于理解匹配内容的上下文关系。</li>\n<li>性能考虑：对于大量数据的搜索，考虑使用 egrep 或 fgrep 命令，它们在某些场景下可能更快。</li>\n</ul>\n<h4 id=\"文本流编辑器sed\"><a class=\"markdownIt-Anchor\" href=\"#文本流编辑器sed\">#</a> 文本流编辑器（sed）</h4>\n<p>sed（Stream Editor）命令在 Linux 系统中用于文本文件的过滤和转换。它可以用来执行各种文本编辑任务，如替换字符串、插入行、删除行等。</p>\n<p>基本语法： <code>sed [选项] '命令' 文件名</code></p>\n<p>参数和选项</p>\n<ul>\n<li>-e 或 --expression：添加一个编辑命令。</li>\n<li>-f 或 --file：从文件中读取编辑命令。</li>\n<li>-i 或 --in-place：直接修改文件内容。</li>\n<li>-n 或 --quiet：只打印显式指定的行。</li>\n<li>-r 或 --regexp：使用扩展正则表达式。</li>\n<li>-u 或 --unbuffered：逐行读取和输出。</li>\n<li>-v 或 --version：显示版本信息。</li>\n<li>-h 或 --help：显示帮助信息。</li>\n</ul>\n<p>命令</p>\n<ul>\n<li>\n<p>替换（s）：用于替换文本中的字符串。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s/pattern/replacement/flags</span><br></pre></td></tr></table></figure>\n<ul>\n<li>pattern：要匹配的模式。</li>\n<li>replacement：替换后的字符串。</li>\n<li>flags：可选标志，如 g（全局替换）、p（打印替换后的行）等。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed &#x27;s/pattern/replacement/g&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>插入行（i）：在当前行之前插入一行或多行文本。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address i\\</span><br><span class=\"line\">text</span><br></pre></td></tr></table></figure>\n<ul>\n<li>address：指定在哪一行插入。</li>\n<li>text：要插入的文本。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed &#x27;1i\\</span><br><span class=\"line\">New line here&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>追加（a）：在当前行之后插入一行或多行文本。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address a\\</span><br><span class=\"line\">text</span><br></pre></td></tr></table></figure>\n<ul>\n<li>address：指定在哪一行追加。</li>\n<li>text：要追加的文本。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed &#x27;2a\\</span><br><span class=\"line\">Another new line&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>删除（d）：删除指定的行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address d</span><br></pre></td></tr></table></figure>\n<ul>\n<li>address：指定要删除的行。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed &#x27;2d&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>打印（p）：打印指定的行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address p</span><br></pre></td></tr></table></figure>\n<ul>\n<li>address：指定要打印的行。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed &#x27;2p&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>行号（=）：打印行号。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address =</span><br></pre></td></tr></table></figure>\n<ul>\n<li>address：指定打印行号的位置。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed &#x27;=; 2=&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>标签（:）：定义一个标签。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:label</span><br></pre></td></tr></table></figure>\n<ul>\n<li>label：定义的标签名称。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed &#x27;:loop</span><br><span class=\"line\">n</span><br><span class=\"line\">/pattern/b loop</span><br><span class=\"line\">p&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>分支（b）：跳转到指定的标签。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b label</span><br></pre></td></tr></table></figure>\n<ul>\n<li>label：跳转的目标标签。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed &#x27;:loop</span><br><span class=\"line\">n</span><br><span class=\"line\">/pattern/b loop</span><br><span class=\"line\">p&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>保持空间（h）：将当前行复制到保持空间。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed &#x27;1h&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>获取空间（g）：将保持空间的内容复制到模式空间。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed &#x27;2g&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>读取外部文件（r）：从外部文件读取一行并追加到当前行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r filename</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed &#x27;2r otherfile.txt&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>写入外部文件（w）：将当前行写入到外部文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">w filename</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed &#x27;2w output.txt&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>条件命令（t）：如果上一个替换命令成功，则跳转到指定的标签。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t label</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed &#x27;s/pattern/replacement/</span><br><span class=\"line\">t success&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>地址范围（address1,address2）：指定命令作用的行范围。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address1,address2 command</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed &#x27;2,5 s/pattern/replacement/&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>正则表达式范围（/regex1/,/regex2/）：指定命令作用的行范围。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/regex1/,/regex2/ command</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed &#x27;/start/,/end/ s/pattern/replacement/&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>命令格式：sed 命令的基本格式为 sed ‘命令’ 文件名。命令通常包括地址、命令和动作三部分。</li>\n<li>正则表达式：sed 支持基本正则表达式（BRE）和扩展正则表达式（ERE）。使用 -r 选项可以启用扩展正则表达式。</li>\n<li>直接修改文件：使用 -i 选项可以直接修改文件内容。为了避免意外覆盖，建议使用备份选项，例如 -i.bak。</li>\n<li>多条命令：可以使用 -e 选项多次添加命令，或者将多条命令写入一个文件并通过 -f 选项读取。</li>\n<li>输出控制：使用 -n 选项可以只打印显式指定的行。</li>\n<li>性能考虑：对于非常大的文件，sed 可以高效地处理文本，因为它逐行读取和处理文件。</li>\n</ul>\n<h4 id=\"文本处理工具awk\"><a class=\"markdownIt-Anchor\" href=\"#文本处理工具awk\">#</a> 文本处理工具（awk）</h4>\n<p>awk 是一种强大的文本处理工具，在 Linux 系统中广泛用于解析和处理文本文件。它可以用来提取、筛选、修改和生成文本数据。</p>\n<p>基本语法： <code>awk [选项] &#123;命令&#125; 文件名</code></p>\n<p>参数和选项</p>\n<ul>\n<li>-F 或 --field-separator：设置字段分隔符。</li>\n<li>-v 或 --assign：定义变量及其值。</li>\n<li>-f 或 --file：从文件中读取 awk 脚本。</li>\n<li>-i 或 --inplace：直接修改文件内容。</li>\n<li>-W 或 --version：显示版本信息。</li>\n<li>-h 或 --help：显示帮助信息。</li>\n</ul>\n<p>命令</p>\n<ul>\n<li>\n<p>打印（print）：打印指定的字段或字符串。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print expression</span><br></pre></td></tr></table></figure>\n<ul>\n<li>expression：可以是字段 $1, $2, … 或任何表达式。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;&#123;print $1&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>条件判断（if）：根据条件执行不同的命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (condition) &#123; commands &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>condition：条件表达式。</li>\n<li>commands：符合条件时执行的命令。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;$1 == &quot;value&quot; &#123;print $2&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>赋值（=）：对变量进行赋值。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">variable = value</span><br></pre></td></tr></table></figure>\n<ul>\n<li>variable：变量名。</li>\n<li>value：赋值的值。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;&#123;sum = $1 + $2; print sum&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>数组（array）：使用数组存储和处理数据。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array[index] = value</span><br></pre></td></tr></table></figure>\n<ul>\n<li>array：数组名。</li>\n<li>index：数组索引。</li>\n<li>value：赋值的值。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;&#123;a[$1]++; print a[$1]&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>循环（for）：循环遍历数组或其他数据结构。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (init; condition; increment) &#123; commands &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>init：初始化语句。</li>\n<li>condition：循环条件。</li>\n<li>increment：增量语句。</li>\n<li>commands：循环体内的命令。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;&#123;for (i=1; i&lt;=NF; i++) print $i&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>循环遍历数组（for）：遍历数组中的所有元素。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (key in array) &#123; commands &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>key：数组的键。</li>\n<li>array：数组名。</li>\n<li>commands：循环体内的命令。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;&#123;a[$1]++; print a[$1]&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数（function）：定义自定义函数。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function name(args) &#123; commands &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>name：函数名。</li>\n<li>args：参数列表。</li>\n<li>commands：函数体内的命令。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sum(a, b) &#123; return a + b &#125;</span><br><span class=\"line\">awk &#x27;&#123;print sum($1, $2)&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>条件分支（if-else）：根据条件执行不同的命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (condition) &#123; commands1 &#125; else &#123; commands2 &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>condition：条件表达式。</li>\n<li>commands1：符合条件时执行的命令。</li>\n<li>commands2：不符合条件时执行的命令。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;$1 &gt; 10 &#123;print $1&#125; else &#123;print $2&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>条件分支（if-elif-else）：多个条件分支。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (condition1) &#123; commands1 &#125; </span><br><span class=\"line\">else if (condition2) &#123; commands2 &#125; </span><br><span class=\"line\">else &#123; commands3 &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>condition1, condition2, …：条件表达式。</li>\n<li>commands1, commands2, …：符合条件时执行的命令。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;$1 &gt; 10 &#123;print $1&#125; else if ($1 &lt; 5) &#123;print $2&#125; else &#123;print $3&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>退出循环（next）：退出当前循环。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;$1 == &quot;exit&quot; &#123;next&#125; &#123;print $1&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>结束处理（END）：在处理完所有输入后执行命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">END &#123; commands &#125;</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;&#123;sum += $1&#125; END &#123;print sum&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>开始处理（BEGIN）：在处理任何输入之前执行命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BEGIN &#123; commands &#125;</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;BEGIN &#123;print &quot;Starting...&quot;&#125; &#123;print $1&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>条件分支（? :）：三元条件运算符。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">condition ? expr1 : expr2</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;$1 &gt; 10 ? print $1 : print $2&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>自定义分隔符（FS）：设置字段分隔符。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FS = &quot;separator&quot;</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk -F: &#x27;&#123;print $1&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>记录计数（NR）：记录当前处理的行数。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NR</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;NR % 2 == 0 &#123;print $1&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>字段计数（NF）：记录当前行的字段数。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NF</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;NF &gt; 2 &#123;print $1&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>记录本身（$0）：记录当前行的内容。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$</span><span class=\"language-bash\">0</span></span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;&#123;print $0&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>字符串操作（length, substr, index, tolower, toupper）：字符串长度、子串、索引、转换大小写等。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">length(string)</span><br><span class=\"line\">substr(string, start, length)</span><br><span class=\"line\">index(string, substring)</span><br><span class=\"line\">tolower(string)</span><br><span class=\"line\">toupper(string)</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;&#123;print length($1), tolower($2)&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>数学函数（sin, cos, exp, log, sqrt, int）：数学函数。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sin(x)</span><br><span class=\"line\">cos(x)</span><br><span class=\"line\">exp(x)</span><br><span class=\"line\">log(x)</span><br><span class=\"line\">sqrt(x)</span><br><span class=\"line\">int(x)</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;&#123;print sqrt($1)&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>数组操作（(split, asprintf）：分割字符串为数组。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">split(string, array, separator)</span><br><span class=\"line\">asprintf(format, ...)</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &#x27;&#123;split($1, a, &quot;:&quot;); print a[1]&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>模式和命令：awk 命令的基本格式为 awk ‘模式 {命令}’ 文件名。模式用于匹配行，命令用于处理匹配的行。</li>\n<li>变量和函数：awk 支持内置变量（如 NR、NF）和用户定义的变量。还可以使用内置函数（如 sum、print）进行计算和输出。</li>\n<li>分隔符：使用 -F 选项可以设置自定义的字段分隔符，这在处理 CSV 或其他格式的文件时非常有用。</li>\n<li>多条件匹配：可以使用逻辑运算符（如 &amp;&amp;、||）进行多条件匹配。</li>\n<li>数组和循环：awk 支持数组和循环结构，可以进行复杂的数据处理。</li>\n<li>脚本文件：可以将多个 awk 命令写入一个文件，并通过 -f 选项读取。</li>\n<li>性能考虑：对于非常大的文件，awk 可以高效地处理文本，因为它逐行读取和处理文件。</li>\n</ul>\n<h4 id=\"文件编辑vivim\"><a class=\"markdownIt-Anchor\" href=\"#文件编辑vivim\">#</a> 文件编辑（vi，vim）</h4>\n<p>vi 和 vim（Vi IMproved）是 Linux 中广泛使用的文本编辑器。它们功能强大且灵活，适用于从简单的文本编辑到复杂的脚本编写等多种场景。</p>\n<p>基本语法： <code>vi [选项] 文件名</code> 和 <code>vim [选项] 文件名</code></p>\n<p>参数</p>\n<ul>\n<li>文件名：要编辑的文件名。如果没有指定文件名，vi 或 vim 将打开一个空白文件。</li>\n</ul>\n<p>选项</p>\n<ul>\n<li>-c command：执行完 command 后退出。</li>\n<li>-e：编辑最后一个被编辑的文件。</li>\n<li>-n：以行号模式启动。</li>\n<li>-R：只读模式。</li>\n<li>+ command：执行完 command 后继续编辑。</li>\n<li>+ line：从指定行开始编辑。</li>\n<li>-V n：在 n 行的垂直分割窗口中打开文件。</li>\n<li>-S session：使用会话文件恢复编辑环境。</li>\n</ul>\n<p>工作模式</p>\n<p>vi 和 vim 有三种主要工作模式：</p>\n<ul>\n<li>命令模式（Command Mode）：默认模式，用于输入编辑命令。</li>\n<li>插入模式（Insert Mode）：用于输入文本。</li>\n<li>末行模式（Ex Mode）：用于执行命令行命令。</li>\n</ul>\n<p>常用命令</p>\n<ul>\n<li>命令模式：\n<ul>\n<li>i：进入插入模式，在光标当前位置插入文本。</li>\n<li>a：进入插入模式，在光标当前位置之后插入文本。</li>\n<li>o：在当前行下一行新开一行并进入插入模式。</li>\n<li>x：删除光标所在字符。</li>\n<li>dd：删除当前行。</li>\n<li>yy：复制当前行。</li>\n<li>p：粘贴已复制或剪切的内容。</li>\n<li>u：撤销上一步操作。</li>\n<li>Ctrl + r：重做上一步操作。</li>\n<li>:：进入末行模式。</li>\n</ul>\n</li>\n<li>插入模式：\n<ul>\n<li>Esc：返回命令模式。</li>\n</ul>\n</li>\n<li>末行模式：\n<ul>\n<li>:w：保存文件。</li>\n<li>:q：退出编辑器。</li>\n<li>:q!：强制退出，不保存修改。</li>\n<li>:wq：保存并退出。</li>\n<li>:set nu：显示行号。</li>\n<li>:set nonu：取消显示行号。</li>\n<li>:help：查看帮助文档。</li>\n<li>:set number：显示行号。</li>\n<li>:set nocursorline：取消高亮显示当前行。</li>\n<li>:set cursorline：高亮显示当前行。</li>\n</ul>\n</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>打开一个名为 example.txt 的文件进行编辑：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi example.txt</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"进程和系统管理\"><a class=\"markdownIt-Anchor\" href=\"#进程和系统管理\">#</a> 进程和系统管理</h3>\n<h4 id=\"显示进程信息ps补充\"><a class=\"markdownIt-Anchor\" href=\"#显示进程信息ps补充\">#</a> 显示进程信息（ps）补充</h4>\n<h4 id=\"查看系统资源top\"><a class=\"markdownIt-Anchor\" href=\"#查看系统资源top\">#</a> 查看系统资源（top)</h4>\n<p>top 命令是一个实时监控系统资源状态的工具，主要用于查看和管理正在运行的进程。它可以显示系统的 CPU 使用率、内存使用情况、进程列表等信息，并且可以动态更新这些信息。</p>\n<p>基本语法： <code>top [选项]</code></p>\n<p>参数与选项</p>\n<ul>\n<li></li>\n<li>-d：指定更新间隔时间（秒）。</li>\n<li>-p：指定监控特定 PID 的进程。</li>\n<li>-q：高优先级模式，减少系统调度开销。</li>\n<li>-c：显示完整的命令行。</li>\n<li>-S：累积模式，显示每个进程自启动以来的 CPU 使用情况。</li>\n<li>-s：安全模式，禁用信号发送功能。</li>\n<li>-n：指定运行次数，之后退出。</li>\n<li>-b：批处理模式，输出到标准输出或重定向到文件。</li>\n<li>-h：显示帮助信息。</li>\n<li>-V：显示版本信息。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>默认运行 top 命令：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top</span><br></pre></td></tr></table></figure>\n</li>\n<li>指定更新间隔时间为 2 秒：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top -d 2</span><br></pre></td></tr></table></figure>\n</li>\n<li>监控特定 PID 的进程：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top -p 1234</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示完整的命令行：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top -c</span><br></pre></td></tr></table></figure>\n</li>\n<li>累积模式显示每个进程的 CPU 使用情况：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top -S</span><br></pre></td></tr></table></figure>\n</li>\n<li>安全模式禁用信号发送功能：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top -s</span><br></pre></td></tr></table></figure>\n</li>\n<li>指定运行次数后退出：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top -n 5</span><br></pre></td></tr></table></figure>\n</li>\n<li>批处理模式输出到文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示帮助信息：：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top -h</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示版本信息：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top -V</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>交互式操作<br>\n一旦进入 top 命令界面，可以通过以下按键进行各种操作：</p>\n<ul>\n<li>h：显示帮助信息。</li>\n<li>k：发送信号终止进程。</li>\n<li>r：重新安排进程的优先级。</li>\n<li>P：按 CPU 使用率排序。</li>\n<li>M：按内存使用率排序。</li>\n<li>S：按累积 CPU 使用率排序。</li>\n<li>f：定制显示列。</li>\n<li>q：退出 top 命令。</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>更新间隔时间：使用 -d 选项可以设置更新间隔时间，通常建议不要设置得太短，以免增加系统负担。</li>\n<li>监控特定进程：使用 -p 选项可以监控特定 PID 的进程，适用于监控关键进程的状态。</li>\n<li>批处理模式：使用 -b 选项可以将 top 的输出重定向到文件，适用于自动化监控和日志记录。</li>\n<li>安全模式：使用 -s 选项可以禁用信号发送功能，适用于安全环境下的监控。</li>\n<li>累积模式：使用 -S 选项可以显示每个进程自启动以来的 CPU 使用情况，适用于长时间运行的监控任务。</li>\n<li>显示完整的命令行：使用 -c 选项可以显示完整的命令行，便于识别进程的具体信息。</li>\n<li>系统负载：top 命令本身也会占用一定的系统资源，因此在高负载环境下应谨慎使用。</li>\n<li>信号发送：使用 k 键可以发送信号终止进程，但应谨慎操作，以免误杀关键进程。</li>\n</ul>\n<h4 id=\"发送信号给进程kill补充\"><a class=\"markdownIt-Anchor\" href=\"#发送信号给进程kill补充\">#</a> 发送信号给进程（kill）补充</h4>\n<h4 id=\"发送信号给多个进程killall补充\"><a class=\"markdownIt-Anchor\" href=\"#发送信号给多个进程killall补充\">#</a> 发送信号给多个进程（killall）补充</h4>\n<h4 id=\"设置进程优先级nice补充\"><a class=\"markdownIt-Anchor\" href=\"#设置进程优先级nice补充\">#</a> 设置进程优先级（nice）补充</h4>\n<h4 id=\"编辑进程优先级renice补充\"><a class=\"markdownIt-Anchor\" href=\"#编辑进程优先级renice补充\">#</a> 编辑进程优先级（renice）补充</h4>\n<h4 id=\"在后台运行命令nohup补充\"><a class=\"markdownIt-Anchor\" href=\"#在后台运行命令nohup补充\">#</a> 在后台运行命令（nohup）补充</h4>\n<h4 id=\"将作业放到后台运行bg补充\"><a class=\"markdownIt-Anchor\" href=\"#将作业放到后台运行bg补充\">#</a> 将作业放到后台运行（bg）补充</h4>\n<h4 id=\"将后台作业放到前台运行fg补充\"><a class=\"markdownIt-Anchor\" href=\"#将后台作业放到前台运行fg补充\">#</a> 将后台作业放到前台运行（fg）补充</h4>\n<h3 id=\"网络和通信\"><a class=\"markdownIt-Anchor\" href=\"#网络和通信\">#</a> 网络和通信</h3>\n<h4 id=\"测试网络连通性ping补充\"><a class=\"markdownIt-Anchor\" href=\"#测试网络连通性ping补充\">#</a> 测试网络连通性（ping）补充</h4>\n<h4 id=\"显示数据包到达目标主机的路径traceroute补充\"><a class=\"markdownIt-Anchor\" href=\"#显示数据包到达目标主机的路径traceroute补充\">#</a> 显示数据包到达目标主机的路径（traceroute）补充</h4>\n<h4 id=\"显示网络连接信息netstat补充\"><a class=\"markdownIt-Anchor\" href=\"#显示网络连接信息netstat补充\">#</a> 显示网络连接信息（netstat）补充</h4>\n<h4 id=\"显示网络接口信息ifconfig补充\"><a class=\"markdownIt-Anchor\" href=\"#显示网络接口信息ifconfig补充\">#</a> 显示网络接口信息（ifconfig）补充</h4>\n<h4 id=\"远程连接ssh\"><a class=\"markdownIt-Anchor\" href=\"#远程连接ssh\">#</a> 远程连接（ssh）</h4>\n<p>ssh（Secure Shell）是一个用于远程登录和管理系统的命令行工具。它通过加密连接来保证通信的安全性，广泛应用于远程服务器管理和文件传输。</p>\n<p>基本格式： <code>ssh [选项] [用户名@]主机名 [命令]</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-l: 指定远程主机上的用户名。</li>\n<li>-p: 指定 SSH 服务的端口号。</li>\n<li>-i: 指定私钥文件。</li>\n<li>-X: 允许 X11 转发。</li>\n<li>-Y: 允许可信的 X11 转发。</li>\n<li>-D: 设置 SOCKS 代理。</li>\n<li>-N: 不执行远程命令。</li>\n<li>-T: 不分配伪终端。</li>\n<li>-A: 允许代理转发。</li>\n<li>-a: 禁止代理转发。</li>\n<li>-C: 启用压缩。</li>\n<li>-c: 指定加密算法。</li>\n<li>-v: 显示详细信息。</li>\n<li>-q: 禁用所有消息。</li>\n<li>-n: 不分配标准输入。</li>\n<li>-f: 在后台运行。</li>\n<li>-R: 远程端口转发。</li>\n<li>-L: 本地端口转发。</li>\n<li>-g: 允许远程主机连接。</li>\n<li>-o: 指定 SSH 配置选项。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>登录到 hostname 主机上的 user 用户：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>在 hostname 主机上的 user 用户执行 ls -l 命令：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh user@hostname &quot;ls -l&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li>使用端口号 2222 登录到 hostname 主机上的 user 用户：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -p 2222 user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>使用私钥文件～/.ssh/id_rsa 登录到 hostname 主机上的 user 用户：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -i ~/.ssh/id_rsa user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>允许 X11 转发，可以在远程主机上运行图形界面应用：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -X user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>设置本地端口 1080 作为 SOCKS 代理：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -D 1080 user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>不执行任何远程命令，只建立 SSH 连接：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -N user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>不分配伪终端，通常用于自动化脚本：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -T user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>允许代理转发：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -A user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>禁止代理转发：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -a user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>启用压缩，提高传输速度：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -C user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>指定加密算法为 aes256-cbc：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -c aes256-cbc user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示详细信息，便于调试：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -v user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>禁用所有消息，减少输出：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -q user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>不分配标准输入，通常用于后台任务：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -n user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>在后台运行 SSH 连接：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -f user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>将远程主机的 8080 端口转发到本地主机的 80 端口：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -R 8080:localhost:80 user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>将本地主机的 8080 端口转发到远程主机的 80 端口：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -L 8080:localhost:80 user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>允许远程主机连接到转发的端口：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -g user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li>指定 SSH 配置选项 StrictHostKeyChecking=no：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -o StrictHostKeyChecking=no user@hostname</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>端口号：确保指定了正确的端口号。默认端口号为 22，如果使用其他端口，请使用 -p 选项。</li>\n<li>私钥文件：使用私钥文件进行身份验证时，确保私钥文件的路径正确并且具有适当的权限。</li>\n<li>X11 转发：使用 -X 或 -Y 选项时，确保远程主机上安装了 X11 服务器，并且防火墙允许 X11 连接。</li>\n<li>端口转发：使用 -L 或 -R 选项时，确保防火墙规则允许转发的端口。</li>\n<li>代理转发：使用 -A 或 -a 选项时，确保代理转发符合安全策略。</li>\n<li>压缩：使用 -C 选项可以提高传输速度，但对于带宽受限的环境可能会增加 CPU 负载。</li>\n<li>详细信息：使用 -v 选项可以显示详细信息，便于调试和故障排除。</li>\n<li>安全配置：使用 -o 选项可以指定 SSH 配置选项，确保安全设置符合要求。</li>\n<li>权限问题：确保有足够的权限执行 ssh 命令。通常需要 root 权限或使用 sudo 命令。</li>\n<li>日志记录：确保 SSH 服务器的日志记录功能开启，以便跟踪和审计 SSH 连接。</li>\n</ul>\n<h4 id=\"安全文件传输scp\"><a class=\"markdownIt-Anchor\" href=\"#安全文件传输scp\">#</a> 安全文件传输（scp）</h4>\n<p>scp (Secure Copy) 是一个用于在计算机之间安全传输文件的命令行工具。它利用 SSH（Secure Shell）协议来加密传输过程，确保文件的安全性和完整性。</p>\n<p>基本语法： <code>scp [选项] 本地文件 远程主机:远程目录</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-r: 递归复制目录。</li>\n<li>-p: 保留文件权限、时间戳等属性。</li>\n<li>-P: 指定 SSH 的端口号。</li>\n<li>-C: 启用压缩（默认启用）。</li>\n<li>-q: 禁用进度条。</li>\n<li>-v: 显示详细信息。</li>\n<li>-i: 指定私钥文件。</li>\n<li>-B: 使用后台模式传输大文件。</li>\n<li>-3: 允许多主机之间的传输。</li>\n</ul>\n<p>scp 的命令格式可以分为几种常见的情况：</p>\n<ul>\n<li>从本地到远程：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp [options] local_file user@remote_host:/remote/path</span><br></pre></td></tr></table></figure>\n</li>\n<li>从远程到本地：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp [options] user@remote_host:/remote/path local_file</span><br></pre></td></tr></table></figure>\n</li>\n<li>从远程到远程：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp [options] user1@remote_host1:/remote/path user2@remote_host2:/remote/path</span><br></pre></td></tr></table></figure>\n</li>\n<li>从本地到本地（通过 SSH 转发）：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp [options] -3 local_file user@remote_host:/remote/path local_file</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>从本地到远程传输文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r local_file user@remote_host:/remote/path</span><br></pre></td></tr></table></figure>\n</li>\n<li>从远程到本地传输文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r user@remote_host:/remote/path local_file</span><br></pre></td></tr></table></figure>\n</li>\n<li>从本地到远程传输目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r local_directory user@remote_host:/remote/path</span><br></pre></td></tr></table></figure>\n</li>\n<li>从远程到本地传输目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r user@remote_host:/remote/path local_directory</span><br></pre></td></tr></table></figure>\n</li>\n<li>从远程到远程传输文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r user1@remote_host1:/remote/path user2@remote_host2:/remote/pa</span><br></pre></td></tr></table></figure>\n</li>\n<li>从本地到本地传输文件（通过 SSH 转发）：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -3 -r local_file user@remote_host:/remote/path local_file</span><br></pre></td></tr></table></figure>\n</li>\n<li>保留文件权限和时间戳：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -rp local_file user@remote_host:/remote/path</span><br></pre></td></tr></table></figure>\n</li>\n<li>指定 SSH 端口号：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r -P 2222 local_file user@remote_host:/remote/path</span><br></pre></td></tr></table></figure>\n</li>\n<li>启用压缩：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r -C local_file user@remote_host:/remote/path</span><br></pre></td></tr></table></figure>\n</li>\n<li>禁用进度条：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r -q local_file user@remote_host:/remote/path</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示详细信息：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r -v local_file user@remote_host:/remote/path</span><br></pre></td></tr></table></figure>\n</li>\n<li>使用私钥文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r -i ~/.ssh/id_rsa local_file user@remote_host:/remote/path</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>SSH 配置：确保 SSH 服务已经在远程主机上启动，并且有相应的用户权限。</li>\n<li>私钥文件：如果使用私钥文件进行身份验证，确保私钥文件的路径和权限正确。</li>\n<li>端口号：如果远程主机的 SSH 服务使用了非标准端口（默认为 22），需要使用 -P 选项指定端口号。</li>\n<li>递归复制：在复制目录时，务必使用 -r 选项，否则只会复制目录中的文件而不是整个目录结构。</li>\n<li>文件权限：使用 -p 选项可以保留文件的权限和时间戳，避免不必要的权限问题。</li>\n<li>压缩：默认情况下，scp 已经启用了压缩。如果网络带宽有限，可以禁用压缩以提高传输速度。</li>\n<li>后台模式：对于大文件传输，可以使用 -B 选项在后台模式下传输，避免阻塞其他任务。</li>\n<li>多主机传输：在多主机之间传输文件时，使用 -3 选项可以提高效率。</li>\n<li>安全性：确保使用强密码或密钥对进行身份验证，避免未经授权的访问。</li>\n</ul>\n<h4 id=\"文件传输ftp\"><a class=\"markdownIt-Anchor\" href=\"#文件传输ftp\">#</a> 文件传输（ftp）</h4>\n<p>ftp (File Transfer Protocol) 是一个用于在计算机之间传输文件的标准协议。<br>\nftp 命令行工具允许用户连接到 FTP 服务器，上传、下载文件，浏览目录结构等。</p>\n<p>基本语法： <code>ftp [选项] [主机名]</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-n: 禁止自动登录。</li>\n<li>-i: 忽略所有输入。</li>\n<li>-d: 显示调试信息。</li>\n<li>-v: 显示详细信息。</li>\n<li>-s: 从脚本文件读取命令。</li>\n</ul>\n<p>以下是一些常用的 ftp 命令：</p>\n<ul>\n<li>open: 连接到 FTP 服务器。</li>\n<li>user: 登录用户名。</li>\n<li>pass: 登录密码。</li>\n<li>cd: 切换目录。</li>\n<li>pwd: 显示当前目录。</li>\n<li>ls: 列出目录内容。</li>\n<li>lcd: 切换本地目录。</li>\n<li>get: 下载文件。</li>\n<li>put: 上传文件。</li>\n<li>mget: 批量下载文件。</li>\n<li>mput: 批量上传文件。</li>\n<li>bye: 退出 FTP 会话。</li>\n<li>quit: 退出 FTP 会话。</li>\n<li>ascii: 设置文本模式。</li>\n<li>binary: 设置二进制模式。</li>\n<li>prompt: 开启或关闭提示符。</li>\n<li>rename: 重命名文件或目录。</li>\n<li>delete: 删除文件。</li>\n<li>mkdir: 创建目录。</li>\n<li>rmdir: 删除目录。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>连接到 FTP 服务器：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ftp example.com</span><br></pre></td></tr></table></figure>\n</li>\n<li>登录 FTP 服务器：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user username</span><br><span class=\"line\">pass password</span><br></pre></td></tr></table></figure>\n</li>\n<li>切换目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /path/to/directory</span><br></pre></td></tr></table></figure>\n</li>\n<li>列出目录内容：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls</span><br></pre></td></tr></table></figure>\n</li>\n<li>切换本地目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lcd /local/path</span><br></pre></td></tr></table></figure>\n</li>\n<li>下载文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get remote_file local_file</span><br></pre></td></tr></table></figure>\n</li>\n<li>上传文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">put local_file remote_file</span><br></pre></td></tr></table></figure>\n</li>\n<li>批量下载文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mget *.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>批量上传文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mput *.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li>设置文本模式：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ascii</span><br></pre></td></tr></table></figure>\n</li>\n<li>设置二进制模式：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binary</span><br></pre></td></tr></table></figure>\n</li>\n<li>退出 FTP 会话：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bye</span><br></pre></td></tr></table></figure>\n</li>\n<li>重命名文件或目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rename old_name new_name</span><br></pre></td></tr></table></figure>\n</li>\n<li>删除文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete file_name</span><br></pre></td></tr></table></figure>\n</li>\n<li>创建目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir directory_name</span><br></pre></td></tr></table></figure>\n</li>\n<li>删除目录：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rmdir directory_name</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>安全性：FTP 传输默认是明文传输，容易被截获。建议使用更安全的协议，如 SFTP 或 FTPS。</li>\n<li>认证信息：登录 FTP 服务器时，确保使用正确的用户名和密码。</li>\n<li>目录结构：在 FTP 服务器上切换目录时，注意当前目录的位置，以免误操作。</li>\n<li>文件类型：根据文件类型选择正确的传输模式（ASCII 或 Binary）。</li>\n<li>批量传输：批量上传或下载文件时，确保本地目录和远程目录匹配。</li>\n<li>脚本文件：可以将常用命令写入脚本文件，通过 -s 选项执行脚本。</li>\n<li>资源管理：长时间运行 FTP 会话时，注意监控系统资源使用情况，避免占用过多带宽和磁盘空间。</li>\n<li>防火墙和路由器设置：确保 FTP 服务器的 IP 地址和端口号（默认为 21）没有被防火墙或路由器阻止。</li>\n</ul>\n<h3 id=\"系统信息和维护\"><a class=\"markdownIt-Anchor\" href=\"#系统信息和维护\">#</a> 系统信息和维护</h3>\n<h4 id=\"系统基本信息查看uname\"><a class=\"markdownIt-Anchor\" href=\"#系统基本信息查看uname\">#</a> 系统基本信息查看（uname）</h4>\n<p>uname（Unix Name）命令用于显示系统的基本信息，包括内核名称、主机名、操作系统版本等。它是一个常用的系统信息查询工具，广泛应用于系统管理和诊断。</p>\n<p>基本语法： <code>uname [选项]</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-a：显示所有信息。</li>\n<li>-s：显示内核名称。</li>\n<li>-n：显示主机名。</li>\n<li>-r：显示内核版本号。</li>\n<li>-v：显示内核发布版本。</li>\n<li>-m：显示机器硬件名称。</li>\n<li>-p：显示处理器类型。</li>\n<li>-i：显示硬件平台。</li>\n<li>-o：显示操作系统名称。</li>\n<li>-r：显示内核版本号。</li>\n<li>-v：显示内核版本。</li>\n<li>-m：显示机器硬件名称。</li>\n<li>-p：显示处理器类型。</li>\n<li>-i：显示硬件平台。</li>\n<li>-o：显示操作系统名称。</li>\n<li>-v：显示内核版本。</li>\n<li>-r：显示内核版本号。</li>\n<li>-m：显示机器硬件名称。</li>\n<li>-p：显示处理器类型。</li>\n<li>-i：显示硬件平台。</li>\n<li>-o：显示操作系统名称。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>显示所有信息：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -a</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示内核名称：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -s</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示主机名：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -n</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示内核版本号：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -r</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示内核发布版本：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -v</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示机器硬件名称：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -m</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示处理器类型：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -p</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示硬件平台：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -i</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示操作系统名称：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -o</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>示例输出</p>\n<ul>\n<li>显示所有信息：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Linux myhost 5.4.0-77-generic #86-Ubuntu SMP Thu Sep 16 22:10:41 UTC </span><br></pre></td></tr></table></figure>\n</li>\n<li>显示内核名称：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Linux</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示主机名：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myhost</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示内核版本号：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5.4.0-77-generic</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示内核发布版本：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">86-Ubuntu SMP Thu Sep 16 22:10:41 UTC 2021</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>显示机器硬件名称：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x86_64</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示处理器类型：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x86_64</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示硬件平台：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x86_64</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示操作系统名称：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GNU/Linux</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>内核名称：使用 -s 选项可以显示内核名称，通常为 Linux。</li>\n<li>主机名：使用 -n 选项可以显示主机名，这对于网络管理非常有用。</li>\n<li>内核版本号：使用 -r 选项可以显示内核版本号，例如 5.4.0-77-generic。</li>\n<li>内核发布版本：使用 -v 选项可以显示内核发布版本，例如 #86-Ubuntu SMP Thu Sep 16 22:10:41 UTC 2021。</li>\n<li>机器硬件名称：使用 -m 选项可以显示机器硬件名称，例如 x86_64。</li>\n<li>处理器类型：使用 -p 选项可以显示处理器类型，例如 x86_64。</li>\n<li>硬件平台：使用 -i 选项可以显示硬件平台，例如 x86_64。</li>\n<li>操作系统名称：使用 -o 选项可以显示操作系统名称，例如 GNU/Linux。</li>\n<li>所有信息：使用 -a 选项可以显示所有系统信息，这对于系统管理和诊断非常有用。</li>\n<li>自动化脚本：uname 命令的输出可以方便地用于自动化脚本中，例如提取特定信息进行进一步处理。</li>\n<li>版本一致性：确保内核版本和操作系统版本的一致性，避免因版本不一致导致的问题。</li>\n<li>系统升级：在进行系统升级时，可以通过 uname 命令确认当前内核版本，确保升级过程顺利。</li>\n</ul>\n<h4 id=\"查看系统磁盘使用情况df\"><a class=\"markdownIt-Anchor\" href=\"#查看系统磁盘使用情况df\">#</a> 查看系统磁盘使用情况（df）</h4>\n<p>df（disk free）命令用于显示文件系统的磁盘空间使用情况。它可以帮助用户了解各个分区的使用情况，包括总容量、已用空间、可用空间等信息。</p>\n<p>基本语法： <code>df [选项]</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-h, --human-readable：以人类易读的格式显示磁盘空间（如 K、M、G 等）。</li>\n<li>-H, --si：以 1000 字节为单位显示磁盘空间（如 K、M、G 等）。</li>\n<li>-k, --kilobytes：以千字节（KB）为单位显示磁盘空间。</li>\n<li>-m, --megabytes：以兆字节（MB）为单位显示磁盘空间。</li>\n<li>-t, --type=TYPE：只显示指定类型的文件系统（如 ext4、xfs 等）。</li>\n<li>-T, --print-type：显示文件系统的类型。</li>\n<li>-x, --exclude-type=TYPE：排除指定类型的文件系统。</li>\n<li>-P, --portability：兼容旧版 df 命令的输出格式。</li>\n<li>-l, --local：只显示本地文件系统的信息。</li>\n<li>-a, --all：显示所有文件系统的信息，包括临时文件系统（如 tmpfs）。</li>\n<li>-i, --inodes：显示 inode 信息，而非磁盘空间。</li>\n<li>-hT, --output=OPTLIST：指定输出格式。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>默认显示磁盘空间使用情况：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df</span><br></pre></td></tr></table></figure>\n</li>\n<li>以人类易读的格式显示磁盘空间：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -h</span><br></pre></td></tr></table></figure>\n</li>\n<li>以 SI 单位显示磁盘空间：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -H</span><br></pre></td></tr></table></figure>\n</li>\n<li>以千字节（KB）为单位显示磁盘空间：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -k</span><br></pre></td></tr></table></figure>\n</li>\n<li>以兆字节（MB）为单位显示磁盘空间：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -m</span><br></pre></td></tr></table></figure>\n</li>\n<li>只显示指定类型的文件系统：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -t ext4</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示文件系统的类型：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -T</span><br></pre></td></tr></table></figure>\n</li>\n<li>排除指定类型的文件系统：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -x tmpfs</span><br></pre></td></tr></table></figure>\n</li>\n<li>只显示本地文件系统的信息：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -l</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示所有文件系统的信息：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -a</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示 inode 信息：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -i</span><br></pre></td></tr></table></figure>\n</li>\n<li>指定输出格式：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -hT</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>df 命令的输出通常包括以下列：</p>\n<ul>\n<li>Filesystem：文件系统的挂载点。</li>\n<li>Size：文件系统的总容量。</li>\n<li>Used：已使用的空间。</li>\n<li>Avail：可用的空间。</li>\n<li>Use%：使用百分比。</li>\n<li>Mounted on：文件系统的挂载点。</li>\n</ul>\n<p>示例输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class=\"line\">/dev/sda1       100G   50G   50G  50% /</span><br><span class=\"line\">tmpfs           2.0G     0  2.0G   0% /dev/shm</span><br><span class=\"line\">/dev/sdb1       200G  100G  100G  50% /data</span><br></pre></td></tr></table></figure>\n<p>注意事项</p>\n<ul>\n<li>磁盘空间不足：定期检查磁盘空间，避免因磁盘空间不足导致系统异常。</li>\n<li>inode 使用情况：使用 -i 选项可以显示 inode 的使用情况，这对于文件数量较多的情况非常有用。</li>\n<li>指定单位：使用 -h 或 -H 选项可以使输出更易于阅读，尤其是当磁盘空间较大时。</li>\n<li>文件系统类型：使用 -t 或 -T 选项可以指定或显示特定类型的文件系统，适用于特定场景下的监控。</li>\n<li>排除临时文件系统：使用 -x 选项可以排除临时文件系统（如 tmpfs），以便专注于永久存储设备。</li>\n<li>本地文件系统：使用 -l 选项可以只显示本地文件系统的信息，排除网络文件系统（如 NFS）。</li>\n<li>所有文件系统：使用 -a 选项可以显示所有文件系统的信息，包括临时文件系统，适用于全面监控。</li>\n<li>输出格式：使用 -hT 选项可以指定输出格式，便于自动化脚本处理。</li>\n</ul>\n<h4 id=\"查看目录或文件的磁盘使用情况du补充\"><a class=\"markdownIt-Anchor\" href=\"#查看目录或文件的磁盘使用情况du补充\">#</a> 查看目录或文件的磁盘使用情况（du）补充</h4>\n<h4 id=\"查看系统内存使用情况free\"><a class=\"markdownIt-Anchor\" href=\"#查看系统内存使用情况free\">#</a> 查看系统内存使用情况（free）</h4>\n<p>free 命令用于显示系统中的内存使用情况，包括物理内存、交换空间（swap）和缓冲区（buffers）等信息。它可以帮助用户了解当前系统的内存使用状况，对于系统管理和性能监控非常有用。<br>\n用途</p>\n<p>基本语法： <code>free [选项]</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-b：以字节（bytes）为单位显示内存大小。</li>\n<li>-k：以千字节（KB）为单位显示内存大小（默认）。</li>\n<li>-m：以兆字节（MB）为单位显示内存大小。</li>\n<li>-g：以吉字节（GB）为单位显示内存大小。</li>\n<li>-h：以人类易读的格式显示内存大小（自动选择单位）。</li>\n<li>-l：显示锁定内存（locked memory）。</li>\n<li>-s：指定更新间隔时间（秒），持续显示内存使用情况。</li>\n<li>-t：显示总计（total）内存。</li>\n<li>-V：显示版本信息。</li>\n<li>-h：以人类易读的格式显示内存大小（自动选择单位）。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>默认显示内存使用情况：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free</span><br></pre></td></tr></table></figure>\n</li>\n<li>以人类易读的格式显示内存大小：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free -h</span><br></pre></td></tr></table></figure>\n</li>\n<li>以兆字节（MB）为单位显示内存大小：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free -m</span><br></pre></td></tr></table></figure>\n</li>\n<li>以千字节（KB）为单位显示内存大小：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free -k</span><br></pre></td></tr></table></figure>\n</li>\n<li>以字节（bytes）为单位显示内存大小：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free -b</span><br></pre></td></tr></table></figure>\n</li>\n<li>以吉字节（GB）为单位显示内存大小：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free -g</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示锁定内存：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free -l</span><br></pre></td></tr></table></figure>\n</li>\n<li>指定更新间隔时间为 2 秒，持续显示内存使用情况：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free -s 2</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示总计内存：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free -t</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示版本信息：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free -V</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>free 命令的输出通常包括以下几部分：</p>\n<ul>\n<li>Total：总内存。</li>\n<li>Used：已使用的内存。</li>\n<li>Free：空闲的内存。</li>\n<li>Shared：共享内存。</li>\n<li>Buffers：缓冲区内存。</li>\n<li>Cached：缓存内存。</li>\n<li>Available：可用内存。</li>\n</ul>\n<p>示例输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">              total        used        free      shared  buff/cache   available</span><br><span class=\"line\">Mem:           8114        1519        2793          0        3802        4335</span><br><span class=\"line\">Swap:         40960          16       40944</span><br></pre></td></tr></table></figure>\n<p>注意事项</p>\n<ul>\n<li>内存单位的选择：\n<ul>\n<li>使用 -h 选项可以自动选择合适的单位（如 K、M、G），使输出更易于阅读。</li>\n<li>使用 -m 或 -k 选项可以固定单位显示，适用于自动化脚本。</li>\n</ul>\n</li>\n<li>持续更新内存使用情况：使用 -s 选项可以指定更新间隔时间，持续显示内存使用情况。这在监控系统性能时非常有用。</li>\n<li>锁定内存：使用 -l 选项可以显示锁定内存（locked memory），适用于需要关注锁定内存的应用场景。</li>\n<li>总计内存：使用 -t 选项可以显示总计内存，方便查看整体内存使用情况。</li>\n<li>内存不足的诊断：定期检查内存使用情况，避免因内存不足导致系统性能下降或崩溃。</li>\n<li>内存缓冲区和缓存：Buffers 和 Cached 列显示了缓冲区和缓存内存，这部分内存通常可以快速释放，有助于提高系统性能。</li>\n<li>可用内存：Available 列显示了当前系统可用的内存，这是系统实际可分配给新进程的内存。</li>\n<li>版本信息：使用 -V 选项可以显示 free 命令的版本信息，确保使用的是最新版本。</li>\n</ul>\n<h4 id=\"查看和设置系统时间date\"><a class=\"markdownIt-Anchor\" href=\"#查看和设置系统时间date\">#</a> 查看和设置系统时间（date）</h4>\n<p>date 命令用于显示和设置系统日期和时间。它是一个非常常用的工具，不仅可以查看当前的日期和时间，还可以用来设置系统的时间。</p>\n<p>基本语法： <code>date [选项] [日期时间字符串]</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-u：以 UTC（协调世界时）显示日期和时间。</li>\n<li>+FORMAT：指定输出格式。</li>\n<li>-d：指定日期时间字符串。</li>\n<li>-s：设置系统日期和时间。</li>\n<li>-R：RFC 2822 格式输出。</li>\n<li>-r：以自上次系统启动以来的秒数表示时间。</li>\n<li>-d：指定日期时间字符串并计算结果。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>显示当前日期和时间：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">date</span><br></pre></td></tr></table></figure>\n</li>\n<li>以 UTC 时间显示当前日期和时间：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">date -u</span><br></pre></td></tr></table></figure>\n</li>\n<li>指定输出格式：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">date +&quot;%Y-%m-%d %H:%M:%S&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li>指定日期时间字符串并计算结果：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">date -d &quot;now + 1 day&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li>设置系统日期和时间：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">date -s &quot;2023-10-01 12:00:00&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li>以 RFC 2822 格式输出：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">date -R</span><br></pre></td></tr></table></figure>\n</li>\n<li>以自上次系统启动以来的秒数表示时间：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">date -r</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>date 命令支持多种输出格式，常见的格式符包括：</p>\n<ul>\n<li>% Y：年份，如 2023。</li>\n<li>% m：月份，如 10。</li>\n<li>% d：日期，如 01。</li>\n<li>% H：小时（24 小时制），如 12。</li>\n<li>% M：分钟，如 30。</li>\n<li>% S：秒，如 45。</li>\n<li>% a：星期几的缩写，如 Sun。</li>\n<li>% A：星期几的全称，如 Sunday。</li>\n<li>% b：月份的缩写，如 Oct。</li>\n<li>% B：月份的全称，如 October。</li>\n<li>% c：日期和时间的表示，如 Mon Oct 2 12:30:45 2023。</li>\n<li>% r：12 小时制的时间表示，如 12:30:45 PM。</li>\n<li>% T：24 小时制的时间表示，如 12:30:45。</li>\n<li>% Z：时区名称，如 CST。</li>\n<li>% z：时区偏移量，如 +0800。</li>\n</ul>\n<p>示例输出</p>\n<ul>\n<li>显示当前日期和时间：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mon Oct 2 12:30:45 CST 2023</span><br></pre></td></tr></table></figure>\n</li>\n<li>指定输出格式：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2023-10-02 12:30:45</span><br></pre></td></tr></table></figure>\n</li>\n<li>指定日期时间字符串并计算结果：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mon Oct 3 12:30:45 CST 2023</span><br></pre></td></tr></table></figure>\n</li>\n<li>设置系统日期和时间：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mon Oct 1 12:00:00 CST 2023</span><br></pre></td></tr></table></figure>\n</li>\n<li>以 RFC 2822 格式输出：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mon, 02 Oct 2023 12:30:45 +0800</span><br></pre></td></tr></table></figure>\n</li>\n<li>以自上次系统启动以来的秒数表示时间：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12345678</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>设置系统日期和时间：\n<ul>\n<li>使用 -s 选项可以设置系统日期和时间，但在某些系统中可能需要管理员权限。</li>\n<li>设置时间时，确保时间格式正确无误。</li>\n</ul>\n</li>\n<li>输出格式：使用 +FORMAT 选项可以指定输出格式，便于自动化脚本处理。熟悉常用的格式符，以便灵活使用。</li>\n<li>UTC 时间：使用 -u 选项可以显示 UTC 时间，适用于跨时区的应用场景。</li>\n<li>日期时间字符串：使用 -d 选项可以指定日期时间字符串并计算结果，例如 now + 1 day。</li>\n<li>自动化脚本：date 命令常用于自动化脚本中，例如定时任务、日志记录等。</li>\n<li>系统同步：确保系统时间准确，可以使用 NTP（Network Time Protocol）服务进行同步。</li>\n<li>时间格式一致性：在不同的系统和环境中，时间格式可能略有不同，确保格式一致性。</li>\n<li>时区问题：处理跨时区的数据时，注意时区转换和调整。</li>\n</ul>\n<h4 id=\"显示日历cal补充\"><a class=\"markdownIt-Anchor\" href=\"#显示日历cal补充\">#</a> 显示日历（cal）补充</h4>\n<h4 id=\"显示当前登录用户who补充\"><a class=\"markdownIt-Anchor\" href=\"#显示当前登录用户who补充\">#</a> 显示当前登录用户（who）补充</h4>\n<h4 id=\"显示最近的登录记录last补充\"><a class=\"markdownIt-Anchor\" href=\"#显示最近的登录记录last补充\">#</a> 显示最近的登录记录（last）补充</h4>\n<h4 id=\"显示命令历史history补充\"><a class=\"markdownIt-Anchor\" href=\"#显示命令历史history补充\">#</a> 显示命令历史（history）补充</h4>\n<h4 id=\"命令手册man\"><a class=\"markdownIt-Anchor\" href=\"#命令手册man\">#</a> 命令手册（man）</h4>\n<p>man 命令用于查看系统命令、实用工具、库函数以及其他系统组件的手册页。手册页提供了详细的文档，包括命令的使用方法、参数、环境变量、文件位置、退出状态、错误信息等信息。<br>\n以下是 man 命令的一些基本用法和参数：</p>\n<p>基本语法： <code>man [选项] [章节号] 命令名</code></p>\n<p>参数</p>\n<ul>\n<li>章节号：每个手册页都有一个章节号，用来区分不同类型的文档。例如：\n<ul>\n<li>1：用户命令。</li>\n<li>2：系统调用。</li>\n<li>3：库函数。</li>\n<li>4：特殊文件（通常是设备文件）。</li>\n<li>5：文件格式和配置文件。</li>\n<li>6：游戏。</li>\n<li>7：杂项（包括宏包和惯例）。</li>\n<li>8：系统管理命令。</li>\n</ul>\n</li>\n</ul>\n<p>选项</p>\n<ul>\n<li>-a 或 --all：在所有的手册页中搜索指定的命令或主题。</li>\n<li>-f 或 --apropos：等价于 whatis 命令，显示给定关键字的简短描述信息。</li>\n<li>-k 或 --apropos：等价于 -f，显示给定关键字的简短描述信息。</li>\n<li>-P 或 --pager：指定内容时使用分页程序，例如 less。</li>\n<li>-M 或 --manualdir：指定手册页搜索路径。</li>\n<li>-m 或 --arch：指定架构。</li>\n<li>-w 或 --where：显示手册页的位置。</li>\n</ul>\n<p>示例：</p>\n<ul>\n<li>查看 ls 命令的手册页：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">man ls</span><br></pre></td></tr></table></figure>\n</li>\n<li>查看 ls 命令的第 1 章节的手册页：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">man 1 ls</span><br></pre></td></tr></table></figure>\n</li>\n<li>在所有手册页中搜索 grep：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">man -a grep</span><br></pre></td></tr></table></figure>\n</li>\n<li>使用 less 分页器查看 man 命令的手册页：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">man -P less man</span><br></pre></td></tr></table></figure>\n</li>\n<li>查看与 grep 相关的手册页摘要：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">man -f grep</span><br></pre></td></tr></table></figure>\n</li>\n<li>查找与 grep 相关的手册页：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">man -k grep</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示 ls 手册页的位置：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">man -w ls</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<p>在手册页中导航<br>\n一旦进入了手册页，你可以使用以下按键来进行导航和操作：</p>\n<ul>\n<li>空格键：向下滚动一页。</li>\n<li>b 或 Page Up：向上滚动一页。</li>\n<li>Enter：向下滚动一行。</li>\n<li>u 或 Page Down：向上滚动一行。</li>\n<li>/ 或？：搜索关键词（使用 / 向前搜索，? 向后搜索）。</li>\n<li>n 或 N：跳转到下一个或上一个搜索结果。</li>\n<li>q：退出手册页。</li>\n<li>h：显示帮助信息。</li>\n</ul>\n<h4 id=\"显示命令的信息页info补充\"><a class=\"markdownIt-Anchor\" href=\"#显示命令的信息页info补充\">#</a> 显示命令的信息页（info）补充</h4>\n<h4 id=\"系统命令查看whereis\"><a class=\"markdownIt-Anchor\" href=\"#系统命令查看whereis\">#</a> 系统命令查看（whereis）</h4>\n<p>whereis 命令用于查找系统中指定命令或程序的位置，包括二进制文件、源代码文件和手册页等。它是一个快速定位命令位置的工具，常用于开发和系统管理。</p>\n<p>基本语法： <code>whereis [选项] 命令名</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-b：仅查找二进制文件。</li>\n<li>-m：仅查找手册页。</li>\n<li>-s：仅查找源代码文件。</li>\n<li>-u：仅查找用户手册页。</li>\n<li>-a：查找所有类型的位置（默认行为）。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>查找命令的位置：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whereis ls</span><br></pre></td></tr></table></figure>\n</li>\n<li>仅查找二进制文件的位置：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whereis -b ls</span><br></pre></td></tr></table></figure>\n</li>\n<li>仅查找手册页的位置：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whereis -m ls</span><br></pre></td></tr></table></figure>\n</li>\n<li>仅查找源代码文件的位置：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whereis -s ls</span><br></pre></td></tr></table></figure>\n</li>\n<li>查找所有类型的位置：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whereis -a ls</span><br></pre></td></tr></table></figure>\n</li>\n<li>查找多个命令的位置：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whereis ls grep</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>命令名称的准确性：确保输入的命令名称准确无误，否则 whereis 可能找不到对应的位置。</li>\n<li>环境变量的影响：whereis 的搜索路径受环境变量 PATH 和 MANPATH 的影响。确保这些环境变量配置正确，以便 whereis 能够找到正确的文件。</li>\n<li>源代码文件的查找：whereis 查找源代码文件时，通常是在 /usr/src 目录下查找。如果源代码不在这个目录下，whereis 可能无法找到。</li>\n<li>手册页的查找：手册页通常位于 /usr/share/man 目录下。如果手册页不在这个目录下，whereis 可能无法找到。</li>\n<li>命令别名的影响：如果某个命令是别名或者软链接，whereis 可能会显示实际的命令路径，而不是别名或软链接本身。</li>\n<li>系统更新后的变化：系统更新后，某些命令或手册页的位置可能会发生变化。此时，建议重新运行 whereis 命令以获取最新的位置信息。</li>\n</ul>\n<h4 id=\"系统命令路径查看which\"><a class=\"markdownIt-Anchor\" href=\"#系统命令路径查看which\">#</a> 系统命令路径查看（which）</h4>\n<p>which 命令用于查找系统中可执行命令的完整路径。它可以帮助用户确定某个命令的具体位置，通常用于开发和系统管理环境中。</p>\n<p>基本语法： <code>which [选项] 命令名</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-a：显示所有匹配的命令路径。</li>\n<li>-m：显示命令的多个匹配路径。</li>\n<li>-s：仅显示第一个匹配的命令路径。</li>\n<li>-t：将结果输出到标准输出，而不是打印。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>查找命令的完整路径：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which ls</span><br></pre></td></tr></table></figure>\n</li>\n<li>查找多个命令的完整路径：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which ls grep</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示所有匹配的命令路径：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which -a ls</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示命令的多个匹配路径：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which -m ls</span><br></pre></td></tr></table></figure>\n</li>\n<li>仅显示第一个匹配的命令路径：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which -s ls</span><br></pre></td></tr></table></figure>\n</li>\n<li>将结果输出到标准输出：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which -t ls</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>命令名称的准确性：确保输入的命令名称准确无误，否则 which 可能找不到对应的位置。</li>\n<li>环境变量的影响：which 的搜索路径受环境变量 PATH 的影响。确保 PATH 变量配置正确，以便 which 能够找到正确的文件。</li>\n<li>命令别名的影响：如果某个命令是别名或者软链接，which 可能会显示实际的命令路径，而不是别名或软链接本身。</li>\n<li>系统更新后的变化：系统更新后，某些命令的位置可能会发生变化。此时，建议重新运行 which 命令以获取最新的位置信息。</li>\n<li>多路径匹配：使用 -a 或 -m 选项时，which 会显示所有匹配的路径。这在某些情况下非常有用，尤其是在系统中有多个版本的命令时。</li>\n<li>仅显示第一个匹配路径：使用 -s 选项时，which 只显示第一个匹配的路径。这对于简单验证命令是否存在非常方便。</li>\n<li>输出到标准输出：使用 -t 选项时，which 将结果输出到标准输出，而不是打印。这在脚本中非常有用，可以方便地处理输出结果。</li>\n</ul>\n<h4 id=\"关闭系统shutdown\"><a class=\"markdownIt-Anchor\" href=\"#关闭系统shutdown\">#</a> 关闭系统（shutdown）</h4>\n<p>基本语法： <code>shutdown [选项] [时间] [警告信息]</code></p>\n<p>参数</p>\n<ul>\n<li>时间：指定何时执行关机或重启。可以是 <code>立即执行（now），几分钟后（+分钟数），或者指定的时间（hh:mm）</code> 。</li>\n<li>警告信息：可以附加一个消息给所有登录的用户，通知他们即将发生的动作。</li>\n</ul>\n<p>选项</p>\n<ul>\n<li>-h：关机。shutdown -h now 会立即关机。</li>\n<li>-r：重启。shutdown -r now 会立即重启。</li>\n<li>-k：发送警告信息给所有用户，但不执行关机或重启。</li>\n<li>-c：取消已经计划的关机或重启。</li>\n<li>-f：强制关机或重启，不执行文件系统检查（fsck）。</li>\n<li>-F：强制关机或重启，并且执行文件系统检查。</li>\n<li>-n：不通过 init 而直接由 shutdown 命令执行关机或重启。</li>\n<li>-t 秒数：指定从警告信息发出到真正执行关机或重启之间的延迟秒数。</li>\n</ul>\n<p>示例</p>\n<ol>\n<li>立即关机：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo shutdown -h now</span><br></pre></td></tr></table></figure>\n</li>\n<li>立即重启：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo shutdown -r now</span><br></pre></td></tr></table></figure>\n</li>\n<li>在 10 分钟后关机，并附带警告信息：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo shutdown -h +10 &quot;System will shutdown in 10 minutes&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li>在晚上 10 点 30 分关机：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo shutdown -h 22:30 &quot;System will shutdown at 22:30&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li>发送警告信息而不执行关机：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo shutdown -k now &quot;This is a warning message&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li>取消已经计划的关机：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo shutdown -c</span><br></pre></td></tr></table></figure>\n</li>\n<li>强制关机，不执行文件系统检查：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo shutdown -hf now</span><br></pre></td></tr></table></figure>\n</li>\n<li>强制重启，并且执行文件系统检查：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo shutdown -Fr now</span><br></pre></td></tr></table></figure>\n</li>\n<li>延迟 60 秒后关机：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo shutdown -h +60</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>注意事项</p>\n<ul>\n<li>shutdown 命令通常需要超级用户权限，因此通常需要使用 sudo 前缀。</li>\n<li>当使用 shutdown 来计划关机或重启时，系统会向所有登录的用户发送通知。</li>\n<li>如果没有指定时间，shutdown 会默认在 1 分钟后执行关机或重启。</li>\n<li>使用 -k 选项时，系统不会真正关机或重启，只会发送警告信息给用户。</li>\n</ul>\n<h4 id=\"切换用户su\"><a class=\"markdownIt-Anchor\" href=\"#切换用户su\">#</a> 切换用户（su）</h4>\n<p>su（switch user）命令在 Linux 和 Unix-like 操作系统中用于切换当前用户到另一个用户的身份。<br>\n这个命令允许你临时以另一个用户的身份执行命令或继续工作，通常是为了获得更高的权限（如 root 用户权限）来执行某些需要特权的操作。</p>\n<p>基本语法： <code>su [选项] [用户名]</code></p>\n<p>参数</p>\n<ul>\n<li>用户名：指定要切换到的用户名。</li>\n</ul>\n<p>选项</p>\n<ul>\n<li>- 或 -l 或 --login：模拟一个完整的登录环境，这意味着它会加载目标用户的环境变量、家目录等。<br>\n如果不使用这个选项，su 只会改变用户 ID，而不会改变环境变量。</li>\n<li>-c 或 --command=command：变更用户身份并执行指定的命令，执行完毕后自动返回到原来的用户身份。</li>\n<li>-s 或 --shell=shell：指定要使用的 shell。默认情况下，su 会使用 /etc/passwd 文件中定义的目标用户的 shell。</li>\n<li>-m 或 -p 或 --preserve-environment：执行 su 时不改变环境变量。</li>\n<li>-f 或 --fast：不读取启动文件（如 csh.cshrc 等），仅适用于 csh 或 tcsh shell。</li>\n<li>-h 或 --help：显示帮助信息。</li>\n<li>-v 或 --version：显示版本信息。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>\n<p>切换到 root 用户： 使用如下命令并输入 root 用户的密码后，你将切换到 root 用户身份，并且提示符会变为 root 用户的提示符。</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su root</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>切换到任意用户： 这里 username 是你要切换到的用户名称。</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su username</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>以 root 用户身份执行单个命令： 这条命令将以 root 用户的身份执行 ls -l 命令，并在命令执行完毕后回到原始用户。</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su -c &#x27;ls -l&#x27; root</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>模拟登录到 root 用户： 这将模拟一个完整的登录环境，加载 root 用户的环境变量和 home 目录。</p>\n<ul>\n<li>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">su</span> - root</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span>--code￼401--<span class=\"token operator\">></span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>\n<p>保持当前环境变量不变的情况下切换用户：</p>\n<ul>\n<li>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">su</span> <span class=\"token parameter variable\">-m</span> username</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span>--code￼402--<span class=\"token operator\">></span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>\n<p>指定 shell 来执行命令：</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su -s /bin/bash username</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>快速切换用户：</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su - username</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>密码要求：当切换到另一个用户时，通常需要输入该用户的密码。</li>\n<li>环境变量：使用 - 或 -l 选项时，会加载目标用户的环境变量，这可能会影响当前的工作环境。</li>\n<li>安全性：频繁使用 su 切换到 root 用户可能会增加系统的安全风险，因为这给予了用户完全的系统控制权。<br>\n在现代 Linux 系统中，推荐使用 sudo 命令来执行需要特权的操作，这样可以避免暴露 root 密码，并且可以对用户的权限进行细粒度控制。</li>\n<li>命令执行：使用 -c 选项时，要注意命令的引号包围问题，确保命令能够正确执行。</li>\n</ul>\n<h4 id=\"以其他用户的身份执行命令sudo\"><a class=\"markdownIt-Anchor\" href=\"#以其他用户的身份执行命令sudo\">#</a> 以其他用户的身份执行命令（sudo）</h4>\n<p>sudo（superuser do）命令在 Linux 和 Unix-like 操作系统中用于以其他用户（通常是 root 用户）的身份执行命令。<br>\n它提供了一种安全的方式来临时提升权限，以便执行需要特权的操作。</p>\n<p>基本语法： <code>sudo [选项] 命令</code></p>\n<p>参数</p>\n<ul>\n<li>命令：要以其他用户身份执行的具体命令。</li>\n</ul>\n<p>选项</p>\n<ul>\n<li>-u 用户名：指定要以哪个用户的身份执行命令，默认为 root 用户。</li>\n<li>-s：执行一个 shell，而不是具体的命令。</li>\n<li>-i：模拟一个完整的登录环境，类似于 su -。</li>\n<li>-l：列出当前用户可以执行的命令。</li>\n<li>-v：验证当前用户的密码，但不执行任何命令。</li>\n<li>-k：清除当前用户的 sudo 记录。</li>\n<li>-E 或 --preserve-env：保留当前环境变量。</li>\n<li>-H 或 --set-home：设置 HOME 环境变量为目标用户的家目录。</li>\n<li>-S：从标准输入读取密码。</li>\n<li>-V 或 --version：显示版本信息。</li>\n<li>-h 或 --help：显示帮助信息。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>以 root 用户身份执行命令：这条命令将以 root 用户的身份执行 ls -l 命令。<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ls -l</span><br></pre></td></tr></table></figure>\n</li>\n<li>以指定用户身份执行命令：这条命令将以 username 用户的身份执行 ls -l 命令。<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo -u username ls -l</span><br></pre></td></tr></table></figure>\n</li>\n<li>执行一个 shell：这条命令将以 root 用户的身份打开一个 shell。<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo -s</span><br></pre></td></tr></table></figure>\n</li>\n<li>模拟登录环境：这条命令将以 root 用户的身份模拟一个完整的登录环境。<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo -i</span><br></pre></td></tr></table></figure>\n</li>\n<li>列出可执行的命令：这条命令将列出当前用户可以执行的命令。<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo -l</span><br></pre></td></tr></table></figure>\n</li>\n<li>验证密码但不执行命令：这条命令将验证当前用户的密码，但不执行任何命令。<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo -v</span><br></pre></td></tr></table></figure>\n</li>\n<li>保留当前环境变量：这条命令将以 root 用户的身份执行 ls -l 命令，并保留当前环境变量。<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo -E ls -l</span><br></pre></td></tr></table></figure>\n</li>\n<li>设置 HOME 环境变量：这条命令将以 root 用户的身份执行 ls -l 命令，并设置 HOME 环境变量为 root 用户的家目录。<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo -H ls -l</span><br></pre></td></tr></table></figure>\n</li>\n<li>从标准输入读取密码：这条命令将从标准输入读取密码，并以 root 用户的身份执行 ls -l 命令。<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;password&quot; | sudo -S ls -l</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>密码验证：使用 sudo 时通常需要输入当前用户的密码。密码验证的有效期通常为 5 分钟，之后需要重新输入密码。</li>\n<li>配置文件：sudo 的行为可以通过 /etc/sudoers 文件进行配置。只有被允许的用户才能使用 sudo 命令。<br>\n编辑 sudoers 文件通常需要使用 visudo 命令。</li>\n<li>安全性：sudo 命令提供了更好的安全性，因为它不需要暴露 root 密码，并且可以限制用户执行特定的命令。<br>\n建议尽量使用 sudo 而不是直接使用 su 切换到 root 用户。</li>\n<li>环境变量：使用 -E 选项时，会保留当前环境变量。如果不使用 -E，则会加载目标用户的环境变量。</li>\n<li>命令执行：使用 sudo 时，注意命令的引号包围问题，确保命令能够正确执行。</li>\n<li>日志记录：sudo 命令通常会被记录在系统日志中，便于审计和追踪。</li>\n</ul>\n<h4 id=\"挂载文件系统mount\"><a class=\"markdownIt-Anchor\" href=\"#挂载文件系统mount\">#</a> 挂载文件系统（mount）</h4>\n<p>mount 命令用于将文件系统挂载到系统中的某个目录上。它是一个非常重要的系统管理工具，广泛应用于挂载硬盘分区、USB 设备、网络文件系统（NFS）等。</p>\n<p>基本语法： <code>mount [选项] [设备名] [挂载点]</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-a：挂载 /etc/fstab 文件中的所有条目。</li>\n<li>-t：指定文件系统类型。</li>\n<li>-o：指定挂载选项。</li>\n<li>-v：显示详细信息。</li>\n<li>-n：不更新 /etc/mtab 文件。</li>\n<li>-l：列出当前挂载的所有文件系统。</li>\n<li>-u：重新挂载已挂载的文件系统。</li>\n<li>-r：以只读方式挂载。</li>\n<li>-w：以读写方式挂载。</li>\n<li>-nolock：不使用锁机制。</li>\n<li>-o remount：重新挂载已挂载的文件系统。</li>\n<li>-o ro：以只读方式挂载。</li>\n<li>-o rw：以读写方式挂载。</li>\n<li>-o loop：挂载循环设备（如 ISO 镜像）。</li>\n<li>-o bind：绑定挂载。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>挂载一个硬盘分区：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount /dev/sda1 /mnt/data</span><br></pre></td></tr></table></figure>\n</li>\n<li>挂载一个 USB 设备：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount /dev/sdc1 /mnt/usb</span><br></pre></td></tr></table></figure>\n</li>\n<li>挂载一个网络文件系统（NFS）：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -t nfs server:/export/path /mnt/nfs</span><br></pre></td></tr></table></figure>\n</li>\n<li>挂载一个 ISO 镜像：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -o loop /path/to/image.iso /mnt/cdrom</span><br></pre></td></tr></table></figure>\n</li>\n<li>挂载一个文件系统，并指定挂载选项：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -t ext4 -o defaults,noatime /dev/sda1 /mnt/data</span><br></pre></td></tr></table></figure>\n</li>\n<li>挂载所有条目：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -a</span><br></pre></td></tr></table></figure>\n</li>\n<li>重新挂载一个已挂载的文件系统：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -o remount /mnt/data</span><br></pre></td></tr></table></figure>\n</li>\n<li>以只读方式挂载：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -o ro /dev/sda1 /mnt/data</span><br></pre></td></tr></table></figure>\n</li>\n<li>以读写方式挂载：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -o rw /dev/sda1 /mnt/data</span><br></pre></td></tr></table></figure>\n</li>\n<li>绑定挂载：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount --bind /src /mnt/bind</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>在挂载之前，确保挂载点目录已经存在。</li>\n<li>使用 -o 选项可以指定挂载选项，如 defaults、noatime 等，这些选项会影响文件系统的性能和行为。</li>\n<li>使用 -t 选项指定文件系统类型，例如 ext4、nfs 等。</li>\n<li>使用 -o remount 选项可以重新挂载已挂载的文件系统，而不卸载后再挂载。</li>\n<li>使用 -o ro 可以以只读方式挂载，使用 -o rw 可以以读写方式挂载。</li>\n<li>使用 -o loop 选项可以挂载 ISO 镜像等循环设备。</li>\n<li>使用 --bind 选项可以将一个目录的内容绑定到另一个目录，适用于共享数据的场景。</li>\n<li>使用 -a 选项可以挂载 /etc/fstab 文件中的所有条目，适用于系统启动时自动挂载。</li>\n<li>使用 -v 选项可以显示详细的挂载信息，适用于调试和诊断。</li>\n<li>使用 -n 选项可以不更新 /etc/mtab 文件，适用于不需要记录挂载信息的场景。</li>\n<li>在挂载文件系统时，确保有足够的权限。通常需要 root 用户权限才能挂载。</li>\n<li>将挂载信息添加到 /etc/fstab 文件中，可以在系统启动时自动挂载。</li>\n</ul>\n<h4 id=\"管理系统服务service\"><a class=\"markdownIt-Anchor\" href=\"#管理系统服务service\">#</a> 管理系统服务（service）</h4>\n<p>service 命令是用于管理系统服务的命令行工具。它提供了启动、停止、重启、状态查询等功能，适用于不同的系统初始化系统（如<br>\n SysVinit、Upstart 和 Systemd）。</p>\n<p>基本格式： <code>service [服务名称] [命令]</code></p>\n<p>命令</p>\n<ul>\n<li>start: 启动服务。</li>\n<li>stop: 停止服务。</li>\n<li>restart: 重启服务。</li>\n<li>reload: 重新加载服务配置。</li>\n<li>status: 查看服务状态。</li>\n<li>enable: 使服务在系统启动时自动启动。</li>\n<li>disable: 禁用服务在系统启动时自动启动。</li>\n<li>force-reload: 强制重新加载服务配置。</li>\n<li>condrestart: 如果服务未运行，则启动服务。</li>\n<li>try-restart: 尝试重启服务，如果服务未运行则启动服务。</li>\n<li>once: 仅运行一次服务。</li>\n<li>is-enabled: 检查服务是否设置为随系统启动自动启动。</li>\n<li>is-active: 检查服务是否正在运行。</li>\n<li>is-failed: 检查服务是否处于失败状态。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>启动服务：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service nginx start</span><br></pre></td></tr></table></figure>\n</li>\n<li>停止服务：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service nginx stop</span><br></pre></td></tr></table></figure>\n</li>\n<li>重启服务：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service nginx restart</span><br></pre></td></tr></table></figure>\n</li>\n<li>检查服务状态：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service nginx status</span><br></pre></td></tr></table></figure>\n</li>\n<li>重新加载服务配置：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service nginx reload</span><br></pre></td></tr></table></figure>\n</li>\n<li>强制重新加载服务配置：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service nginx force-reload</span><br></pre></td></tr></table></figure>\n</li>\n<li>使服务在系统启动时自动启动：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service nginx enable</span><br></pre></td></tr></table></figure>\n</li>\n<li>禁用服务在系统启动时自动启动：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service nginx disable</span><br></pre></td></tr></table></figure>\n</li>\n<li>如果服务未运行，则启动服务：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service nginx condrestart</span><br></pre></td></tr></table></figure>\n</li>\n<li>尝试重启服务，如果服务未运行则启动服务：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service nginx try-restart</span><br></pre></td></tr></table></figure>\n</li>\n<li>仅运行一次服务：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service nginx once</span><br></pre></td></tr></table></figure>\n</li>\n<li>检查服务是否设置为随系统启动自动启动：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service nginx is-enabled</span><br></pre></td></tr></table></figure>\n</li>\n<li>检查服务是否正在运行：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service nginx is-active</span><br></pre></td></tr></table></figure>\n</li>\n<li>检查服务是否处于失败状态：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service nginx is-failed</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>服务名称：确保服务名称正确无误。服务名称通常是服务程序的名称，如 nginx、httpd、mysql 等。</li>\n<li>初始化系统：service 命令的行为取决于系统的初始化系统。在 SysVinit 系统中，service 命令直接调用 /etc/init.d/ 目录下的脚本；在</li>\n<li>Systemd 系统中，service 命令实际上调用的是 systemctl 命令。</li>\n<li>依赖关系：某些服务可能依赖于其他服务。在执行操作之前，确保所有依赖的服务都已正确启动。</li>\n<li>权限问题：通常需要 root 权限才能执行 service 命令。如果没有 root 权限，可以使用 sudo 命令。</li>\n<li>配置文件：重新加载服务配置时，确保配置文件已经正确修改并保存。</li>\n<li>日志文件：如果服务出现问题，可以通过查看相关的日志文件来诊断问题。例如，nginx 的日志文件通常位于 /var/log/nginx/ 目录下。</li>\n<li>状态检查：在执行操作前后，可以使用 status 命令检查服务的状态，确保操作成功。</li>\n<li>自动启动管理：使用 enable 和 disable 选项可以方便地管理服务的自动启动设置。</li>\n<li>错误处理：如果遇到错误，可以查看详细的错误信息，或者使用 journalctl 命令查看 Systemd 日志。</li>\n</ul>\n<h3 id=\"包管理\"><a class=\"markdownIt-Anchor\" href=\"#包管理\">#</a> 包管理</h3>\n<h4 id=\"apt-命令debianubuntu\"><a class=\"markdownIt-Anchor\" href=\"#apt-命令debianubuntu\">#</a> apt 命令（Debian/Ubuntu）</h4>\n<p>apt (Advanced Package Tool) 是 Debian 系及其衍生系统（如 Ubuntu）中常用的包管理工具。它可以处理软件包的安装、更新、删除等操作，并且能够自动解决依赖关系。</p>\n<p>基本语法： <code>apt [选项] [命令] [参数]</code></p>\n<p>参数与选项</p>\n<ul>\n<li>install: 安装指定的软件包。</li>\n<li>update: 更新本地包索引。</li>\n<li>upgrade: 更新已安装的软件包到最新版本。</li>\n<li>remove: 卸载指定的软件包。</li>\n<li>purge: 卸载指定的软件包并删除其配置文件。</li>\n<li>list: 列出可用的软件包。</li>\n<li>show: 显示软件包的详细信息。</li>\n<li>search: 搜索软件仓库中符合关键字的所有软件包。</li>\n<li>autoremove: 卸载不再需要的自动安装的软件包。</li>\n<li>clean: 清除下载的包缓存。</li>\n<li>autoclean: 清除旧的、不再需要的包缓存。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>更新本地包索引：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br></pre></td></tr></table></figure>\n</li>\n<li>安装软件包：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install httpd</span><br></pre></td></tr></table></figure>\n</li>\n<li>更新所有已安装的软件包：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt upgrade</span><br></pre></td></tr></table></figure>\n</li>\n<li>删除软件包：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt remove httpd</span><br></pre></td></tr></table></figure>\n</li>\n<li>删除软件包并清除配置文件：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt purge httpd</span><br></pre></td></tr></table></figure>\n</li>\n<li>查找软件包：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt search firewall</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示软件包信息：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt show httpd</span><br></pre></td></tr></table></figure>\n</li>\n<li>清理缓存：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt clean</span><br></pre></td></tr></table></figure>\n</li>\n<li>自动清理旧的缓存：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt autoclean</span><br></pre></td></tr></table></figure>\n</li>\n<li>卸载不再需要的自动安装的软件包：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt autoremove</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>在执行任何涉及系统软件变更的操作前，最好先运行 sudo apt update 来确保本地包索引是最新的。</li>\n<li>对于大型软件包或者多个软件包的安装，可以考虑使用 apt install package1 package2 来一次性安装多个软件包。</li>\n<li>当遇到依赖问题时，可以尝试使用 --no-install-recommends 选项来忽略推荐的软件包，但这可能会导致缺少某些功能。</li>\n<li>避免在生产环境中直接使用 apt upgrade 而不检查更新的内容，以防意外升级导致兼容性问题。</li>\n<li>如果遇到软件包冲突或依赖问题，可以使用 apt policy <package> 查看当前的状态，并使用 apt install --fix-broken 来尝试修复。</li>\n<li>对于重要的系统更新，建议先阅读官方文档或发行说明，了解可能的影响。</li>\n</ul>\n<h4 id=\"yum-命令centosrhel\"><a class=\"markdownIt-Anchor\" href=\"#yum-命令centosrhel\">#</a> yum 命令（CentOS/RHEL）</h4>\n<p>yum (Yellowdog Updater Modified) 是一个在 Fedora 和 Red Hat 系统上常用的包管理器，用于安装、更新和删除软件包。它通过仓库来获取软件包，并且可以自动处理依赖关系。</p>\n<p>基本语法： <code>yum [选项] [命令] [参数]</code></p>\n<p>参数与选项</p>\n<ul>\n<li>install: 安装指定的软件包。</li>\n<li>update: 更新已安装的软件包到最新版本。</li>\n<li>remove: 卸载指定的软件包。</li>\n<li>list: 列出可用的软件包。</li>\n<li>info: 显示软件包的详细信息。</li>\n<li>clean: 清除缓存目录下的软件包。</li>\n<li>search: 搜索软件仓库中符合关键字的所有软件包。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>安装软件包<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install httpd</span><br></pre></td></tr></table></figure>\n</li>\n<li>更新所有已安装的软件包：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum update</span><br></pre></td></tr></table></figure>\n</li>\n<li>删除软件包：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum remove httpd</span><br></pre></td></tr></table></figure>\n</li>\n<li>查找软件包：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum search firewall</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示软件包信息：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum info httpd</span><br></pre></td></tr></table></figure>\n</li>\n<li>清理缓存：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum clean all</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>使用 yum 前，请确保已经配置了正确的仓库文件。这些文件通常位于 /etc/yum.repos.d/ 目录下。</li>\n<li>在执行任何涉及系统软件变更的操作前，最好先运行 sudo yum update 来确保系统是最新的。</li>\n<li>当遇到依赖问题时，可以尝试使用 --setopt=tsflags=nodocs 选项来忽略文档包，但这可能会导致缺少文档。</li>\n<li>避免在生产环境中直接使用 yum update 而不检查更新的内容，以防意外升级导致兼容性问题。</li>\n<li>对于大型软件包或者多个软件包的安装，考虑使用 yum groupinstall “Development Tools” 这样的组安装命令来简化流程。</li>\n</ul>\n<h4 id=\"rpm-命令centosrhel\"><a class=\"markdownIt-Anchor\" href=\"#rpm-命令centosrhel\">#</a> rpm 命令（CentOS/RHEL）</h4>\n<p>rpm (Red Hat Package Manager) 是一个广泛使用的包管理工具，主要用于基于 RPM 的 Linux 发行版（如 Red Hat、Fedora、CentOS<br>\n 等）。它支持安装、更新、删除软件包，并能处理依赖关系。</p>\n<p>基本语法： <code>rpm [选项] [命令] [参数]</code></p>\n<p>参数与选项</p>\n<ul>\n<li>-i: 安装指定的软件包。</li>\n<li>-U: 更新已安装的软件包。</li>\n<li>-F: 更新已安装的软件包（仅当现有包版本较旧时才更新）。</li>\n<li>-e: 卸载指定的软件包。</li>\n<li>-q: 查询已安装的软件包。</li>\n<li>-qp: 显示未安装的软件包信息。</li>\n<li>-V: 验证已安装的软件包。</li>\n<li>-qa: 列出所有已安装的软件包。</li>\n<li>-ql: 列出已安装软件包的文件列表。</li>\n<li>-qi: 显示已安装软件包的详细信息。</li>\n<li>-qc: 显示已安装软件包的配置文件列表。</li>\n<li>-qd: 显示已安装软件包的文档文件列表。</li>\n<li>-qf: 根据文件路径查询所属的软件包。</li>\n<li>-qs: 显示已安装软件包的状态信息。</li>\n</ul>\n<p>示例</p>\n<ul>\n<li>安装软件包：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rpm -i httpd.rpm</span><br></pre></td></tr></table></figure>\n</li>\n<li>更新软件包：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rpm -U httpd.rpm</span><br></pre></td></tr></table></figure>\n</li>\n<li>更新软件包（仅当现有版本较旧时）：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rpm -F httpd.rpm</span><br></pre></td></tr></table></figure>\n</li>\n<li>删除软件包：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rpm -e httpd</span><br></pre></td></tr></table></figure>\n</li>\n<li>查询已安装的软件包：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -q httpd</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示未安装的软件包信息：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -qp httpd.rpm</span><br></pre></td></tr></table></figure>\n</li>\n<li>验证已安装的软件包：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -V httpd</span><br></pre></td></tr></table></figure>\n</li>\n<li>列出所有已安装的软件包：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -qa</span><br></pre></td></tr></table></figure>\n</li>\n<li>列出已安装软件包的文件列表：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ql httpd</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示已安装软件包的详细信息：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -qi httpd</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示已安装软件包的配置文件列表：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -qc httpd</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示已安装软件包的文档文件列表：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -qd httpd</span><br></pre></td></tr></table></figure>\n</li>\n<li>根据文件路径查询所属的软件包：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -qf /etc/httpd/conf/httpd.conf</span><br></pre></td></tr></table></figure>\n</li>\n<li>显示已安装软件包的状态信息：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -qs httpd</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>在安装或更新软件包之前，最好先确认软件包的来源可靠，避免安装恶意软件。</li>\n<li>使用 rpm -i 或 rpm -U 时，如果遇到依赖问题，可以尝试使用 rpm -ivh --nodeps 强制安装，但这可能会导致系统不稳定。</li>\n<li>在删除软件包之前，最好先用 rpm -ql 查看该软件包包含的文件，确保不会误删重要文件。</li>\n<li>如果遇到依赖问题，可以使用 rpm -qa | grep <pattern> 来查找相关软件包，并尝试手动解决依赖问题。</li>\n<li>对于复杂的依赖问题，可以考虑使用 yum 或 dnf 这样的高级包管理器来自动解决依赖关系。</li>\n<li>在安装新软件包时，建议先用 rpm -qp --verify 检查软件包的完整性。</li>\n</ul>\n<h4 id=\"dnf-命令fedora补充\"><a class=\"markdownIt-Anchor\" href=\"#dnf-命令fedora补充\">#</a> dnf 命令（Fedora）补充</h4>\n<h4 id=\"pacman-命令arch-linux补充\"><a class=\"markdownIt-Anchor\" href=\"#pacman-命令arch-linux补充\">#</a> pacman 命令（Arch Linux）补充</h4>\n",
            "tags": [
                "后端",
                "操作系统",
                "Linux"
            ]
        },
        {
            "id": "https://silvercrow42.github.io/joker.github.io/2024/09/24/%E3%80%90Zookeeper%E3%80%91Zookeeper%E8%AF%A6%E8%A7%A3/",
            "url": "https://silvercrow42.github.io/joker.github.io/2024/09/24/%E3%80%90Zookeeper%E3%80%91Zookeeper%E8%AF%A6%E8%A7%A3/",
            "title": "【Zookeeper】Zookeeper详解",
            "date_published": "2024-09-24T03:39:53.000Z",
            "content_html": "<h2 id=\"什么是zookeeper\"><a class=\"markdownIt-Anchor\" href=\"#什么是zookeeper\">#</a> 什么是 Zookeeper</h2>\n<p>Zookeeper 是一个开源的主动协调服务，用于分布式应用程序，提供了诸如配置维护、域名服务、分布式同步、组服务等功能。它是一个为分布式应用提供一致性服务的软件，其内部使用了一种称为<br>\n Zab 的协议（在选举过程中使用 Paxos 协议）来保证分布式环境中不同节点之间的数据一致性。</p>\n<p>Zookeeper 的主要特点包括：</p>\n<ul>\n<li>高可用性：Zookeeper 可以构建为集群模式，通过多数派存活原则来保证服务的高可用性。</li>\n<li>顺序一致性：客户端请求按照发起顺序进行处理。</li>\n<li>原子性：所有事务要么全部成功，要么全部失败。</li>\n<li>单一视图：无论客户端连接到集群中的哪个服务器，看到的服务视图都是一样的。</li>\n<li>可靠性：一旦一个更新被应用并确认，该更新将一直有效，即使此时 Zookeeper 发生故障。</li>\n</ul>\n<p>Zookeeper 的应用场景：</p>\n<ul>\n<li>\n<p>数据发布与订阅</p>\n<p>顾名思义就是将数据发布到 ZooKeeper 节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，地址列表等就非常适合使用。<br>\n数据发布 / 订阅的一个常见的场景是配置中心，发布者把数据发布到 ZooKeeper 的一个或一系列的节点上，供订阅者进行数据订阅，达到动态获取数据的目的。<br>\n配置信息一般有几个特点:</p>\n<ol>\n<li>数据量小的 KV</li>\n<li>数据内容在运行时会发生动态变化</li>\n<li>集群机器共享，配置一致</li>\n</ol>\n<p>ZooKeeper 采用的是推拉结合的方式。</p>\n<ol>\n<li>推：服务端会推给注册了监控节点的客户端 Wathcer 事件通知</li>\n<li>拉：客户端获得通知后，然后主动到服务端拉取最新的数据</li>\n</ol>\n</li>\n<li>\n<p>命名服务</p>\n<p>作为分布式命名服务，命名服务是指通过指定的名字来获取资源或者服务的地址，利用 ZooKeeper 创建一个全局的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。统一命名服务的命名结构图如下所示：</p>\n<ol>\n<li>在分布式环境下，经常需要对应用 / 服务进行统一命名，便于识别不同服务。类似于域名与 IP 之间对应关系，IP 不容易记住，而域名容易记住。通过名称来获取资源或服务的地址，提供者等信息。</li>\n<li>按照层次结构组织服务 / 应用名称。可将服务名称以及地址信息写到 ZooKeeper 上，客户端通过 ZooKeeper 获取可用服务列表类。</li>\n</ol>\n</li>\n<li>\n<p>分布式锁</p>\n<p>处于不同节点上不同的服务，它们可能需要顺序的访问一些资源，这里需要一把分布式的锁。<br>\n分布式锁具有以下特性：写锁、读锁、时序锁。</p>\n<ul>\n<li>写锁：在 zk 上创建的一个临时的无编号的节点。由于是无序编号，在创建时不会自动编号，导致只能客户端有一个客户端得到锁，然后进行写入。</li>\n<li>读锁：在 zk 上创建一个临时的有编号的节点，这样即使下次有客户端加入是同时创建相同的节点时，他也会自动编号，也可以获得锁对象，然后对其进行读取。</li>\n<li>时序锁：在 zk 上创建的一个临时的有编号的节点根据编号的大小控制锁。</li>\n</ul>\n</li>\n<li>\n<p>集群管理</p>\n<p>所谓集群管理就是：是否有机器退出和加入、选举 master。<br>\n集群管理主要指集群监控和集群控制两个方面。前者侧重于集群运行时的状态的收集，后者则是对集群进行操作与控制。开发和运维中，面对集群，经常有如下需求:</p>\n<ol>\n<li>希望知道集群中究竟有多少机器在工作</li>\n<li>对集群中的每台机器的运行时状态进行数据收集</li>\n<li>对集群中机器进行上下线的操作</li>\n</ol>\n<p>集群管理结构如下所示：</p>\n<ol>\n<li>\n<p>分布式环境中，实时掌握每个节点的状态是必要的，可根据节点实时状态做出一些调整。</p>\n</li>\n<li>\n<p>可交由 ZooKeeper 实现。<br>\n可将节点信息写入 ZooKeeper 上的一个 Znode。<br>\n监听这个 Znode 可获取它的实时状态变化。</p>\n</li>\n<li>\n<p>典型应用</p>\n<p>Hbase 中 Master 状态监控与选举。<br>\n利用 ZooKeeper 的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建<br>\n /currentMaster<br>\n 节点，最终一定只有一个客户端请求能够创建成功</p>\n</li>\n</ol>\n</li>\n<li>\n<p>分布式通知与协调</p>\n<ol>\n<li>分布式环境中，经常存在一个服务需要知道它所管理的子服务的状态。\n<ol>\n<li>NameNode 需知道各个 Datanode 的状态。</li>\n<li>JobTracker 需知道各个 TaskTracker 的状态。</li>\n</ol>\n</li>\n<li>心跳检测机制可通过 ZooKeeper 来实现。</li>\n<li>信息推送可由 ZooKeeper 来实现，ZooKeeper 相当于一个发布 / 订阅系统。</li>\n</ol>\n</li>\n<li>\n<p>分布式队列管理</p>\n<p>分布式队列分为两种：</p>\n<ol>\n<li>当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。\n<ol>\n<li>一个 job 由多个 task 组成，只有所有任务完成后，job 才运行完成。</li>\n<li>可为 job 创建一个 /job 目录，然后在该目录下，为每个完成的 task 创建一个临时的 Znode，一旦临时节点数目达到 task 总数，则表明 job 运行完成。</li>\n</ol>\n</li>\n<li>队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"znode\"><a class=\"markdownIt-Anchor\" href=\"#znode\">#</a> Znode</h2>\n<p>Znode 是 Zookeeper 中的基本数据结构，用于存储数据和组织数据结构。<br>\n每个 Znode 都有一个唯一的路径，路径类似于文件系统的路径，以 / 开头。</p>\n<p>Znode 的属性</p>\n<ul>\n<li>数据内容：\n<ul>\n<li>data：Znode 存储的数据内容，最大为 1MB。</li>\n</ul>\n</li>\n<li>ACL（Access Control List）：\n<ul>\n<li>权限控制列表：定义了对 Znode 的访问权限，包括读、写、创建子节点等权限。</li>\n</ul>\n</li>\n<li>版本信息：\n<ul>\n<li>version：Znode 的版本号，用于数据一致性检查。</li>\n<li>cversion：子节点的版本号。</li>\n<li>aversion：ACL 的版本号。</li>\n</ul>\n</li>\n<li>时间戳：\n<ul>\n<li>ctime：创建时间。</li>\n<li>mtime：最后修改时间。</li>\n</ul>\n</li>\n<li>子节点：\n<ul>\n<li>children：Znode 可以拥有子节点，形成树状结构。</li>\n</ul>\n</li>\n</ul>\n<p>Znode 的类型包括：</p>\n<ol>\n<li>\n<p>持久节点（Persistent）：持久节点在 ZooKeeper 服务器重启后不会丢失，除非显式删除。Java 创建示例如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zookeeper.create(<span class=\"string\">&quot;/path&quot;</span>, data, acl, CreateMode.PERSISTENT);</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>临时节点（Ephemeral）：创建后，如果创建该节点的客户端会话断开，则自动删除。且其不能有子节点。Java 创建示例如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zookeeper.create(<span class=\"string\">&quot;/path&quot;</span>, data, acl, CreateMode.EPHEMERAL);</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>顺序节点（Sequential）：</p>\n<ul>\n<li>\n<p>顺序节点在创建时自动获得一个唯一的序号，用于排序。例如，如果路径为 /path，创建的第一个顺序节点可能是<br>\n /path00000001。</p>\n</li>\n<li>\n<p>顺序节点也包含持久节点和临时节点两种持久化类型。</p>\n</li>\n</ul>\n<p>通过 Java 创建一个路径为 &quot;/path&quot; 的持久顺序节点示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zookeeper.create(<span class=\"string\">&quot;/path&quot;</span>, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>默认情况下创建的 Znode 为持久节点类型。</p>\n<p>注意事项：</p>\n<ol>\n<li>创建节点时，必须要带上全路径。</li>\n<li>创建节点时，如果父节点不存在，ZooKeeper 会自动创建父节点。</li>\n<li>同一级节点 key 名称是唯一的。</li>\n<li>delete 命令只能一层一层删除，不能删除一个节点下的所有子节点。新版本可以通过 deleteall 命令递归删除。</li>\n</ol>\n<h2 id=\"watch机制\"><a class=\"markdownIt-Anchor\" href=\"#watch机制\">#</a> Watch 机制</h2>\n<h3 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\">#</a> 概述</h3>\n<p>ZooKeeper 的 watch 机制是一种非常重要的特性，用于实现实时监控 ZooKeeper 中的数据变化。<br>\n在 Spring Cloud 应用中，可以通过 Curator 框架结合 Spring Boot 来实现对 ZooKeeper 数据的监控。</p>\n<p><strong>基本概念</strong></p>\n<ul>\n<li>Watch：一种一次性触发的通知机制。</li>\n<li>Watcher：客户端注册的监听器，用于接收 ZooKeeper 的通知。</li>\n</ul>\n<p><strong>工作原理</strong></p>\n<ul>\n<li>注册 Watcher：客户端在执行某些操作（如获取节点数据、获取子节点列表等）时，可以注册一个 Watcher。</li>\n<li>触发 Watcher：当节点数据或子节点列表发生变化时，ZooKeeper 会触发相应的 Watcher。</li>\n<li>处理事件：客户端在收到 Watcher 触发的通知后，可以处理相应的事件，并重新注册 Watcher。</li>\n</ul>\n<p><strong>事件类型</strong></p>\n<ul>\n<li>NodeCreatedEvent：节点创建事件。</li>\n<li>NodeDeletedEvent：节点删除事件。</li>\n<li>NodeDataChangedEvent：节点数据变化事件。</li>\n<li>NodeChildrenChangedEvent：子节点列表变化事件。</li>\n</ul>\n<p><strong>使用场景</strong></p>\n<ul>\n<li>配置管理：在分布式系统中，配置管理需要实时监控配置的变化，以保持配置的实时一致性。</li>\n<li>监控服务：在分布式系统中，需要实时监控服务的状态，以确定服务的可用性。</li>\n<li>负载均衡：在分布式系统中，需要根据负载情况动态调整服务实例的数量，以实现负载均衡。</li>\n</ul>\n<h3 id=\"在-spring-cloud-应用中的使用方法\"><a class=\"markdownIt-Anchor\" href=\"#在-spring-cloud-应用中的使用方法\">#</a> 在 Spring Cloud 应用中的使用方法</h3>\n<h4 id=\"curator\"><a class=\"markdownIt-Anchor\" href=\"#curator\">#</a> Curator</h4>\n<p>Curator 框架提供了简化 ZooKeeper 使用的 API，使得注册和处理 Watcher 更加方便。</p>\n<ol>\n<li>\n<p>创建 Curator 客户端</p>\n<p>在 Spring Boot 应用中，可以通过配置 Curator 客户端来管理 ZooKeeper 连接。</p>\n <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">curator:</span></span><br><span class=\"line\">    <span class=\"attr\">connect-string:</span> <span class=\"string\">localhost:2181</span></span><br><span class=\"line\">    <span class=\"attr\">session-timeout-ms:</span> <span class=\"number\">5000</span></span><br><span class=\"line\">    <span class=\"attr\">connection-timeout-ms:</span> <span class=\"number\">3000</span></span><br><span class=\"line\">    <span class=\"attr\">retry-policy:</span></span><br><span class=\"line\">      <span class=\"attr\">base-sleep-time-ms:</span> <span class=\"number\">1000</span></span><br><span class=\"line\">      <span class=\"attr\">max-retries:</span> <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>配置 Curator 客户端</p>\n<p>在 Spring Boot 应用中，可以通过 @Configuration 类来配置 Curator 客户端。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.curator.RetryPolicy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CuratorConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CuratorFramework <span class=\"title function_\">curatorFramework</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RetryPolicy</span> <span class=\"variable\">retryPolicy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExponentialBackoffRetry</span>(<span class=\"number\">1000</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"type\">CuratorFramework</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> CuratorFrameworkFactory.builder()</span><br><span class=\"line\">                .connectString(<span class=\"string\">&quot;localhost:2181&quot;</span>)</span><br><span class=\"line\">                .sessionTimeoutMs(<span class=\"number\">5000</span>)</span><br><span class=\"line\">                .connectionTimeoutMs(<span class=\"number\">3000</span>)</span><br><span class=\"line\">                .retryPolicy(retryPolicy)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">        client.start();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> client;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>注册 Watcher</p>\n<p>在 Spring Boot 应用中，可以通过 Curator 框架提供的 NodeCache 和 PathChildrenCache 来注册 Watcher。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.curator.framework.api.ACLProvider;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.curator.framework.recipes.cache.ChildData;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.curator.framework.recipes.cache.NodeCache;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.curator.framework.recipes.cache.NodeCacheListener;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.curator.framework.recipes.cache.PathChildrenCache;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.curator.utils.CloseableUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.zookeeper.CreateMode;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.zookeeper.Watcher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WatcherService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CuratorFramework curatorFramework;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">watchNodeData</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">NodeCache</span> <span class=\"variable\">nodeCache</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NodeCache</span>(curatorFramework, <span class=\"string\">&quot;/testNode&quot;</span>);</span><br><span class=\"line\">        nodeCache.getListenable().addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">NodeCacheListener</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">nodeChanged</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                <span class=\"type\">ChildData</span> <span class=\"variable\">currentData</span> <span class=\"operator\">=</span> nodeCache.getCurrentData();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (currentData != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;Node data changed: &quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(currentData.getData()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        nodeCache.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">watchChildrenChanges</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">PathChildrenCache</span> <span class=\"variable\">childrenCache</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PathChildrenCache</span>(curatorFramework, <span class=\"string\">&quot;/testNode&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        childrenCache.getListenable().addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">PathChildrenCacheListener</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">childEvent</span><span class=\"params\">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (event.getType()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> CHILD_ADDED:</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;Child added: &quot;</span> + event.getData().getPath());</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> CHILD_UPDATED:</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;Child updated: &quot;</span> + event.getData().getPath());</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> CHILD_REMOVED:</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;Child removed: &quot;</span> + event.getData().getPath());</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;Unknown event type: &quot;</span> + event.getType());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        childrenCache.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"zookeeper-命令\"><a class=\"markdownIt-Anchor\" href=\"#zookeeper-命令\">#</a> Zookeeper 命令</h2>\n<ol>\n<li>ls: 列出指定节点下的所有子节点。 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls /path/to/node</span><br></pre></td></tr></table></figure>\n</li>\n<li>get: 获取指定节点的数据以及其状态信息。 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get /path/to/node</span><br></pre></td></tr></table></figure>\n</li>\n<li>set: 设置指定节点的数据。 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set /path/to/node new_data</span><br></pre></td></tr></table></figure>\n</li>\n<li>create: 创建一个新的节点，并可以设置节点的权限和类型（持久化或临时）。 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create /path/to/new_node data [acl] [flags]</span><br></pre></td></tr></table></figure>\n其中 [acl] 表示访问控制列表，[flags] 可以是 0（持久化节点）或 1（临时节点）。</li>\n<li>delete: 删除指定的节点。 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete /path/to/node</span><br></pre></td></tr></table></figure>\n</li>\n<li>stat: 获取指定节点的状态信息。 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls /path/to/node</span><br></pre></td></tr></table></figure>\n</li>\n<li>rmr: 递归删除一个节点及其所有的子节点。 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rmr /path/to/node</span><br></pre></td></tr></table></figure>\n</li>\n<li>sync: 强制同步节点到所有服务器。 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sync /path/to/node</span><br></pre></td></tr></table></figure>\n</li>\n<li>close: 关闭当前客户端连接。 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">close</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"zookeeper集群\"><a class=\"markdownIt-Anchor\" href=\"#zookeeper集群\">#</a> Zookeeper 集群</h2>\n<p>Zookeeper 集群是一种分布式协调服务，主要用于解决分布式系统中的一致性问题。它通过一组服务器组成集群，共同维护一个高度一致的状态。</p>\n<p>Zookeeper 集群的组成和角色如下：</p>\n<ol>\n<li>\n<p>领导者（Leader）：</p>\n<p>Leader 是 Zookeeper 集群中的核心角色，负责处理客户端请求并协调其他服务器的状态。</p>\n<ul>\n<li>处理客户端请求：\n<ul>\n<li>Leader 负责接收客户端的所有读写请求，并处理这些请求。</li>\n<li>对于读请求，Leader 可以直接返回结果。</li>\n<li>对于写请求，Leader 会广播给所有 Follower 和 Observer。</li>\n</ul>\n</li>\n<li>数据同步：\n<ul>\n<li>Leader 负责将写请求广播给所有的 Follower，并确保所有 Follower 都正确地执行了写操作。</li>\n<li>Leader 通过事务日志（transaction log）和快照（snapshot）来保证数据的一致性。</li>\n</ul>\n</li>\n<li>选举协调：\n<ul>\n<li>当集群中出现故障或需要重新选举时，Leader 负责协调选举过程。</li>\n<li>Leader 通过投票机制来确定新的 Leader。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>跟随者（Follower）：</p>\n<p>Follower 是 Zookeeper 集群中的重要角色之一，负责接收客户端请求并将请求转发给 Leader。</p>\n<ul>\n<li>接收客户端请求：\n<ul>\n<li>Follower 可以接收客户端的请求，并将请求转发给 Leader。</li>\n<li>Follower 也可以直接处理客户端的读请求。</li>\n</ul>\n</li>\n<li>数据同步：\n<ul>\n<li>Follower 负责同步 Leader 的状态。</li>\n<li>当 Leader 发送写请求时，Follower 会执行相同的写操作，并确认操作完成。</li>\n</ul>\n</li>\n<li>选举参与：\n<ul>\n<li>Follower 参与选举过程，通过投票机制选举新的 Leader。</li>\n<li>当集群中出现故障时，Follower 会参与重新选举。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>观察者（Observer）：</p>\n<p>Observer 是 Zookeeper 集群中的辅助角色，主要用于提高集群的吞吐量。</p>\n<ul>\n<li>接收客户端请求：\n<ul>\n<li>Observer 可以接收客户端的请求，并将请求转发给 Leader。</li>\n<li>Observer 不参与选举过程，因此不会影响选举的结果。</li>\n</ul>\n</li>\n<li>数据同步：\n<ul>\n<li>Observer 负责同步 Leader 的状态。</li>\n<li>当 Leader 发送写请求时，Observer 会执行相同的写操作，并确认操作完成。</li>\n</ul>\n</li>\n<li>提高吞吐量：\n<ul>\n<li>Observer 可以接收更多的客户端请求，从而提高集群的整体吞吐量。</li>\n<li>Observer 不参与选举过程，因此不会增加选举的复杂度。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>数据一致性：Zookeeper 通过 ZAB 算法保证数据的一致性。</p>\n<ul>\n<li>事务日志：\n<ul>\n<li>每个服务器都会记录事务日志（transaction log），确保数据的一致性。</li>\n<li>在选举过程中，Leader 会根据事务日志同步其他服务器的状态。</li>\n</ul>\n</li>\n<li>快照：\n<ul>\n<li>定期生成快照（snapshot），减少事务日志的大小，提高性能。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"zookeeper集群的读写流程\"><a class=\"markdownIt-Anchor\" href=\"#zookeeper集群的读写流程\">#</a> Zookeeper 集群的读写流程</h3>\n<p>Zookeeper 单机均遵循先写磁盘后写内存的写入模式，能够确保数据一致性。<br>\n在集群模式下，当客户端向 Zookeeper 发送一个数据变更请求时，请求首先到达 Leader 节点。以下是详细的流程：</p>\n<ol>\n<li>写入事务日志\n<ol>\n<li>Leader 收到变更请求：\n<ul>\n<li>Leader 节点首先接收到客户端发送的数据变更请求。</li>\n</ul>\n</li>\n<li>生成事务记录：\n<ul>\n<li>Leader 节点生成一条事务记录，这条记录包含了变更请求的所有细节，例如操作类型（创建、删除、更新）、节点路径、数据等。</li>\n</ul>\n</li>\n<li>写入事务日志：\n<ul>\n<li>Leader 节点将这条事务记录写入事务日志文件中。事务日志文件通常位于磁盘上，以确保数据的持久性。</li>\n<li>事务日志文件通常以 .log 或 .txn 结尾。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>写入内存\n<ol>\n<li>应用变更到内存：\n<ul>\n<li>在事务日志写入完成后，Leader 节点将变更请求应用到内存中的数据树。</li>\n<li>这一步确保了数据的一致性和实时性。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>广播变更请求\n<ol>\n<li>广播变更请求：\n<ul>\n<li>Leader 节点将变更请求广播给所有 Follower 节点。</li>\n<li>Follower 节点接收到变更请求后，同样先写入事务日志，再写入内存。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>确认变更\n<ol>\n<li>Follower 处理变更：\n<ul>\n<li>每个 Follower 节点接收到变更请求后，先将其写入自己的事务日志文件中，然后再应用到内存中的数据树。</li>\n</ul>\n</li>\n<li>多数确认：\n<ul>\n<li>当大多数 Follower 节点确认收到并处理完变更请求后，Leader 节点认为变更成功。</li>\n<li>这一步确保了数据的一致性和可靠性。</li>\n</ul>\n</li>\n<li>返回结果：\n<ul>\n<li>Leader 节点将变更成功的消息返回给客户端。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"zookeeper集群的选举机制\"><a class=\"markdownIt-Anchor\" href=\"#zookeeper集群的选举机制\">#</a> Zookeeper 集群的选举机制</h3>\n<p>Zookeeper 的选举机制基于 Fast Leader Election (FLE) 算法，确保在一个分布式环境中快速且正确地选出领导者。</p>\n<p>Zookeeper 集群中的选举机制通常在以下几种情况下被触发：</p>\n<ul>\n<li>初始启动：当集群中的所有服务器首次启动时，它们需要选举出一个 Leader。</li>\n<li>Leader 故障：当当前的 Leader 发生故障（如宕机或网络分区）时，需要重新选举新的 Leader。</li>\n<li>Leader 步骤落后：当 Leader 的步骤落后于其他服务器时，可能需要重新选举新的 Leader。</li>\n</ul>\n<p>在进行 Zookeeper 集群中，进行选举的节点具有以下状态：</p>\n<ul>\n<li>LOOKING\n<ul>\n<li>定义：节点处于寻找领导者的状态。</li>\n<li>行为：节点会发起投票，并接收来自其他节点的投票信息。一旦收集到足够的投票信息，它会尝试成为领导者或者选择一个合适的领导者。</li>\n</ul>\n</li>\n<li>LEADING\n<ul>\n<li>定义：节点成为领导者。</li>\n<li>行为：负责协调集群中的所有事务操作，并向其他节点发送心跳信息以维持集群的一致性。</li>\n</ul>\n</li>\n<li>FOLLOWING\n<ul>\n<li>定义：节点作为跟随者。</li>\n<li>行为：接收领导者的心跳信息和指令，并执行相应的操作。</li>\n</ul>\n</li>\n<li>OBSERVING\n<ul>\n<li>定义：节点作为观察者。</li>\n<li>行为：观察者可以参与投票过程，但不参与决策制定。观察者主要用于扩展集群的读取能力。</li>\n</ul>\n</li>\n</ul>\n<p>在 ZooKeeper 的选举过程中，投票信息通常包含一个五元组，用于描述候选节点的状态和其他相关信息。这个五元组包括以下五个元素：</p>\n<ul>\n<li>epoch（纪元号）\n<ul>\n<li>定义：纪元号（epoch）是一个整数，用于标识选举周期。每次选举都会有一个新的纪元号。</li>\n<li>作用：纪元号用于区分不同的选举周期，防止旧的投票信息影响新的选举。</li>\n</ul>\n</li>\n<li>zxid（事务 ID）\n<ul>\n<li>定义：事务 ID（zxid）是一个 64 位的整数，用于标识事务的唯一性。</li>\n<li>组成：zxid 由两部分组成：高 32 位是纪元号（epoch），低 32 位是事务编号（transaction number）。</li>\n<li>作用：用于确定哪个节点具有最新的事务信息。</li>\n</ul>\n</li>\n<li>peerId（节点 ID）\n<ul>\n<li>定义：节点 ID（peerId）是一个唯一的标识符，用于标识集群中的每个节点。</li>\n<li>作用：用于识别投票来自哪个节点。</li>\n</ul>\n</li>\n<li>leaderId（Leader ID）\n<ul>\n<li>定义：Leader ID（leaderId）是一个标识符，用于标识当前投票支持的候选 Leader。</li>\n<li>作用：用于确定哪个节点被投票支持作为新的 Leader。</li>\n</ul>\n</li>\n<li>type（投票类型）\n<ul>\n<li>定义：投票类型（type）是一个标识符，用于描述当前投票的类型。</li>\n<li>作用：用于区分不同类型的投票，如 LOOKING、LEADING 或 LEADER。</li>\n</ul>\n</li>\n</ul>\n<p>参与运算的关键变量</p>\n<ul>\n<li>myid\n<ul>\n<li>定义：每个节点的唯一标识符。</li>\n<li>作用：用于区分不同的节点，在选举过程中用于投票。</li>\n</ul>\n</li>\n<li>zxid\n<ul>\n<li>定义：事务 ID，表示最后一次提交的事务编号。</li>\n<li>作用：用于判断节点的状态是否最新。具有更大 zxid 的节点被认为是更 “新” 的节点。</li>\n</ul>\n</li>\n<li>epoch\n<ul>\n<li>定义：选举轮次。</li>\n<li>作用：防止过期的投票信息干扰当前的选举过程。每次选举开始时，epoch 增加。</li>\n</ul>\n</li>\n<li>peerState\n<ul>\n<li>定义：节点的当前状态。</li>\n<li>作用：记录节点当前处于哪种状态（LOOKING, LEADING, FOLLOWING, OBSERVING）。</li>\n</ul>\n</li>\n<li>votesReceived\n<ul>\n<li>定义：节点接收到的投票数量。</li>\n<li>作用：用于统计当前节点是否获得了大多数投票。</li>\n</ul>\n</li>\n<li>lastVote\n<ul>\n<li>定义：节点上一次投票的对象。</li>\n<li>作用：记录上一次投票的对象，避免重复投票。</li>\n</ul>\n</li>\n<li>electionType\n<ul>\n<li>定义：选举类型（例如普通选举或重新选举）。</li>\n<li>作用：用于区分不同类型的选举过程。</li>\n</ul>\n</li>\n</ul>\n<p>详细流程</p>\n<ol>\n<li>初始化状态：当一个节点启动时，它会进入 LOOKING 状态。这意味着它正在寻找或试图成为领导者。</li>\n<li>初始化投票：每个节点在启动时会给自己投一票，并将投票信息（包括 myid 和 zxid）发送给集群中的其他节点。</li>\n<li>接收投票信息：节点会接收到其他节点的投票信息。</li>\n<li>比较和更新投票\n<ol>\n<li>比较 epoch：节点会比较接收到的投票信息中的 epoch 和自己的 epoch。\n<ul>\n<li>当接收到的 epoch 大于自己的 epoch，则更新自己的 epoch，并将新的投票信息再次发送给集群中的所有节点，防止投票过期。</li>\n</ul>\n</li>\n<li>比较 zxid：节点会比较接收到的投票信息中的 zxid 和自己的 zxid。\n<ul>\n<li>如果接收到的投票信息中的 zxid 大于自己的 zxid，则更新自己的投票信息，并将新的投票信息再次发送给集群中的所有节点。</li>\n<li>如果接收到的投票信息中的 zxid 等于自己的 zxid，则比较 myid。\n<ul>\n<li>如果接收到的投票信息中的 myid 大于自己的 myid，则更新自己的投票信息，并将新的投票信息再次发送给集群中的所有节点。</li>\n<li>如果接收到的投票信息中的 myid 小于自己的 myid，则保持当前的投票信息不变。</li>\n</ul>\n</li>\n<li>如果接收到的投票信息中的 zxid 小于自己的 zxid，则保持当前的投票信息不变。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>统计投票结果：每个节点会统计接收到的投票信息。如果一个特定的节点得到了大多数（超过半数）的投票，那么这个节点就被认为是领导者。\n<ul>\n<li>大多数投票：对于奇数个节点的集群，大多数意味着 (N + 1) / 2；对于偶数个节点，则需要 N / 2 + 1 才能构成大多数。</li>\n</ul>\n</li>\n<li>领导者确认：成功获得大多数投票的节点会向集群广播它的领导者身份。<br>\n其他节点接收到这条消息后，会切换到 FOLLOWING 状态，并开始跟随新的领导者。</li>\n<li>故障转移：如果当前的领导者失效了，跟随者会重新进入 LOOKING 状态并开始新一轮的选举。</li>\n</ol>\n<p>示例流程</p>\n<p>假设有一个 Zookeeper 集群，包含三个节点 A、B 和 C：</p>\n<ol>\n<li>初始化状态：A、B 和 C 都进入 LOOKING 状态。</li>\n<li>投票：A、B 和 C 各自给自己投一票，并将投票信息发送给其他节点。假设\n<ul>\n<li>A 的 zxid 是 100。</li>\n<li>B 的 zxid 是 90。</li>\n<li>C 的 zxid 是 110。</li>\n</ul>\n</li>\n<li>接收投票：\n<ul>\n<li>A 收到 B 和 C 的投票信息。</li>\n<li>B 收到 A 和 C 的投票信息。</li>\n<li>C 收到 A 和 B 的投票信息。</li>\n</ul>\n</li>\n<li>比较和更新投票：\n<ul>\n<li>A 发现 C 的 zxid 更大，更新自己的投票信息，并重新发送投票给 B 和 C。</li>\n<li>B 发现 C 的 zxid 更大，更新自己的投票信息，并重新发送投票给 A 和 C。</li>\n<li>C 发现自己的 zxid 最大，保持投票信息不变。</li>\n</ul>\n</li>\n<li>统计投票结果：C 收到 A 和 B 的投票，统计后发现自己的投票数达到 2（超过半数）。</li>\n<li>领导者确认：\n<ul>\n<li>C 向 A 和 B 广播自己成为领导者的信息。</li>\n<li>A 和 B 收到消息后，切换到 FOLLOWING 状态。</li>\n</ul>\n</li>\n<li>故障转移：如果 C 故障，A 和 B 重新进入 LOOKING 状态，重复上述流程。</li>\n</ol>\n<h3 id=\"zookeeper的数据同步机制\"><a class=\"markdownIt-Anchor\" href=\"#zookeeper的数据同步机制\">#</a> Zookeeper 的数据同步机制</h3>\n<p>Zookeeper 使用 ZAB（Zookeeper Atomic Broadcast）协议来保证数据的一致性和高可用性。</p>\n<p>在集群中已经选举出 Leader 后，集群中的其他服务器会通过以下步骤与 Leader 保持同步：</p>\n<ol>\n<li>\n<p>状态同步</p>\n<ul>\n<li>新领导者确定事务状态：新领导者需要确定哪些事务应该保留，哪些事务应该撤销。</li>\n<li>事务日志检查：新领导者检查所有节点的事务日志，找出最新的事务状态。</li>\n</ul>\n</li>\n<li>\n<p>冲突解决</p>\n<ul>\n<li>冲突检测：新领导者检查事务日志，找出冲突的事务。</li>\n<li>冲突解决策略：\n<ul>\n<li>基于事务编号（ZXID）：保留编号较大的事务。</li>\n<li>基于事务时间戳：保留时间戳较新的事务。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Leader 同步</p>\n<p>选举出新的 Leader 后，Leader 会开始与其他 Follower 进行数据同步。具体步骤如下：</p>\n<ol>\n<li>Leader 发送事务日志：\n<ul>\n<li>Leader 将最新的事务日志（transaction log）发送给所有 Follower。</li>\n<li>事务日志包含了所有未提交的事务记录。</li>\n</ul>\n</li>\n<li>Follower 接收事务日志：\n<ul>\n<li>Follower 接收到事务日志后，会将其应用到本地状态上。</li>\n<li>Follower 会确认事务日志的正确性，并将确认信息发送回 Leader。</li>\n</ul>\n</li>\n<li>Leader 确认同步：\n<ul>\n<li>Leader 收到所有 Follower 的确认信息后，会确认数据同步完成。</li>\n<li>Leader 会发送确认信息给所有 Follower，表明数据同步完成。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>Follower 同步</p>\n<p>Follower 在同步过程中需要确保与 Leader 的状态一致。具体步骤如下：</p>\n<ol>\n<li>Leader 发送写请求：\n<ul>\n<li>当 Leader 收到客户端的写请求时，会将写请求广播给所有 Follower。</li>\n<li>写请求包含具体的写操作和事务 ID（zxid）。</li>\n</ul>\n</li>\n<li>Follower 执行写操作：\n<ul>\n<li>Follower 接收到写请求后，会执行相同的写操作，并记录事务日志。</li>\n<li>Follower 会将确认信息发送回 Leader，表明写操作已完成。</li>\n</ul>\n</li>\n<li>Leader 确认写操作：\n<ul>\n<li>Leader 收到所有 Follower 的确认信息后，会确认写操作完成。</li>\n<li>Leader 会发送确认信息给所有 Follower，表明写操作完成。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>Observer 同步</p>\n<p>Observer 不参与选举过程，但需要同步 Leader 的数据以保持最新状态。具体步骤如下：</p>\n<ol>\n<li>Observer 同步数据：\n<ul>\n<li>Observer 从 Leader 获取最新的数据。</li>\n<li>Leader 将最新的事务日志发送给 Observer。</li>\n</ul>\n</li>\n<li>Observer 应用事务日志：\n<ul>\n<li>Observer 接收到事务日志后，会将其应用到本地状态上。</li>\n<li>Observer 会确认事务日志的正确性，并将确认信息发送回 Leader。</li>\n</ul>\n</li>\n<li>Leader 确认同步：\n<ul>\n<li>Leader 收到 Observer 的确认信息后，会确认数据同步完成。</li>\n<li>Leader 会发送确认信息给 Observer，表明数据同步完成。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<p>详细流程示例</p>\n<p>假设集群中有三个服务器：Server A、Server B 和 Server C。Server A 成为 Leader，Server B 和 Server C 作为 Follower。此外，还有一个<br>\n Observer 服务器 Server D。</p>\n<ol>\n<li>Leader 同步：\n<ul>\n<li>Server A 发送最新的事务日志给 Server B 和 Server C。</li>\n<li>Server B 和 Server C 接收到事务日志后，应用到本地状态，并发送确认信息给 Server A。</li>\n<li>Server A 收到所有 Follower 的确认信息后，确认数据同步完成。</li>\n</ul>\n</li>\n<li>Follower 同步：\n<ul>\n<li>当 Server A 收到客户端的写请求时，将写请求广播给 Server B 和 Server C。</li>\n<li>Server B 和 Server C 执行相同的写操作，并记录事务日志。</li>\n<li>Server B 和 Server C 发送确认信息给 Server A。</li>\n<li>Server A 收到所有 Follower 的确认信息后，确认写操作完成。</li>\n</ul>\n</li>\n<li>Observer 同步：\n<ul>\n<li>Server D 从 Server A 获取最新的事务日志。</li>\n<li>Server A 发送最新的事务日志给 Server D。</li>\n<li>Server D 接收到事务日志后，应用到本地状态，并发送确认信息给 Server A。</li>\n<li>Server A 收到 Observer 的确认信息后，确认数据同步完成。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"zookeeper的持久化机制\"><a class=\"markdownIt-Anchor\" href=\"#zookeeper的持久化机制\">#</a> Zookeeper 的持久化机制</h3>\n<p>Zookeeper 的数据持久化机制是其可靠性的关键组成部分之一。为了确保数据在系统崩溃或重启后仍然可用，Zookeeper 采用了多种机制来实现数据持久化。</p>\n<ol>\n<li>\n<p>事务日志（Transaction Log）</p>\n<p>事务日志记录了所有对 Zookeeper 数据树的操作。每次写操作都会被记录在事务日志中，以便在系统崩溃后能够恢复数据。</p>\n<ul>\n<li>\n<p>事务日志的作用</p>\n<ul>\n<li>记录所有写操作：每次写操作（如创建节点、删除节点、更新节点数据等）都会被记录在事务日志中。</li>\n<li>支持数据恢复：在系统崩溃后，可以通过事务日志恢复数据。</li>\n</ul>\n</li>\n<li>\n<p>事务日志的存储</p>\n<ul>\n<li>事务日志通常存储在磁盘上，以确保数据的安全性和持久性。每个 Server 都有自己的事务日志文件，通常位于配置文件<br>\n zoo.cfg<br>\n 中指定的目录下。</li>\n</ul>\n</li>\n<li>\n<p>事务日志的格式</p>\n<p>事务日志文件通常以 .log 或 .txn 结尾。每个事务日志文件包含一系列事务记录，每条记录包含以下信息：</p>\n<ul>\n<li>事务类型：标识操作类型（如 create、delete、setData 等）。</li>\n<li>事务 ID（zxid）：唯一的事务标识符。</li>\n<li>操作详情：具体的操作内容（如节点路径、数据等）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>快照（Snapshot）</p>\n<p>快照是对 Zookeeper 数据树的一个完整备份。快照定期生成，以减少事务日志的大小，并提高恢复速度。</p>\n<ul>\n<li>\n<p>快照的作用</p>\n<ul>\n<li>快速恢复数据：在系统崩溃后，可以通过快照快速恢复数据。</li>\n<li>减少事务日志大小：定期生成快照可以减少事务日志的大小，提高系统性能。</li>\n</ul>\n</li>\n<li>\n<p>快照的存储</p>\n<p>快照通常也存储在磁盘上，与事务日志文件一起存放在配置文件 zoo.cfg 中指定的目录下。</p>\n</li>\n<li>\n<p>快照的格式</p>\n<p>快照文件通常以 .snapshot 或 .snap 结尾。每个快照文件包含以下信息：</p>\n<ul>\n<li>数据树的完整状态：当前 Zookeeper 数据树的完整状态。</li>\n<li>事务 ID（zxid）：最后一个事务的 ID，用于标识快照的时间点。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>恢复机制</p>\n<p>当 Zookeeper 服务器启动时，需要从磁盘上的事务日志和快照文件中恢复数据。恢复过程如下：</p>\n<ol>\n<li>加载快照：服务器启动时，首先加载最新的快照文件，恢复数据树的基本状态。</li>\n<li>重放事务日志：从最新的快照时间点之后的事务日志开始重放，逐条执行事务日志中的操作，直到最新的事务日志为止。</li>\n<li>检查一致性：服务器会检查数据树的状态是否一致，确保没有遗漏的操作。</li>\n</ol>\n</li>\n</ol>\n",
            "tags": [
                "后端",
                "java",
                "Zookeeper"
            ]
        },
        {
            "id": "https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/",
            "url": "https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/",
            "title": "【Redis】Redis详解",
            "date_published": "2024-09-13T05:52:28.000Z",
            "content_html": "<h1 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h1>\n<h2 id=\"redis-是什么\"><a class=\"markdownIt-Anchor\" href=\"#redis-是什么\">#</a> Redis 是什么</h2>\n<p>Redis（Remote Dictionary Server）是一个开源的键值存储系统，以其高性能和低延迟著称。它最初由 Salvatore<br>\nSanfilippo 编写，并于 2009 年首次发布。Redis 不仅可以作为数据库使用，还可以作为缓存和消息代理。Redis 支持多种数据结构，如字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted<br>\nsets）等，这使得它非常适合用于多种应用场景</p>\n<h2 id=\"redis-的特点\"><a class=\"markdownIt-Anchor\" href=\"#redis-的特点\">#</a> Redis 的特点</h2>\n<ul>\n<li>内存存储：Redis 将所有数据都存储在内存中，这使得它能够提供非常高的读写速度，通常能够达到数十万次每秒的读写操作（QPS）。</li>\n<li>持久化：尽管 Redis 主要是一个内存数据库，但它也提供了数据持久化的机制，包括 RDB（Redis Database Backup）快照和 AOF（Append Only<br>\nFile）日志两种方式。</li>\n<li>数据结构丰富：除了基本的键值对存储之外，Redis 还支持多种复杂的数据结构，如列表、集合、有序集合等，这使得它非常适合用于构建复杂的数据模型。</li>\n<li>网络透明：Redis 使用 TCP 协议，客户端可以通过网络访问 Redis 服务器，支持跨平台部署。</li>\n<li>主从复制：Redis 支持主从复制机制，可以轻松地设置数据备份和读写分离。</li>\n<li>Lua 脚本：Redis 支持在服务器端执行 Lua 脚本，允许用户将复杂的操作封装成一个原子性的操作。</li>\n<li>事务：Redis 支持事务，允许用户将一系列操作打包成一个单独的命令序列执行。</li>\n<li>发布 / 订阅模式：Redis 支持发布 / 订阅模式，可以用于构建消息队列或事件驱动的应用程序。</li>\n<li>集群：Redis 3.0 之后版本支持官方的集群模式，可以实现数据的水平扩展。</li>\n<li>多线程：Redis 6.0 版本引入了多线程模型，用于异步处理 I/O 和其他耗时操作，进一步提升了性能。</li>\n</ul>\n<h2 id=\"redis-的应用场景\"><a class=\"markdownIt-Anchor\" href=\"#redis-的应用场景\">#</a> Redis 的应用场景</h2>\n<p>由于其高性能和灵活性，Redis 被广泛应用于多种场景中：</p>\n<ul>\n<li>缓存：由于 Redis 的高速读写能力，它经常被用作 Web 应用的缓存层，以减轻后端数据库的压力。</li>\n<li>会话存储：Redis 可以用来存储用户的会话信息，支持快速的读取和更新操作。</li>\n<li>排行榜：Redis 的有序集合非常适合用来构建排行榜，可以高效地进行排序和范围查询。</li>\n<li>消息队列：通过发布 / 订阅模式，Redis 可以作为一个轻量级的消息队列系统。</li>\n<li>实时数据分析：Redis 的数据结构非常适合用于处理实时数据流，如实时统计、监控等。</li>\n<li>分布式锁：Redis 可以用来实现简单的分布式锁机制，协调多个节点上的并发操作。</li>\n</ul>\n<h2 id=\"redis-的数据结构\"><a class=\"markdownIt-Anchor\" href=\"#redis-的数据结构\">#</a> Redis 的数据结构</h2>\n<h3 id=\"底层数据结构\"><a class=\"markdownIt-Anchor\" href=\"#底层数据结构\">#</a> 底层数据结构</h3>\n<h4 id=\"redisobject\"><a class=\"markdownIt-Anchor\" href=\"#redisobject\">#</a> redisObject</h4>\n<p>定义：redisObject（通常缩写为 robj）是 Redis 中用来表示数据库键值对的一个核心数据结构。每一个键值对在 Redis 内部都会被转化为一个 redisObject 实例进行管理。这个结构体不仅包含了键或值本身的数据，还提供了额外的信息来帮助 Redis 更好地管理和操作这些对象。</p>\n<p>用途：redisObject 是 Redis 中键值对存储的数据结构，它封装了键和值，并提供了额外的元数据，如引用计数、过期时间等。其主要作用在于：</p>\n<ul>\n<li>类型和编码：它使得 Redis 能够灵活地存储不同类型的数据，并且可以根据数据的特点选择最合适的编码方式来存储，从而优化内存使用和访问速度。</li>\n<li>内存管理：通过引用计数，redisObject 支持对象的共享和自动内存回收，减少了不必要的内存分配和释放操作。</li>\n<li>LRU 缓存淘汰：通过记录对象的最后访问时间，Redis 可以实现基于 LRU 算法的对象淘汰，从而在内存资源有限的情况下，优先保留最近使用的对象。</li>\n<li>共享对象：对于一些常用的简单对象（如数字 0 和 1，以及空字符串），Redis 会创建一次并复用，这减少了创建和销毁对象的开销。</li>\n</ul>\n<p>底层实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> lru:REDIS_LRU_BITS; <span class=\"comment\">/* LRU time (relative to server.lruclock) */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"type\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n<p>redisObject 的基本结构通常包含以下字段：</p>\n<ul>\n<li>type: 一个 4 位的无符号整数，用来标识对象的类型。Redis 支持多种数据类型，如字符串（string）、列表（list）、集合（set）、哈希（hash）、有序集合（sorted<br>\nset）等，每种类型都有一个对应的标识符。</li>\n<li>encoding: 另一个 4 位的无符号整数，表示对象的编码方式。不同的数据类型有不同的内部编码方式，例如字符串可以是普通的字符串，也可以是压缩后的字符串（embstr），列表可以是链表（list）或者快速列表（quicklist）等。</li>\n<li>lru: 一个时间戳，记录了对象最后一次被访问的时间（相对于服务器的 lruclock）。这个字段用于实现 Redis 的 LRU（Least Recently<br>\nUsed）缓存淘汰策略。</li>\n<li>refcount: 引用计数器，用来追踪有多少地方引用了这个对象。当一个对象不再被任何地方引用时，其引用计数器减至零，Redis 可以回收该对象占用的内存。</li>\n<li>ptr: 一个指向实际数据的指针。这个指针指向的具体内容依赖于对象的类型和编码方式。</li>\n</ul>\n<h4 id=\"动态字符串sds\"><a class=\"markdownIt-Anchor\" href=\"#动态字符串sds\">#</a> 动态字符串（SDS）</h4>\n<p>定义：SDS（Simple Dynamic String）是一种动态字符串，它使用一个结构体来保存字符串的指针、长度和未使用的空间。</p>\n<p>底层实现：使用简单动态字符串（SDS）来存储数据，SDS 是为了克服 C 字符串的一些不足而设计的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//记录buf数组中已使用字节的数量</span></span><br><span class=\"line\">    <span class=\"comment\">//等于 SDS 保存字符串的长度</span></span><br><span class=\"line\">    <span class=\"type\">int</span> len;</span><br><span class=\"line\">    <span class=\"comment\">//记录 buf 数组中未使用字节的数量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"built_in\">free</span>;</span><br><span class=\"line\">    <span class=\"comment\">//字节数组，用于保存字符串</span></span><br><span class=\"line\">    <span class=\"type\">char</span> buf[];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用 SDS 保存字符串 “Redis” 具体图示如下：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1120165-20180528075607627-218845583.png\" class=\"\" title=\"1120165-20180528075607627-218845583.png\">\n<p>图片来源：《Redis 设计与实现》</p>\n<p>我们看上面对于 SDS 数据类型的定义：</p>\n<ul>\n<li>len 保存了 SDS 保存字符串的长度</li>\n<li>buf [] 数组用来保存字符串的每个元素</li>\n<li>free j 记录了 buf 数组中未使用的字节数量</li>\n</ul>\n<p>上面的定义相对于 C 语言对于字符串的定义，有什么好处？</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1120165-20180527234349672-568401853.png\" class=\"\" title=\"1120165-20180528075607627-218845583.png\">\n<ol>\n<li>\n<p>常数复杂度获取字符串长度：由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O (1)。而对于 C<br>\n 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O (n)。通过 strlen key 命令可以获取 key 的字符串长度。</p>\n</li>\n<li>\n<p>杜绝缓冲区溢出：我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于<br>\n SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求。如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p>\n</li>\n<li>\n<p>减少修改字符串的内存重新分配次数:<br>\nC 语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p>\n<p>而对于 SDS，由于 len 属性和 free 属性的存在，对于修改字符串 SDS 实现了空间预分配和惰性空间释放两种策略：</p>\n<ol>\n<li>空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</li>\n<li>惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free<br>\n 属性将这些字节的数量记录下来，等待后续使用。（当然 SDS 也提供了相应的 API，当我们有需要时，也可以手动释放这些未使用的空间。）</li>\n</ol>\n</li>\n<li>\n<p>二进制安全</p>\n<p>因为 C 字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此 C 字符串无法正确存取；而所有<br>\n SDS 的 API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len<br>\n 属性表示的长度来判断字符串是否结束。</p>\n</li>\n<li>\n<p>兼容部分 C 字符串函数</p>\n<p>虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库 &lt;string.h&gt; 中的一部分函数。</p>\n</li>\n</ol>\n<p>一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）来使用。</p>\n<h4 id=\"压缩列表zip-list\"><a class=\"markdownIt-Anchor\" href=\"#压缩列表zip-list\">#</a> 压缩列表（Zip List）</h4>\n<p>定义：Ziplist 是一种特殊的内存紧凑型数据结构，用于存储多个相邻的元素。它主要用于实现 Redis 中的列表（List）和哈希（Hash）数据类型，当这些数据类型的数据量较小且元素较短时，使用 ziplist 可以节省内存空间。</p>\n<p>底层实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> header; <span class=\"comment\">// 标记ziplist的开始，通常是一个固定的字节（例如 0x01）</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> length; <span class=\"comment\">// 整个ziplist的长度，包括所有条目和前缀信息。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Entries</span></span><br><span class=\"line\">    <span class=\"comment\">// Each entry has a length prefix and content</span></span><br><span class=\"line\">    <span class=\"comment\">// The number of entries is determined by the length field</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Example entry structure:</span></span><br><span class=\"line\">    <span class=\"comment\">// Length prefix (1 or 5 bytes)</span></span><br><span class=\"line\">    <span class=\"comment\">// Content (variable length)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// End marker</span></span><br><span class=\"line\">    <span class=\"type\">char</span> end; <span class=\"comment\">// 标记ziplist的结束，通常是一个固定的字节（例如 0xff）。</span></span><br><span class=\"line\">&#125; <span class=\"type\">ziplist_t</span>;</span><br></pre></td></tr></table></figure>\n<p>实现细节：</p>\n<ul>\n<li>前缀：每个元素的前缀包含了元素的长度信息，以及元素的类型信息。</li>\n<li>长度编码：ziplist 使用可变长度编码来存储元素的长度，这样可以更高效地利用内存。</li>\n<li>内存紧凑：由于 ziplist 将所有元素存储在一个连续的内存区域中，因此它可以有效地减少内存碎片。</li>\n</ul>\n<p>特点</p>\n<ul>\n<li>连续存储：ziplist 将多个元素存储在一个连续的内存块中。</li>\n<li>元素和长度信息：每个元素的前面都会有一个前缀，这个前缀包含了元素的长度信息。</li>\n<li>支持多种类型：ziplist 可以存储整数或字符串，整数直接存储在前缀中，字符串则存储在前缀之后。</li>\n</ul>\n<h4 id=\"双向链表linkedlist\"><a class=\"markdownIt-Anchor\" href=\"#双向链表linkedlist\">#</a> 双向链表（linkedlist）</h4>\n<p>定义：在 Redis 中，linkedlist（通常指的是 Redis 内部实现的双向链表）是 Redis 用来存储 list 键值对的一种底层数据结构。它允许 Redis 从列表的两端高效地添加和移除元素，</p>\n<p>底层实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个双向链表节点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span>  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span>&#123;</span></span><br><span class=\"line\">       <span class=\"comment\">//前置节点</span></span><br><span class=\"line\">       <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\">       <span class=\"comment\">//后置节点</span></span><br><span class=\"line\">       <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">       <span class=\"comment\">//节点的值</span></span><br><span class=\"line\">       <span class=\"type\">void</span> *value;  </span><br><span class=\"line\">&#125;listNode</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个双向链表</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span>&#123;</span></span><br><span class=\"line\">     <span class=\"comment\">//表头节点</span></span><br><span class=\"line\">     listNode *head;</span><br><span class=\"line\">     <span class=\"comment\">//表尾节点</span></span><br><span class=\"line\">     listNode *tail;</span><br><span class=\"line\">     <span class=\"comment\">//链表所包含的节点数量</span></span><br><span class=\"line\">     <span class=\"type\">unsigned</span> <span class=\"type\">long</span> len;</span><br><span class=\"line\">     <span class=\"comment\">//节点值复制函数</span></span><br><span class=\"line\">     <span class=\"type\">void</span> (*<span class=\"built_in\">free</span>) (<span class=\"type\">void</span> *ptr);</span><br><span class=\"line\">     <span class=\"comment\">//节点值释放函数</span></span><br><span class=\"line\">     <span class=\"type\">void</span> (*<span class=\"built_in\">free</span>) (<span class=\"type\">void</span> *ptr);</span><br><span class=\"line\">     <span class=\"comment\">//节点值对比函数</span></span><br><span class=\"line\">     <span class=\"type\">int</span> (*match) (<span class=\"type\">void</span> *ptr,<span class=\"type\">void</span> *key);</span><br><span class=\"line\">&#125;<span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure>\n<p>数据结构如下图</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1120165-20180528074403440-111834793.png\" class=\"\" title=\"1120165-20180528074403440-111834793.png\">\n<p>Redis 的 linkedlist 是由一系列 listNode 节点构成的双向链表。</p>\n<p>每个 listNode 包含三个主要部分：</p>\n<ul>\n<li>prev：指向列表中前一个节点的指针。</li>\n<li>next：指向列表中后一个节点的指针。</li>\n<li>value：存储实际数据的字段，这个字段实际上是指向 redisObject 的指针，redisObject 包含了实际的数据和元数据（如类型、编码等）。</li>\n</ul>\n<p>每个 list 包含三个主要部分：</p>\n<ul>\n<li>head：指向链表的第一个节点。</li>\n<li>tail：指向链表的最后一个节点。</li>\n<li>len：链表的长度，即链表中节点的数量。</li>\n</ul>\n<p>特点</p>\n<ul>\n<li>双向链接：每个节点都包含前驱和后继指针，这使得可以从链表的任一端开始遍历整个链表。</li>\n<li>无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL, 对链表的访问都是以 NULL 结束。</li>\n<li>带链表长度计数器：通过 len 属性获取链表长度的时间复杂度为 O (1)。</li>\n<li>多态：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值。</li>\n<li>动态增长：随着元素的增加，链表可以动态增长。</li>\n</ul>\n<h4 id=\"哈希表hashtable\"><a class=\"markdownIt-Anchor\" href=\"#哈希表hashtable\">#</a> 哈希表（Hashtable）</h4>\n<p>定义：hashtable（哈希表）是一种用于存储键值对的数据结构，它在 Redis 内部用于实现哈希（hash）类型。哈希表允许快速地插入、查找和删除键值对，并且提供了良好的性能。</p>\n<p>底层实现：Redis 中的哈希表实现主要包括两个核心组件：一个数组和一个链表。数组中的每个槽（slot）都可以存储一个链表，链表中的每个节点代表一个键值对。这种设计允许哈希表处理哈希冲突，即多个键映射到同一个数组索引的情况。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    dictEntry **table; <span class=\"comment\">// 哈希桶数组</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> size; <span class=\"comment\">// 哈希桶数组大小</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> used; <span class=\"comment\">// 已使用的哈希桶数量</span></span><br><span class=\"line\">    dictResizeFunc *resize; <span class=\"comment\">// 重置哈希表大小的函数</span></span><br><span class=\"line\">    <span class=\"type\">void</span> (*rehashidx); <span class=\"comment\">// 当前正在进行的哈希表重置索引</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> states; <span class=\"comment\">// 哈希表状态标志</span></span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure>\n<p>Redis 中的哈希表结构定义通常包括以下几个部分：</p>\n<ul>\n<li>table：一个数组，数组的每个元素都是一个链表。</li>\n<li>size：数组的大小。</li>\n<li>used：已使用的槽的数量，即存储键值对的链表数量。</li>\n<li>resize_policy：在某些 Redis 版本中，可能还包括用于控制何时进行重新哈希（resizing）的策略。</li>\n</ul>\n<p>哈希表 table 中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *key; <span class=\"comment\">// 键</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"type\">void</span> *val; <span class=\"comment\">// 值</span></span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> ival; <span class=\"comment\">// 整数值</span></span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span> <span class=\"comment\">// 指向下一个同散列值的dictEntry</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure>\n<p>每个键值对存储在一个 dictEntry 结构体中，该结构体包含：</p>\n<ul>\n<li>key：键的指针，指向 redisObject。</li>\n<li>val：值的指针，同样指向 redisObject。</li>\n<li>next：指向链表中下一个节点的指针，用于处理哈希冲突。</li>\n</ul>\n<h5 id=\"哈希冲突的优化\"><a class=\"markdownIt-Anchor\" href=\"#哈希冲突的优化\">#</a> 哈希冲突的优化</h5>\n<p>我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过 next 这个指针可以将多个哈希值相同的键值对连接在一起，用来解决哈希冲突。</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1120165-20180528080655703-1600710948.png\" class=\"\" title=\"1120165-20180528080655703-1600710948.png\">\n<ol>\n<li>\n<p>哈希算法：Redis 计算哈希值和索引值方法如下：</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"number\">1</span>、使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class=\"line\">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class=\"line\">#<span class=\"number\">2</span>、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值</span><br><span class=\"line\">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>解决哈希冲突：这个问题上面我们介绍了，方法是链地址法。通过字典里面的 *next 指针指向下一个具有相同索引值的哈希表节点。</p>\n</li>\n<li>\n<p>扩容和收缩：当哈希表保存的键值对太多或者太少时，就要通过 rerehash (重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：</p>\n<ol>\n<li>如果执行扩展操作，会基于原哈希表创建一个大小等于 ht [0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。<br>\n相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。</li>\n<li>重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。</li>\n<li>所有键值对都迁徙完毕后，释放原哈希表的内存空间。</li>\n</ol>\n</li>\n<li>\n<p>触发扩容的条件：</p>\n<ol>\n<li>服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于 1。</li>\n<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于 5。</li>\n</ol>\n<p>ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。</p>\n</li>\n<li>\n<p>渐近式 rehash</p>\n<p>什么叫渐进式 rehash？ 也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在 Redis 中的键值对只有几个几十个，那么<br>\n rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行<br>\n rehash，势必会造成 Redis 一段时间内不能进行别的操作。所以 Redis 采用渐进式<br>\n rehash, 这样在进行渐进式 rehash 期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行<br>\n增加操作，一定是在新的哈希表上进行的。</p>\n</li>\n</ol>\n<h4 id=\"整数集合intset\"><a class=\"markdownIt-Anchor\" href=\"#整数集合intset\">#</a> 整数集合（intset）</h4>\n<p>定义：一种特殊的数据结构，主要用于存储整数类型的集合，并且这些整数集合不允许有重复的元素。</p>\n<p>底层实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">intset</span>&#123;</span></span><br><span class=\"line\">     <span class=\"comment\">//编码方式</span></span><br><span class=\"line\">     <span class=\"type\">uint32_t</span> encoding;</span><br><span class=\"line\">     <span class=\"comment\">//集合包含的元素数量</span></span><br><span class=\"line\">     <span class=\"type\">uint32_t</span> length;</span><br><span class=\"line\">     <span class=\"comment\">//保存元素的数组</span></span><br><span class=\"line\">     <span class=\"type\">int8_t</span> contents[];</span><br><span class=\"line\">&#125;intset;</span><br></pre></td></tr></table></figure>\n<p>intset 的数据结构定义通常包括以下几个部分：</p>\n<ul>\n<li>length：表示集合中元素的数量。</li>\n<li>encoding：表示集合中元素的类型，可以是 int16_t、int32_t 或 int64_t，具体取决于集合中最大的整数值所需的位数。</li>\n<li>contents：一个动态数组，用于存储实际的整数值。每个整数根据 encoding 字段指定的类型占用相应的字节数。</li>\n</ul>\n<p>动态升级</p>\n<p>当尝试向 intset 中添加一个超出当前整数类型范围的整数时，Redis 会执行一个称为 “编码升级” 的过程。这个过程会将 intset 中的所有元素转换为更大类型的整数，以适应新加入的元素。例如，如果 intset 当前使用的是 int32_t 类型，而尝试插入一个 int64_t 类型的值，则所有现有的 int32_t 值会被转换成 int64_t 类型。</p>\n<h4 id=\"跳表skip-list\"><a class=\"markdownIt-Anchor\" href=\"#跳表skip-list\">#</a> 跳表（Skip List）</h4>\n<p>定义：Skiplist 是一种线性数据结构，它提供了比传统平衡树更快的查找性能，同时实现相对简单。Redis 使用 skiplist 来实现有序集合（Sorted<br>\nSet）。</p>\n<p>底层实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplist</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">header</span>;</span> <span class=\"comment\">// 跳表头部</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">tail</span>;</span> <span class=\"comment\">// 跳表尾部</span></span><br><span class=\"line\">    <span class=\"type\">int</span> length; <span class=\"comment\">// 跳表长度</span></span><br><span class=\"line\">    <span class=\"type\">int</span> level; <span class=\"comment\">// 跳表层级</span></span><br><span class=\"line\">&#125; zskiplist;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">double</span> score; <span class=\"comment\">// 成员的分数</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *obj; <span class=\"comment\">// 成员对象</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">backward</span>;</span> <span class=\"comment\">// 指向前一个节点的指针</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistLevel</span> &#123;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">forward</span>;</span> <span class=\"comment\">// 指向后一个节点的指针</span></span><br><span class=\"line\">        <span class=\"type\">int</span> span; <span class=\"comment\">// 跨越的节点数量</span></span><br><span class=\"line\">    &#125; level[]; <span class=\"comment\">// 层级数组</span></span><br><span class=\"line\">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>\n<p>实现细节：</p>\n<ul>\n<li>节点结构：skiplist 中的每个节点包含一个元素、一个分数（用于排序）、一个指向前一个节点的指针以及一个或多个指向下一层节点的指针。</li>\n<li>层级：每个节点可以有多个层级，每个层级对应一个指针，指向下一个具有相同高度的节点。</li>\n<li>查找：查找时，从最高层开始，沿着指针前进直到找到目标元素或到达最低层。</li>\n</ul>\n<p>特点：</p>\n<ul>\n<li>多级索引：skiplist 通过构建多级索引来加速查找，每一级索引都是前一级索引的一个子集。</li>\n<li>随机高度：新插入的元素的高度是随机确定的，通常使用随机化算法来决定新节点的高度。</li>\n<li>高效插入和删除：由于 skiplist 的多级索引结构，插入和删除操作也相当高效。</li>\n</ul>\n<h3 id=\"数据结构的使用\"><a class=\"markdownIt-Anchor\" href=\"#数据结构的使用\">#</a> 数据结构的使用</h3>\n<h4 id=\"字符串string\"><a class=\"markdownIt-Anchor\" href=\"#字符串string\">#</a> 字符串（String）</h4>\n<p>用途：存储字符串数据，如文本、数字、日期等。</p>\n<p>实现：根据不同的情况下字符串对象的 encoding 有三种，分别是：int、raw、embstr。</p>\n<ol>\n<li>\n<p>如果一个字符串对象保存的是整数值，并且这个整数值可以用 long 类型标识，那么字符串对象会讲整数值保存在 ptr 属性中，并将<br>\n encoding 设置为 int。比如 set number 10086 命令。</p>\n</li>\n<li>\n<p>如果字符串对象保存的是一个字符串值，并且这个字符串的长度大于 44 字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为<br>\n raw。在这种情况下，ptr 字段指向一个 SDS（Simple Dynamic String）结构。S 在这种情况下，ptr 字段指向一个 SDS（Simple Dynamic<br>\nString）结构。</p>\n</li>\n<li>\n<p>如果字符串对象保存的是一个字符串值，并且这个字符串的长度小于等于 44 字节，那么字符串对象将使用 embstr<br>\n 编码的方式来保存这个字符串。embstr 同样基于 SDS，是一种将 RedisObject 对象头和 SDS 对象连续存在一起，使用 malloc<br>\n 方法一次分配内存的存储形式。 这种编码方式的一些优点：</p>\n<ol>\n<li>embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次。</li>\n<li>释放 embstr 编码的字符串对象只需要调用一次内存释放函数，而释放 raw 编码的字符串对象需要调用两次内存释放函数。</li>\n<li>因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起 raw<br>\n 编码的字符串对象能够更好地利用缓存带来的优势。</li>\n</ol>\n</li>\n</ol>\n<p>为什么分界线是 44 字节？</p>\n<p>Redis 的 embstr 编码的实现中，字符串对象头和字符串对象本身是连续的，因此需要一个字节来保存字符串的长度。<br>\nembstr 最小占用空间为 19（16+3），而 64-19-1（结尾的 \\0）=44，所以 embstr 只能容纳 44 字节。</p>\n<p>使用场景：</p>\n<ul>\n<li>计数器：例如网站的访问计数，可以使用 INCR 或 INCRBY 命令来递增计数器。</li>\n<li>会话存储：存储用户的登录状态或其他临时信息。</li>\n<li>消息队列：使用 LPUSH 和 BRPOP 命令实现简单的消息队列。</li>\n<li>缓存：存储经常访问的数据，减少数据库的访问压力。</li>\n</ul>\n<h4 id=\"列表list\"><a class=\"markdownIt-Anchor\" href=\"#列表list\">#</a> 列表（List）</h4>\n<p>用途：用于存储有序的元素列表，如队列、栈等。</p>\n<p>实现：列表对象的 encoding 有 ziplist 和 linkedlist 两种。</p>\n<ul>\n<li>当列表的长度小于 512，并且所有元素的长度都小于 64 字节时，使用压缩列表 (ziplist) 存储</li>\n<li>当列表的长度大于等于 512，或者有元素长度大于 64 字节时，使用链表 (linkedlist) 存储。</li>\n</ul>\n<p>使用场景：</p>\n<ul>\n<li>消息队列：使用 LPUSH 和 BRPOP 命令实现先进先出（FIFO）的消息队列。</li>\n<li>历史记录：保存用户的浏览历史或购买记录，可以使用 RPUSH 和 LPOP 命令。</li>\n<li>排行榜：使用列表存储排名信息，通过 LREM 命令可以移除特定成员。</li>\n</ul>\n<h4 id=\"哈希hash\"><a class=\"markdownIt-Anchor\" href=\"#哈希hash\">#</a> 哈希（Hash）</h4>\n<p>用途：存储键值对，其中键是唯一的，值可以重复。</p>\n<p>实现：哈希对象的 encoding 有 ziplist 和 hashtable 两种。</p>\n<ul>\n<li>当哈希对象保存的键值对数量小于 512，并且所有键值对的长度都小于 64 字节时，使用压缩列表存储；</li>\n<li>当哈希对象保存的键值对数量大于等于 512，或者有键值对长度大于 64 字节时，使用 hashtable 存储。</li>\n</ul>\n<p>使用场景：</p>\n<ul>\n<li>对象存储：存储复杂对象，如用户信息，每个字段对应用户的一个属性。</li>\n<li>购物车：每个用户有一个购物车，购物车中的商品信息可以用哈希表来存储。</li>\n<li>会话管理：存储用户的会话信息，每个会话 ID 对应一个哈希表。</li>\n</ul>\n<h4 id=\"集合set\"><a class=\"markdownIt-Anchor\" href=\"#集合set\">#</a> 集合（Set）</h4>\n<p>用途：存储不重复的元素集合，如集合、去重列表等。</p>\n<p>实现：集合对象的 encoding 有 intset 和 hashtable 两种。</p>\n<ul>\n<li>当集合中元素数量小于 512，并且所有元素的长度都小于 64 字节时，使用 intset 存储；</li>\n<li>当集合中元素数量大于等于 512，或者有元素长度大于 64 字节时，使用 hashtable 存储。</li>\n</ul>\n<p>使用场景：</p>\n<ul>\n<li>去重：例如在一个活动中，确保每个用户只能参与一次。</li>\n<li>标签系统：每个项目可以有多个标签，使用集合来存储项目的标签。</li>\n<li>好友关系：存储用户的好友列表，可以快速判断两个用户是否互为好友。</li>\n</ul>\n<h4 id=\"有序集合sorted-set\"><a class=\"markdownIt-Anchor\" href=\"#有序集合sorted-set\">#</a> 有序集合（Sorted Set）</h4>\n<p>用途：存储有序的元素集合，其中元素是唯一的，并且可以按照一定的顺序排列。</p>\n<p>实现：有序集合对象的 encoding 有 ziplist 和 skiplist 两种。</p>\n<ol>\n<li>当有序集合中的元素数量小于 512，并且所有元素的长度都小于 64 字节时，使用压缩列表 (ziplist) 存储；</li>\n<li>当有序集合中的元素数量大于等于 512，或者有元素长度大于 64 字节时，使用跳表 (skiplist) 存储。</li>\n</ol>\n<p>使用场景：</p>\n<ul>\n<li>排行榜：根据分数排序的排行榜，如游戏得分、用户贡献度等。</li>\n<li>优先级队列：每个元素都有一个优先级，可以按优先级取出元素。</li>\n<li>时间轴：按时间戳排序的消息或帖子显示，如微博、Facebook 的时间线。</li>\n<li>地理信息：存储地理位置信息，并使用 GEO 命令查询附近的地点。</li>\n</ul>\n<h4 id=\"其他数据结构\"><a class=\"markdownIt-Anchor\" href=\"#其他数据结构\">#</a> 其他数据结构</h4>\n<ul>\n<li>\n<p>Bitmaps：二进制位数组，适合用于存储大量稀疏数据，如用户访问记录、权限控制等。</p>\n<p>使用场景：</p>\n<ul>\n<li>统计分析：例如统计某一天有多少独立用户访问了网站，可以使用一个位图来表示每个用户是否访问过。</li>\n<li>权限管理：每个用户可以有多个权限位，使用位图来表示用户的权限。</li>\n</ul>\n</li>\n<li>\n<p>HyperLogLog：用于近似计算不重复元素的数量，非常适合处理大规模数据集。</p>\n<p>使用场景：</p>\n<ul>\n<li>近似计数：用于估算大量数据中的不重复元素数量，例如统计网站的独立访客数。</li>\n</ul>\n</li>\n<li>\n<p>Streams：类似于消息队列，用于处理异步消息传递，可以实现类似 Kafka 的功能。</p>\n<p>使用场景：</p>\n<ul>\n<li>事件日志：记录系统中的事件，如用户行为日志，可以使用 XADD 添加事件，XREAD 读取事件。</li>\n<li>异步处理：作为消息队列的一部分，将事件发布到流中，然后由消费者异步处理。</li>\n</ul>\n</li>\n<li>\n<p>Geo：用于存储地理位置信息，并提供基于地理位置的查询功能。</p>\n<p>使用场景：</p>\n<ul>\n<li>位置服务：存储地理位置信息，并支持基于地理位置的搜索，如查找附近的餐厅或酒店。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"redis-综合应用示例\"><a class=\"markdownIt-Anchor\" href=\"#redis-综合应用示例\">#</a> Redis 综合应用示例</h4>\n<p>假设我们要构建一个社交网络应用，可以使用 Redis 来实现以下功能：</p>\n<ul>\n<li>用户信息存储：使用 Hash 类型存储每个用户的个人信息，如用户名、头像、生日等。</li>\n<li>好友关系：使用 Set 类型存储每个用户的好友列表。</li>\n<li>动态时间线：使用 Sorted Set 类型存储用户的动态，根据发布时间排序。</li>\n<li>消息通知：使用 List 类型作为消息队列，存储用户收到的通知消息。</li>\n<li>在线状态：使用 BitMap 类型记录每天用户的在线状态。</li>\n<li>热门话题：使用 HyperLogLog 类型来估计参与某个话题讨论的独立用户数量。</li>\n</ul>\n<h2 id=\"redis-的持久化\"><a class=\"markdownIt-Anchor\" href=\"#redis-的持久化\">#</a> Redis 的持久化</h2>\n<p>redis 是一个内存数据库，数据保存在内存中，但是我们都知道内存的数据变化是很快的，也容易发生丢失。幸好 Redis 还为我们提供了持久化的机制，分别是 RDB (<br>\nRedis DataBase) 和 AOF (Append Only File)。</p>\n<h3 id=\"rdb机制\"><a class=\"markdownIt-Anchor\" href=\"#rdb机制\">#</a> RDB 机制</h3>\n<p>RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为 dump.rdb。</p>\n<p>Redis 提供了三种机制：save、bgsave、自动化来触发 RDB 持久化过程：</p>\n<ul>\n<li>\n<p>save 触发方式</p>\n<p>该命令会阻塞当前 Redis 服务器，执行 save 命令期间，Redis 不能处理其他命令，直到 RDB 过程完成为止。具体流程如下：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg\" class=\"\" title=\"e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg\">\n<p>执行完成时候如果存在老的 RDB 文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p>\n</li>\n<li>\n<p>bgsave 触发方式</p>\n<p>执行该命令时，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg\" class=\"\" title=\"023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg\">\n<p>具体操作是 Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短。基本上<br>\n Redis 内部所有的 RDB 操作都是采用 bgsave 命令。</p>\n</li>\n<li>\n<p>自动触发</p>\n<p>自动触发是由我们的配置文件来完成的。在 redis.conf 配置文件中，里面有如下配置，我们可以去设置：</p>\n<ol>\n<li>save：这里是用来配置触发 Redis 的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如 “save m<br>\nn”。表示 m 秒内数据集存在 n 次修改时，自动触发 bgsave。</li>\n<li>stop-writes-on-bgsave-error：默认值为 yes。<br>\n当启用了 RDB 且最后一次后台保存数据失败，Redis 是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果 Redis 重启了，那么又可以重新开始接收数据了</li>\n<li>rdbcompression；默认值是 yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</li>\n<li>rdbchecksum：默认值是 yes。在存储快照后，我们还可以让 redis 使用 CRC64 算法来进行数据校验，但是这样做会增加大约 10% 的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</li>\n<li>dbfilename：设置快照的文件名，默认是 dump.rdb</li>\n<li>dir：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</li>\n</ol>\n<p>我们可以修改这些配置来实现我们想要的效果。</p>\n</li>\n</ul>\n<p>因为第三种方式是配置的，所以我们对前两种进行一个对比：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1c950a7b02087bf43b4490d50ac25f2a11dfcf7e.jpeg\" class=\"\" title=\"1c950a7b02087bf43b4490d50ac25f2a11dfcf7e.jpeg\">\n<p>RDB 的优势和劣势</p>\n<ul>\n<li>\n<p>优势</p>\n<ul>\n<li>RDB 文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</li>\n<li>生成 RDB 文件的时候，redis 主进程会 fork () 一个子进程来处理所有保存工作，主进程不需要进行任何磁盘 IO 操作。</li>\n<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>\n</ul>\n</li>\n<li>\n<p>劣势</p>\n<ul>\n<li>RDB 快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。<br>\n当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"aof机制\"><a class=\"markdownIt-Anchor\" href=\"#aof机制\">#</a> AOF 机制</h3>\n<p>全量备份总是耗时的，Redis 提供一种更加高效的方式 AOF，工作机制很简单，Redis 会将每一个收到的写命令都通过 write 函数追加到文件中。通俗的理解就是日志记录。</p>\n<ol>\n<li>\n<p>持久化原理</p>\n<p>他的原理看下面这张图：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/32fa828ba61ea8d3c2502e396b1b3848251f58b0.jpeg\" class=\"\" title=\"32fa828ba61ea8d3c2502e396b1b3848251f58b0.jpeg\">\n<p>每当有一个写命令过来时，就直接保存在我们的 AOF 文件中。</p>\n</li>\n<li>\n<p>文件重写原理</p>\n<p>AOF 的方式也同时带来了另一个问题：持久化文件会变的越来越大。为了解决这个问题，redis 提供了 bgrewriteaof 命令用来压缩 aof 的持久化文件。这条命令会将内存中的数据以命令的方式保存到临时文件中，同时会 fork 出一条新进程来将文件重写。</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/09fa513d269759ee28454d2c4cea4b106c22dfd3.jpeg\" class=\"\" title=\"09fa513d269759ee28454d2c4cea4b106c22dfd3.jpeg\">\n<p>重写 aof 文件的操作，并没有读取旧的 aof 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 aof 文件，这点和快照有点类似。</p>\n</li>\n</ol>\n<p>AOF 也有三种触发机制</p>\n<ul>\n<li>每修改同步 always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</li>\n<li>每秒同步 everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失</li>\n<li>不同 no：从不同步</li>\n</ul>\n<p>三种触发机制的对比如下图</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/b17eca8065380cd7df69859ba056a5325982816c.jpeg\" class=\"\" title=\"b17eca8065380cd7df69859ba056a5325982816c.jpeg\">\n<p>AOF 的优势和劣势</p>\n<ul>\n<li>优势\n<ul>\n<li>AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次 fsync 操作，最多丢失 1 秒钟的数据。</li>\n<li>AOF 日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</li>\n<li>AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</li>\n<li>AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。<br>\n比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大</li>\n<li>AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"持久化机制的选择\"><a class=\"markdownIt-Anchor\" href=\"#持久化机制的选择\">#</a> 持久化机制的选择</h3>\n<p>通常情况下我们是二者结合使用的。</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>RDB</th>\n<th>AOF</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>启动优先级</td>\n<td>低</td>\n<td>高</td>\n</tr>\n<tr>\n<td>体积</td>\n<td>小</td>\n<td>大</td>\n</tr>\n<tr>\n<td>恢复速度</td>\n<td>快</td>\n<td>慢</td>\n</tr>\n<tr>\n<td>数据安全性</td>\n<td>丢数据</td>\n<td>取决于刷盘策略</td>\n</tr>\n<tr>\n<td>轻重</td>\n<td>重</td>\n<td>轻</td>\n</tr>\n</tbody>\n</table>\n<p>RDB 使用场景</p>\n<ul>\n<li>数据恢复要求不高：如果应用程序可以接受在两次快照之间数据丢失的风险，那么 RDB 是一个很好的选择。</li>\n<li>需要快速恢复大量数据：由于 RDB 文件是一个完整的数据库快照，因此在需要快速恢复大量数据时，RDB 提供了更快的恢复速度。</li>\n<li>定期备份：RDB 适用于需要定期进行完整备份的场景，比如每天一次的全量备份。</li>\n<li>数据归档：RDB 文件可以轻松地传输到远程服务器或存储设备上，用于长期的数据归档或灾难恢复。</li>\n</ul>\n<p>AOF 使用场景</p>\n<ul>\n<li>数据安全性要求高：如果应用程序不能容忍任何数据丢失，那么 AOF 是更好的选择，因为它可以保证数据的完整性。</li>\n<li>频繁写入操作：对于写密集型的应用场景，AOF 可以更好地保证数据的一致性。</li>\n<li>数据重放：AOF 文件可以用来重放数据，这对于调试和审计非常有用。</li>\n<li>自动修复：Redis 可以定期对 AOF 文件进行重写，以压缩文件大小并移除冗余命令。</li>\n</ul>\n<h2 id=\"redis-的内存调度\"><a class=\"markdownIt-Anchor\" href=\"#redis-的内存调度\">#</a> Redis 的内存调度</h2>\n<h3 id=\"redis-的过期策略\"><a class=\"markdownIt-Anchor\" href=\"#redis-的过期策略\">#</a> Redis 的过期策略</h3>\n<h4 id=\"设置过期时间\"><a class=\"markdownIt-Anchor\" href=\"#设置过期时间\">#</a> 设置过期时间</h4>\n<p>Redis 对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置 key 的有效时间。Expires 字典保存了所有键的过期时间，Expires 也被称为过期字段。</p>\n<p>一般主要包括 5 种处理过期方式，其中 expire 都是以秒为单位，pexpire 都是以毫秒为单位的。</p>\n<ul>\n<li><code>EXPIRE key seconds</code> ：将 key 的生存时间设置为 ttl 秒</li>\n<li><code>PEXPIRE key milliseconds</code> ：将 key 的生成时间设置为 ttl 毫秒</li>\n<li><code>EXPIREAT key timestamp</code> ：将 key 的过期时间设置为 timestamp 所代表的的秒数的时间戳</li>\n<li><code>PEXPIREAT key milliseconds-timestamp</code> ：将 key 的过期时间设置为 timestamp 所代表的的毫秒数的时间戳</li>\n<li><code>setex(String key, int seconds, String value)</code> ：字符串独有的方式，为指定的 key 设置值及其过期时间。如果 key 已经存在，<br>\nSETEX 命令将会替换旧的值。</li>\n</ul>\n<p>注：</p>\n<ul>\n<li>timestamp 为 unix 时间戳（例如：timestamp=1499788800 表示将在 2017.07.12 过期）</li>\n<li>1、2 两种方式是设置一个过期的时间段，就是咱们处理验证码最常用的策略，设置三分钟或五分钟后失效，把分钟数转换成秒或毫秒存储到 Redis 中。</li>\n<li>3、4 两种方式是指定一个过期的时间 ，比如优惠券的过期时间是某年某月某日，只是单位不一样。</li>\n<li>如果没有设置时间，那缓存就是永不过期</li>\n<li>如果设置了过期时间，之后又想让缓存永不过期，使用 persist key</li>\n</ul>\n<h4 id=\"过期策略\"><a class=\"markdownIt-Anchor\" href=\"#过期策略\">#</a> 过期策略</h4>\n<ul>\n<li>\n<p>定时过期（Active Expiration）</p>\n<p>含义：当一个键设置了过期时间时，Redis 会在键的过期时间到达时立即清除这个键。</p>\n<p>优点：这种方法可以保证内存被尽快释放，过期的键不会占用内存太久。</p>\n<p>缺点：定时过期需要为每个设置了过期时间的键创建一个定时器，这会占用大量的 CPU 资源来处理过期的数据，从而影响 Redis 的响应时间和吞吐量。</p>\n</li>\n<li>\n<p>被动过期（Lazy Expiration）</p>\n<p>含义：当访问一个键时，Redis 会检查这个键是否已经过期。如果过期，Redis 会删除这个键并返回相应的错误信息给客户端。</p>\n<p>优点：这种方法对 CPU 资源友好，因为它只在访问键时才会检查过期情况。</p>\n<p>缺点：如果过期的键没有被及时访问，那么它将继续占用内存，直到被访问或通过其他方式清理掉为止。</p>\n<p>流程：</p>\n<ol>\n<li>在进行 get 或 setnx 等操作时，先检查 key 是否过期，</li>\n<li>若过期，删除 key，然后执行相应操作；</li>\n<li>若没过期，直接执行相应操作</li>\n</ol>\n</li>\n<li>\n<p>定期过期（Periodic Reaping）</p>\n<p>含义：Redis 会周期性地检查过期的键，并删除一部分过期的键。这种策略试图在内存消耗和 CPU 使用之间找到一个平衡点，可以通过</p>\n<ul>\n<li>配置 redis.conf 的 hz 选项，默认为 10 （即 1 秒执行 10 次，100ms 一次，值越大说明刷新频率越快，对 Redis 性能损耗也越大）</li>\n<li>配置 redis.conf 的 maxmemory 最大值，当已用内存超过 maxmemory 限定时，就会触发主动清理策略。</li>\n</ul>\n<p>优点：通过周期性地检查和删除过期键，可以有效地减少内存浪费，同时通过限制删除操作的执行时长和频率来减少对 CPU 时间的影响。</p>\n<p>缺点：难以确定删除操作执行的时长和频率。如果删除操作执行得太频繁或执行的时间太长，定期删除策略就会退化成定时删除，导致占用太多的 CPU 执行时间。如果删除操作执行得太少或执行时间太短，定期删除策略又会类似于被动过期，导致内存浪费。</p>\n<p>流程：其核心是对指定个数个库的每一个库随机删除小于等于指定个数个过期 key：</p>\n<ol>\n<li>遍历每个数据库（就是 redis.conf 中配置的 “database” 数量，默认为 16）；\n<ol>\n<li>检查当前库中的指定个数个 key （默认是每个库检查 20 个，相当于该循环执行 20 次）：\n<ol>\n<li>如果当前库中没有一个 key 设置了过期时间，直接执行下一个库的遍历；</li>\n<li>随机获取一个设置了过期时间的 key，检查是否过期，如果过期则删除；</li>\n<li>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<p>综合策略</p>\n<p>在实际应用中，Redis 通常会结合使用上述三种策略来管理过期键。例如，Redis 可能会使用定期过期作为主要的过期策略，同时辅以被动过期来处理未被定期过期策略捕获的过期键。此外，对于一些关键操作，Redis 可能会采用定时过期来确保某些重要键在过期后能够立即被释放。</p>\n<h4 id=\"持久化中的过期\"><a class=\"markdownIt-Anchor\" href=\"#持久化中的过期\">#</a> 持久化中的过期</h4>\n<ul>\n<li>\n<p>RDB 对过期 key 的处理</p>\n<p>过期 key 对 RDB 没有任何影响</p>\n<ul>\n<li>从内存数据库持久化数据到 RDB 文件\n<ul>\n<li>持久化 key 之前，会检查是否过期，过期的 key 不进入 RDB 文件</li>\n</ul>\n</li>\n<li>从 RDB 文件恢复数据到内存数据库\n<ul>\n<li>数据载入数据库之前，会对 key 先进行过期检查，如果过期，不导入数据库（主库情况）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>AOF 对过期 key 的处理<br>\n过期 key 对 AOF 没有任何影响</p>\n<ul>\n<li>从内存数据库持久化数据到 AOF 文件：\n<ul>\n<li>当 key 过期后，还没有被删除，此时进行执行持久化操作（该 key 是不会进入 aof 文件的，因为没有发生修改命令）</li>\n<li>当 key 过期后，在发生删除操作时，程序会向 aof 文件追加一条 del 命令（在将来的以 aof 文件恢复数据的时候该过期的键就会被删掉）</li>\n</ul>\n</li>\n<li>AOF 重写\n<ul>\n<li>重写时，会先判断 key 是否过期，已过期的 key 不会重写到 aof 文件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"pipeline\"><a class=\"markdownIt-Anchor\" href=\"#pipeline\">#</a> Pipeline</h2>\n<p>Redis 的 Pipeline 功能允许客户端将多个命令打包成一个请求发送给 Redis 服务器，而不是逐个发送命令。这样做可以显著减少客户端与服务器之间的网络往返次数，从而提高<br>\n Redis 的性能和效率。下面详细介绍 Redis Pipeline 的工作原理、使用场景以及如何使用。</p>\n<p>Pipeline 的工作原理</p>\n<ol>\n<li>打包命令：客户端将多个 Redis 命令打包成一个请求，这个请求包含了所有命令的数据。</li>\n<li>发送请求：客户端一次性将打包好的请求发送给 Redis 服务器。</li>\n<li>执行命令：Redis 服务器接收到请求后，依次执行其中的所有命令。</li>\n<li>返回结果：Redis 服务器将各个命令的结果保存起来，并在所有命令执行完毕后，一次性将所有结果返回给客户端。</li>\n<li>处理结果：客户端接收到所有命令的结果后，按顺序处理这些结果。</li>\n</ol>\n<p>Pipeline 的优点</p>\n<ul>\n<li>减少网络延迟：通过减少客户端与服务器之间的网络往返次数，Pipeline 可以显著降低网络延迟，提高整体性能。</li>\n<li>提高吞吐量：由于减少了网络交互次数，客户端可以更快地处理更多的命令。</li>\n<li>事务性操作：虽然 Pipeline 不保证命令执行的原子性，但是它可以模拟事务的行为，即可以将一组命令作为一个整体发送和接收结果。</li>\n</ul>\n<p>使用场景</p>\n<ul>\n<li>批量操作：当你需要执行一系列相关联的命令时，使用 Pipeline 可以提高效率。</li>\n<li>性能优化：在需要频繁与 Redis 进行交互的应用场景中，使用 Pipeline 可以减少网络开销，提升性能。</li>\n<li>模拟事务：虽然 Redis 的 Pipeline 不保证命令的原子性，但是在不需要严格事务性的场景下，可以使用 Pipeline 来模拟事务行为。</li>\n</ul>\n<p>如何使用 Pipeline<br>\n 在不同的 Redis 客户端库中，使用 Pipeline 的方式略有不同。以下是在几种常见语言中使用 Pipeline 的示例：</p>\n<p>JavaScript (Node.js)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> redis = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;redis&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> client = redis.<span class=\"title function_\">createClient</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">client.<span class=\"title function_\">pipeline</span>()</span><br><span class=\"line\">    .<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;foo&#x27;</span>, <span class=\"string\">&#x27;bar&#x27;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">exec</span>(<span class=\"function\">(<span class=\"params\">err, replies</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(replies); <span class=\"comment\">// replies is an array of responses</span></span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>Python (redis-py)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const redis = require(<span class=\"string\">&quot;redis&quot;</span>);</span><br><span class=\"line\">const client = redis.createClient();</span><br><span class=\"line\"></span><br><span class=\"line\">client.pipeline()</span><br><span class=\"line\">  .<span class=\"built_in\">set</span>(<span class=\"string\">&#x27;foo&#x27;</span>, <span class=\"string\">&#x27;bar&#x27;</span>)</span><br><span class=\"line\">  .get(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"built_in\">exec</span>((err, replies) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) throw err;</span><br><span class=\"line\">    console.log(replies); // replies <span class=\"keyword\">is</span> an array of responses</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>java (jedis)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">Jedis jedis=<span class=\"keyword\">new</span> <span class=\"title class_\">Jedis</span>(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        Pipeline pipelined=jedis.pipelined();</span><br><span class=\"line\">        pipelined.set(<span class=\"string\">&quot;foo&quot;</span>,<span class=\"string\">&quot;bar&quot;</span>);</span><br><span class=\"line\">        pipelined.get(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">        List&lt;Object&gt; results=pipelined.syncAndReturnAll();</span><br><span class=\"line\">        System.out.println(results);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>注意事项</p>\n<ul>\n<li>命令数量：虽然 Pipeline 可以显著提高性能，但如果打包的命令数量过多，可能会导致单个请求的体积过大，增加客户端的等待时间，并可能导致网络阻塞。</li>\n<li>命令执行顺序：Pipeline 中的命令是按照发送顺序执行的，因此需要确保命令间的依赖关系不会导致错误。</li>\n<li>错误处理：如果 Pipeline 中的某条命令执行失败，整个 Pipeline 的结果都会受到影响。因此，在处理 Pipeline<br>\n 的结果时，需要注意检查每个命令的执行状态。</li>\n</ul>\n<p>原生批命令 (mset, mget) 与 Pipeline 对比</p>\n<ul>\n<li>原生批命令是原子性，pipeline 是非原子性</li>\n<li>原生批命令一命令多个 key, 但 pipeline 支持多命令（存在事务），非原子性</li>\n<li>原生批命令是服务端实现，而 pipeline 需要服务端与客户端共同完成</li>\n</ul>\n<h2 id=\"redis-事务\"><a class=\"markdownIt-Anchor\" href=\"#redis-事务\">#</a> Redis 事务</h2>\n<p>Redis 事务是 Redis 中的一个重要特性，它允许客户端在一个事务中执行多个命令，并确保这些命令要么全部执行成功，要么全部执行失败。在事务中，客户端可以提交或回滚整个事务，而不需要关心事务中的命令是否成功执行。尽管<br>\n Redis 事务并不提供传统意义上的 ACID 事务特性（原子性、一致性、隔离性、持久性），但它确实提供了一些基本的功能，使得开发者可以更方便地处理一系列相关的命令。</p>\n<p>Redis 事务的主要功能包括：</p>\n<ul>\n<li>命令队列：客户端可以将多个命令放入一个队列中，然后通过 EXEC 命令一次性发送给 Redis 服务器执行。</li>\n<li>监视（WATCH）：客户端可以监视一个或多个键，如果在执行 EXEC 命令之前这些键被其他客户端修改，则事务会被取消。</li>\n<li>取消（DISCARD）：如果在事务执行之前发现某些条件不满足，客户端可以选择取消事务。</li>\n</ul>\n<p>Redis 事务的实现分为几个步骤：</p>\n<ul>\n<li>事务开始：客户端通过 MULTI 命令开始一个事务。</li>\n<li>命令入队：在 MULTI 命令之后，客户端可以发送任意数量的命令，这些命令将被放入事务队列中，但不会立即执行。</li>\n<li>事务执行：通过 EXEC 命令，客户端可以执行事务队列中的所有命令。如果在此之前使用了 WATCH 命令监视的键被修改，则事务会被取消。</li>\n<li>取消事务：如果在执行 EXEC 命令之前，客户端想要取消事务，可以使用 DISCARD 命令。</li>\n</ul>\n<p>Redis 中事务的特性有：</p>\n<ul>\n<li>原子性：一旦事务开始执行，Redis 会保证事务中的所有命令要么全部执行成功，要么都不执行。然而，如果命令在执行过程中出现错误（如类型错误），Redis<br>\n 会继续执行后续命令。</li>\n<li>一致性：Redis 事务在一定程度上保证了一致性，特别是通过使用 WATCH 命令监视键的变化，可以防止脏读。</li>\n<li>隔离性：由于 Redis 是单线程的，事务中的命令会按顺序执行，因此不存在并发事务之间的隔离性问题。</li>\n<li>持久性：Redis 的持久化机制（如 RDB 或 AOF）保证了数据的持久性，但这与事务无关。</li>\n</ul>\n<p>Redis 事务的限制</p>\n<ul>\n<li>不支持回滚：如果事务中的某个命令失败，Redis 会继续执行剩余的命令，并不会回滚之前的命令。</li>\n<li>错误处理：如果事务中的命令出现错误，Redis 会记录错误并继续执行后续命令。客户端需要处理这些错误。</li>\n<li>性能考虑：虽然事务可以减少网络往返次数，但如果事务中的命令数量过多，可能会导致单个请求过大，反而影响性能。</li>\n</ul>\n<p>Redis 事务的使用场景</p>\n<ul>\n<li>批量操作：当需要执行一系列相关的命令时，可以使用事务来减少网络往返次数，提高性能。</li>\n<li>乐观锁：通过 WATCH 命令监视键的变化，可以实现乐观锁机制，确保在执行事务之前键没有被其他客户端修改。</li>\n<li>模拟事务：虽然 Redis 事务不提供严格的 ACID 特性，但在不需要强一致性的场景下，可以使用事务来模拟事务行为。</li>\n</ul>\n<h2 id=\"redis-多线程\"><a class=\"markdownIt-Anchor\" href=\"#redis-多线程\">#</a> Redis 多线程</h2>\n<p>Redis 作为一种高性能的键值存储系统，最初是单线程设计的，这意味着 Redis 在处理客户端的请求时，包括获取 (socket 读)<br>\n、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的单线程。但如果严格来讲从 Redis 4<br>\n 之后并不是单线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 key 的删除等等。<br>\n这样的设计保证了数据的一致性和简单性，但也限制了 Redis 在多核 CPU 环境下的性能潜力。从 Redis 6.0 开始，Redis<br>\n 引入了多线程的支持，以充分利用现代多核处理器的优势。</p>\n<p>Redis 6 为何引入多线程？</p>\n<p>随着目前行业内越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的<br>\n QPS。常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点，比如：</p>\n<ul>\n<li>\n<p>要管理的 Redis 服务器太多，维护代价大；</p>\n</li>\n<li>\n<p>某些适用于单个 Redis 服务器的命令不适用于数据分区；</p>\n</li>\n<li>\n<p>数据分区无法解决热点读 / 写问题；</p>\n</li>\n<li>\n<p>数据偏斜，重新分配和放大 / 缩小变得更加复杂等等。</p>\n</li>\n</ul>\n<p>从 Redis 自身角度来说，因为读写网络的 read/write 系统调用占用了 Redis 执行期间大部分 CPU 时间，瓶颈主要在于网络的 IO 消耗，<br>\n 优化主要有两个方向:</p>\n<ul>\n<li>\n<p>提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式；</p>\n</li>\n<li>\n<p>使用多线程充分利用多核，典型的实现比如 Memcached。</p>\n</li>\n</ul>\n<p>协议栈优化的这种方式跟 Redis 关系不大，支持多线程是一种最有效最便捷的操作方式。所以总结起来，Redis 支持多线程主要就是两个原因：</p>\n<ul>\n<li>可以充分利用服务器 CPU 资源，目前主线程只能利用一个核；</li>\n<li>多线程任务可以分摊 Redis 同步 IO 读写负荷。</li>\n</ul>\n<p>Redis 多线程的工作原理</p>\n<p>在 Redis 6.0 中，多线程主要用于处理客户端的网络 I/O 操作，包括读取客户端请求、解析请求以及将响应写回到客户端。具体来说：</p>\n<ul>\n<li>多线程 I/O：Redis 在主线程之外创建了若干个 I/O 子线程，这些子线程负责读取客户端的请求数据，并将其传递给主线程进行处理。主线程处理完请求后，子线程再负责将响应写回到客户端。</li>\n<li>命令执行：尽管引入了多线程，Redis 的命令执行仍然是单线程的。这意味着 Redis 仍然保证了数据的一致性，因为所有命令都在同一个线程中顺序执行。</li>\n</ul>\n<p>配置多线程</p>\n<p>Redis 6.0 中的多线程支持需要在 redis.conf 文件中进行配置。Redis 6 的多线程默认是禁用的，只使用主线程。可以通过设置<br>\n io-threads-do-reads 参数来启用多线程 I/O 支持，并指定子线程的数量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">io-threads 4  # 设置子线程的数量</span><br><span class=\"line\">io-threads-do-reads yes  # 启用子线程读取</span><br></pre></td></tr></table></figure>\n<p>官方建议线程数应小于机器的核数，并且给出了一个简单的指导原则：对于 4 核的机器，建议设置 2 或 3 个线程；对于 8 核的机器，建议设置<br>\n 6 个线程。线程数并不是越多越好，一般超过 8 个线程就没有太多的意义了。</p>\n<p>使用场景</p>\n<ul>\n<li>网络 I/O 密集型操作：当 Redis 实例面临大量的网络 I/O 负载时，多线程可以帮助减轻主线程的压力，提高系统的整体吞吐量。</li>\n<li>多核 CPU 利用率：在多核处理器环境下，多线程可以让 Redis 更好地利用硬件资源，特别是在处理高并发请求时。</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>单线程命令执行：尽管 Redis 引入了多线程支持，但命令的执行仍然是单线程的。这意味着 Redis 依然保证了数据的一致性和事务的安全性。</li>\n<li>适用性：多线程功能最适合在网络 I/O 成为性能瓶颈的情况下使用。如果 Redis 实例的 CPU 占用率已经很高，那么开启多线程可能并不会带来显著的性能提升。</li>\n<li>兼容性：在 Redis 的其他模式（如集群模式）中，多线程功能可能不完全适用，因此在使用时需要谨慎。</li>\n</ul>\n<h2 id=\"redis-集群\"><a class=\"markdownIt-Anchor\" href=\"#redis-集群\">#</a> Redis 集群</h2>\n<h3 id=\"redis-主从\"><a class=\"markdownIt-Anchor\" href=\"#redis-主从\">#</a> Redis 主从</h3>\n<p>和 MySQL 需要主从复制的原因一样，Redis 虽然读取写入的速度都特别快，但是也会产生性能瓶颈，特别是在读压力上，为了分担压力，Redis 支持主从复制。<br>\nRedis 的主从结构包括一主一从，一主多从或级联结构，复制类型分为全量同步和增量同步。<br>\n下图为级联结构：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1557639147418-27b8b69d-f0a8-4ec0-a771-99c43783190d.png\" class=\"\" title=\"1557639147418-27b8b69d-f0a8-4ec0-a771-99c43783190d.png\">\n<h4 id=\"全量同步\"><a class=\"markdownIt-Anchor\" href=\"#全量同步\">#</a> 全量同步</h4>\n<p>Redis 全量复制一般发生在 slave 的初始阶段，这时 slave 需要将 master 上的数据都复制一份，具体步骤如下：</p>\n<ol>\n<li>slave 连接 master，发送 SYNC 命令；</li>\n<li>master 街道 SYNC 命令后，执行 BGSAVE 命令生产 RDB 文件并使用缓冲区记录此后执行的所有写命令；</li>\n<li>master 的 BGSAVE 执行完成后，向所有的 slave 发送快照文件，并在发送过程中继续记录执行的写命令；</li>\n<li>slave 收到快照后，丢弃所有的旧数据，载入收到的数据；</li>\n<li>master 快照发送完成后就会开始向 slave 发送缓冲区的写命令；</li>\n<li>slave 完成对快照的载入，并开始接受命令请求，执行来自 master 缓冲区的写命令；</li>\n<li>slave 完成上面的数据初始化后就可以开始接受用户的读请求了。</li>\n</ol>\n<p>大致流程图如下：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1557639652986-bfbcd0af-6688-4047-83df-8f3bea5d0875.png\" class=\"\" title=\"1557639652986-bfbcd0af-6688-4047-83df-8f3bea5d0875.png\">\n<h4 id=\"增量复制\"><a class=\"markdownIt-Anchor\" href=\"#增量复制\">#</a> 增量复制</h4>\n<p>增量复制实际上就是在 slave 初始化完成后开始正常工作时 master 发生写操作同步到 slave 的过程。增量复制的具体步骤如下：</p>\n<ol>\n<li>主节点记录复制偏移量：<br>\n在全量复制完成后，主节点开始记录其发送给从节点的所有写命令，并维护一个复制偏移量（replication<br>\noffset），这个偏移量表示了主节点已发送了多少字节的数据给从节点。</li>\n<li>从节点记录复制偏移量：<br>\n同时，从节点也会记录接收到的命令及其对应的偏移量。这使得从节点能够知道它已经处理了多少数据。</li>\n<li>主节点维护积压队列：<br>\n为了支持增量复制，主节点会维护一个 “积压队列”（backlog）。这是一个固定大小的环形缓冲区，用来存储最近的写入命令。这样即使从节点暂时断开连接，也能在重新连接后获取到断开期间丢失的数据。</li>\n<li>从节点请求增量数据：<br>\n当从节点重新连接到主节点时，它会发送一个 PSYNC 命令，附带它最后已知的复制偏移量和主节点的运行 ID（run<br>\nID）。主节点会检查这个信息，并决定是否进行增量复制。</li>\n<li>增量复制：\n<ul>\n<li>如果主节点发现从节点提供的偏移量在积压队列的有效范围内，则主节点会从该偏移量开始向从节点发送所有后续的写命令，这就是增量复制。</li>\n<li>如果偏移量不在有效范围内，或者从节点提供的运行 ID 与主节点当前的运行 ID 不符（可能是因为主节点重启过），那么主节点会选择进行一次全量复制。</li>\n</ul>\n</li>\n<li>从节点应用增量数据：<br>\n从节点接收到增量数据后，会将其应用到自己的数据集上，使自己的数据与主节点保持一致。</li>\n</ol>\n<p>Redis 主从同步的特点</p>\n<ol>\n<li>采用异步复制；</li>\n<li>可以一主多从；</li>\n<li>主从复制对于 master 来说是非阻塞的，也就是说 slave 在进行主从复制的过程中，master 依然可以处理请求；</li>\n<li>主从复制对于 slave 来说也是非阻塞的，也就是说 slave 在进行主从复制的过程中也可以接受外界的查询请求，只不过这时候返回的数据不一定是正确的。为了避免这种情况发生，可以在 slave 的配置文件中配置，在同步过程中阻止查询；</li>\n<li>每个 slave 可以接受来自其他 slave 的连接；</li>\n<li>主从复制提高了 Redis 服务的扩展性，避免单节点问题，另外也为数据备份冗余提供了一种解决方案；</li>\n</ol>\n<p>为了降低主 redis 服务器写磁盘压力带来的开销，可以配置让主 redis 不在将数据持久化到磁盘，而是通过连接让一个配置的从 redis 服务器及时的将相关数据持久化到磁盘，不过这样会存在一个问题，就是主 redis 服务器一旦重启，因为主 redis 服务器数据为空，这时候通过主从同步可能导致从 redis 服务器上的数据也被清空；</p>\n<h4 id=\"redis主从复制搭建\"><a class=\"markdownIt-Anchor\" href=\"#redis主从复制搭建\">#</a> Redis 主从复制搭建</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">下载软件包</span></span><br><span class=\"line\">wget http://download.redis.io/releases/redis-4.0.10.tar.gz</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">解压软件包，主从都需要做（本次是单机多实例来做主从）</span></span><br><span class=\"line\">tar xf redis-4.0.10.tar.gz -C /home/redis/6379/</span><br><span class=\"line\">tar xf redis-4.0.10.tar.gz -C /home/redis/6380/</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">编译安装</span></span><br><span class=\"line\">yum install -y gcc gcc++</span><br><span class=\"line\">make MALLOC=libc</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">启动Redis（修改了Redis运行方式为守护进程方式）</span></span><br><span class=\"line\">/home/redis/6379/redis-4.0.10/src/redis-server /home/redis/6379/redis-4.0.10/redis.conf</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">从库做相同的操作，由于是单机多实例，所以修改从库的port为6380，启动从库</span></span><br><span class=\"line\">/home/redis/6380/redis-4.0.10/src/redis-server /home/redis/6380/redis-4.0.10/redis.conf</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">Redis测试</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">master：</span></span><br><span class=\"line\">./src/redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; set name 111</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get name</span><br><span class=\"line\">&quot;111&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">slave：</span></span><br><span class=\"line\">./src/redis-cli -p 6380</span><br><span class=\"line\">127.0.0.1:6380&gt; set name slave</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6380&gt; get name</span><br><span class=\"line\">&quot;slave&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">主从搭建</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">1、只需要配置slave，指明master的IP地址和port就可以了，配置完后重启实例</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">slaveof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class=\"line\">slaveof 127.0.0.1 6379</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">测试：</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">master：</span></span><br><span class=\"line\">./src/redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; set password 123456</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get password</span><br><span class=\"line\">&quot;123456&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">slave：</span></span><br><span class=\"line\">./src/redis-cli -p 6380</span><br><span class=\"line\">127.0.0.1:6380&gt; get password</span><br><span class=\"line\">&quot;123456&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">在master上设定键值对，在slave上能够准确的查出来，主从配置成功</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"redis-哨兵\"><a class=\"markdownIt-Anchor\" href=\"#redis-哨兵\">#</a> Redis 哨兵</h3>\n<p>在主从复制实现之后，如果想对 master 进行监控，Redis 提供了一种哨兵机制，哨兵的含义就是监控 Redis 系统的运行状态，并做相应的响应。</p>\n<p>其主要的功能有以下两点：</p>\n<ol>\n<li>监控所有 Redis 节点是否正常运行；</li>\n<li>master 故障后可以通过投票机制，从 slave 中选举出新的 master，保证集群正常运行。</li>\n</ol>\n<p>在一个一主多从的集群中，可以启用多个哨兵进行监控以保证集群足够稳健，这种情况下，哨兵不仅监控主从服务，哨兵之间也会相互监控，建议哨兵至少 3 个并且是奇数。</p>\n<p>哨兵主要用于管理多个 Redis 服务器，主要有以下三个任务：</p>\n<ol>\n<li>监控：哨兵会不断的检测 master 和 slave 之间是否运行正常；</li>\n<li>提醒：当监控的某个 Redis 出现问题，哨兵可以通过 API 向管理员或其他应用程序发送通知；</li>\n<li>故障迁移：当一个 master 不能正常工作时，哨兵会开始一次自动故障迁移操作，它会将失效 master 的其中一个 slave 提升为 master，并让失效 master 和其他 slave 该为复制新的 master。<br>\n当客户端试图连接失效的 master 时，集群也会向客户端返回新的 master 地址，使得集群可以使用新的 master 代替失效的 master。</li>\n</ol>\n<h4 id=\"redis-哨兵的工作原理\"><a class=\"markdownIt-Anchor\" href=\"#redis-哨兵的工作原理\">#</a> Redis 哨兵的工作原理</h4>\n<p>Redis 哨兵（Sentinel）是一个分布式系统，用于监控 Redis 主节点和从节点的健康状况，并在主节点发生故障时自动进行故障转移。<br>\n哨兵系统由一组哨兵进程组成，它们相互协作来完成监控、通知、选举以及故障转移的任务。下面详细介绍哨兵的工作原理：</p>\n<ol>\n<li>监控（Monitoring）\n<ul>\n<li>心跳检测：每个哨兵（Sentinel）会定期向主节点、从节点以及其他哨兵发送心跳消息，以此来监控这些节点的健康状况。</li>\n<li>配置文件：哨兵的配置文件中定义了需要监控的主节点的信息，包括名称、IP 地址和端口号等。</li>\n</ul>\n</li>\n<li>选举（Election）\n<ul>\n<li>选举机制：当某个哨兵发现主节点不可用时，它会向其他哨兵发起询问，以确认主节点是否真的出现了故障。</li>\n<li>投票过程：每个哨兵都有机会投票选出一个领导者（leader），领导者负责执行实际的故障转移操作。</li>\n<li>多数原则：为了防止脑裂现象（Split-brain 指的是系统的一部分节点认为另一部分节点已经失败，而实际上那些被认为失败的节点仍在正常工作。），哨兵系统采用多数原则来决定是否进行故障转移。<br>\n只有当超过半数的哨兵同意主节点已经失效时，才会执行故障转移。</li>\n</ul>\n</li>\n<li>故障转移（Failover）\n<ul>\n<li>选择从节点：一旦确定主节点失效，领导者哨兵会选择一个合适的从节点来升级为主节点。</li>\n<li>数据同步：被选中的从节点会被提升为主节点，并且其他从节点会重新连接到新的主节点。</li>\n<li>客户端通知：完成故障转移后，哨兵会更新客户端的配置文件，使客户端能够连接到新的主节点。</li>\n</ul>\n</li>\n<li>配置更新（Configuration Updates）\n<ul>\n<li>自动配置更新：哨引不仅会更新客户端的配置文件，还会自动更新从节点的配置，使它们指向新的主节点。</li>\n<li>持续监控：故障转移完成后，哨兵将继续监控新的主节点和从节点的健康状况。</li>\n</ul>\n</li>\n<li>客户端通知\n<ul>\n<li>通知机制：哨兵会通知客户端新的主节点地址，以便客户端可以继续正常工作。</li>\n<li>透明切换：这一过程对客户端来说应该是透明的，即客户端不需要做任何额外的操作即可继续访问 Redis 服务。</li>\n</ul>\n</li>\n</ol>\n<p>实现细节如下：</p>\n<ul>\n<li>哨兵通信：哨兵之间通过发布 / 订阅模式进行通信，确保所有哨兵都能及时了解系统状态的变化。</li>\n<li>命令交互：哨兵使用特定的命令（如 SENTINEL 命令）来查询和管理哨兵系统。</li>\n</ul>\n<p>缺点</p>\n<ul>\n<li>主从服务器的数据要经常进行主从复制，这样会造成性能下降；</li>\n<li>当主服务器宕机后，从服务器切换成主服务器的那段时间，服务是不可用的。</li>\n</ul>\n<h4 id=\"redis哨兵模式搭建\"><a class=\"markdownIt-Anchor\" href=\"#redis哨兵模式搭建\">#</a> Redis 哨兵模式搭建</h4>\n<p>主从模式搭建看上面的步骤，以下主要是在主从搭建完的基础上搭建哨兵模式。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">配置sentinel.conf文件</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">工作路径，注意路径不要和主重复</span></span><br><span class=\"line\">dir &quot;/tmp/23679&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">哨兵监控的master，主从配置一样，这里只用输入redis主节点的ip/port和法定人数。</span></span><br><span class=\"line\">sentinel monitor mymaster 192.168.125.128 6379 1</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">master或slave多长时间（默认30秒）不能使用后标记为s_down状态。</span></span><br><span class=\"line\">sentinel down-after-milliseconds mymaster 5000</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">若sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换），则认为本次failover失败。</span></span><br><span class=\"line\">sentinel failover-timeout mymaster 18000</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步，有几个slave就设置几个</span></span><br><span class=\"line\">sentinel parallel-syncs mymaster 2</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">启动哨兵</span></span><br><span class=\"line\">/home/redis/26379/redis-4.0.10/src/redis-server /home/redis/26379/redis-4.0.10/sentinel.conf --sentinel</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">通过哨兵查看集群状态</span></span><br><span class=\"line\">./src/redis-cli -p 26379</span><br><span class=\"line\">127.0.0.1:26379&gt; sentinel master mymaster</span><br><span class=\"line\">1) &quot;name&quot;</span><br><span class=\"line\">2) &quot;mymaster&quot;</span><br><span class=\"line\">3) &quot;ip&quot;</span><br><span class=\"line\">4) &quot;172.16.0.169&quot;</span><br><span class=\"line\">5) &quot;port&quot;</span><br><span class=\"line\">6) &quot;6379&quot;</span><br><span class=\"line\">7) &quot;runid&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:26379&gt; sentinel slaves mymaster</span><br><span class=\"line\">1)  1) &quot;name&quot;                                           # slave 1</span><br><span class=\"line\">    2) &quot;127.0.0.1:6381&quot;</span><br><span class=\"line\">    3) &quot;ip&quot;</span><br><span class=\"line\">    4) &quot;127.0.0.1&quot;</span><br><span class=\"line\">    5) &quot;port&quot;</span><br><span class=\"line\">    6) &quot;6381&quot;</span><br><span class=\"line\">    7) &quot;runid&quot;</span><br><span class=\"line\">    8) &quot;0419f313098f6af1b4ccdb189d6beb22edf27a1c&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">2)  1) &quot;name&quot;                                            # slave2</span><br><span class=\"line\">    2) &quot;127.0.0.1:6380&quot;</span><br><span class=\"line\">    3) &quot;ip&quot;</span><br><span class=\"line\">    4) &quot;127.0.0.1&quot;</span><br><span class=\"line\">    5) &quot;port&quot;</span><br><span class=\"line\">    6) &quot;6380&quot;</span><br><span class=\"line\">    7) &quot;runid&quot;</span><br><span class=\"line\">    8) &quot;5b00b502a93245f7916efd1f564bd40b16aa7b22&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">模拟主down掉</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">观察sentinel的状态</span></span><br><span class=\"line\">127.0.0.1:26379&gt; sentinel master mymaster</span><br><span class=\"line\">1) &quot;name&quot;</span><br><span class=\"line\">2) &quot;mymaster&quot;</span><br><span class=\"line\">3) &quot;ip&quot;</span><br><span class=\"line\">4) &quot;127.0.0.1&quot;</span><br><span class=\"line\">5) &quot;port&quot;</span><br><span class=\"line\">6) &quot;6381&quot;                # 已经从6379切换到6381</span><br><span class=\"line\">7) &quot;runid&quot;</span><br><span class=\"line\">8) &quot;0419f313098f6af1b4ccdb189d6beb22edf27a1c&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">相应的slave也做了切换</span></span><br><span class=\"line\">127.0.0.1:26379&gt; sentinel slaves mymaster</span><br><span class=\"line\">1)  1) &quot;name&quot;</span><br><span class=\"line\">    2) &quot;127.0.0.1:6379&quot;</span><br><span class=\"line\">    3) &quot;ip&quot;</span><br><span class=\"line\">    4) &quot;127.0.0.1&quot;</span><br><span class=\"line\">    5) &quot;port&quot;</span><br><span class=\"line\">    6) &quot;6379&quot;</span><br><span class=\"line\">    7) &quot;runid&quot;</span><br><span class=\"line\">    8) &quot;&quot;</span><br><span class=\"line\">    9) &quot;flags&quot;</span><br><span class=\"line\">   10) &quot;s_down,slave,disconnected&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">2)  1) &quot;name&quot;</span><br><span class=\"line\">    2) &quot;127.0.0.1:6380&quot;</span><br><span class=\"line\">    3) &quot;ip&quot;</span><br><span class=\"line\">    4) &quot;127.0.0.1&quot;</span><br><span class=\"line\">    5) &quot;port&quot;</span><br><span class=\"line\">    6) &quot;6380&quot;</span><br><span class=\"line\">    7) &quot;runid&quot;</span><br><span class=\"line\">    8) &quot;5b00b502a93245f7916efd1f564bd40b16aa7b22&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"redis集群\"><a class=\"markdownIt-Anchor\" href=\"#redis集群\">#</a> Redis 集群</h3>\n<p>Redis 在 3.0 版本开始正式引入集群特性。Redis 集群是一个分布式，高容错的内存 K/V 系统，集群可以使用的功能是普通单机 Redis 所使用的功能的一个子集。比如，Redis 集群并不支持处理多个 keys 的命令，因为这需要在不同节点间移动数据，从而达不到像 Redis 那样的性能，在高负载的情况下可能会出现无法预估的错误。</p>\n<p>Redis 集群有以下几个重要的特征：</p>\n<ol>\n<li>Redis 集群的分片特征在于将空间拆分为 16384 个槽位，某一个节点负责其中一些槽位；</li>\n<li>Redis 集群提供一定程度的可用性，可以在某个节点宕机或者不可达的情况继续处理命令；</li>\n<li>Redis 集群不存在中心节点或代理节点，集群的其中一个最重要的设计目标是达到线性可扩展性；</li>\n</ol>\n<p>其架构如下：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1557644289413-437c9a81-dcb1-40bc-8549-2a4867b797c2.png\" class=\"\" title=\"1557644289413-437c9a81-dcb1-40bc-8549-2a4867b797c2.png\">\n<p>其中每一个圆代表一个节点，任何两个节点是互通的，可以归纳以下几点：</p>\n<ul>\n<li>所有的节点相互连接；</li>\n<li>集群消息通信通过集群总线通信，，集群总线端口大小为客户端服务端口 + 10000，这个 10000 是固定值；</li>\n<li>节点与节点之间通过二进制协议进行通信；</li>\n<li>客户端和集群节点之间通信和通常一样，通过文本协议进行；</li>\n<li>集群节点不会代理查询；</li>\n</ul>\n<h4 id=\"redis集群的原理\"><a class=\"markdownIt-Anchor\" href=\"#redis集群的原理\">#</a> Redis 集群的原理</h4>\n<p>Redis 集群是一种分布式存储解决方案，旨在通过数据分片和复制来实现高可用性和可扩展性。以下是 Redis 集群的详细运行原理：</p>\n<ol>\n<li>\n<p>哈希槽（Hash Slots）<br>\nRedis 集群中有一个长度为 16384 的哈希槽列表，编号为 0 到 16383。这些哈希槽是虚拟的，并不是真实存在的物理实体。</p>\n<ul>\n<li>哈希计算：当一个键（Key）被存储时，Redis 会计算该键的哈希值，并将哈希值映射到 0 到 16383 之间的某个哈希槽上。<br>\n具体映射公式为：slot = CRC16 (key) mod 16384，其中 CRC16 是一个循环冗余校验算法。</li>\n</ul>\n</li>\n<li>\n<p>数据分片</p>\n<ul>\n<li>槽分配：集群中的每个 Master 节点负责一部分哈希槽。例如，如果集群中有 3 个 Master 节点，它们可能会分别负责以下槽范围：\n<ul>\n<li>Master 1: 槽 0-5461</li>\n<li>Master 2: 槽 5462-10923</li>\n<li>Master 3: 槽 10924-16383</li>\n</ul>\n</li>\n<li>键的分配：每个键根据其哈希值被分配到相应的槽上，进而确定存储在哪个 Master 节点上。</li>\n</ul>\n<p>这里值得一提的是，在 Redis Cluster 中，只有 Master 才拥有槽的所有权。如果是某个 Master 的 slave，这个 slave 只负责槽的使用，但是没有所有权。<br>\n槽与节点结构如下所示：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1557644627263-0159f2b0-f9ff-46d6-acd3-abc6a22d8e87.png\" class=\"\" title=\"1557644627263-0159f2b0-f9ff-46d6-acd3-abc6a22d8e87.png\">\n</li>\n<li>\n<p>主从复制</p>\n<ul>\n<li>主节点（Master）：每个 Master 节点负责处理写操作，并拥有槽的所有权。</li>\n<li>从节点（Slave）：每个 Master 节点可以有多个从节点，从节点负责处理读操作，并作为 Master 节点的备份。</li>\n<li>数据同步：从节点通过复制机制与 Master 节点保持数据一致。</li>\n</ul>\n</li>\n<li>\n<p>故障转移</p>\n<ul>\n<li>自动故障转移：当一个 Master 节点失效时，集群会自动选择一个从节点提升为主节点，以保持集群的服务可用性。</li>\n<li>选举机制：集群中的其他节点会通过 Gossip 协议来协商并选举一个新的 Master 节点。</li>\n</ul>\n</li>\n<li>\n<p>集群间的通信</p>\n<ul>\n<li>Gossip 协议：Redis 集群使用 Gossip 协议来交换节点状态信息。每个节点周期性地与其他节点交换信息，以了解集群中其他节点的状态。</li>\n<li>状态同步：通过 Gossip 协议，节点可以得知集群中的其他节点是否在线、是否有新的节点加入等信息。</li>\n</ul>\n</li>\n<li>\n<p>命令路由</p>\n<ul>\n<li>客户端路由：客户端可以连接到任何一个节点，集群内部会根据键的哈希值来确定该键所在的节点，并将请求路由到正确的节点。</li>\n<li>命令转发：如果客户端请求的键不在当前节点上，那么该节点会将请求转发到正确的节点上。</li>\n</ul>\n</li>\n<li>\n<p>初始化与配置</p>\n<ul>\n<li>初始化脚本：使用 redis-trib.rb 脚本来初始化集群。该脚本会自动分配槽到各个 Master 节点，并配置从节点。</li>\n<li>配置文件：每个节点的配置文件中需要指定集群模式和其他相关参数。</li>\n</ul>\n</li>\n<li>\n<p>投票机制</p>\n<ul>\n<li>投票过程：集群中所有 Master 节点参与投票。如果超过半数的 Master 节点与某个 Master 节点通信超时（cluster-node-timeout），则认为该<br>\n Master 节点已挂掉。</li>\n<li>集群不可用状态：\n<ul>\n<li>单个 Master 挂掉：如果某个 Master 节点挂掉，并且没有从节点，集群进入 fail 状态。</li>\n<li>多数 Master 挂掉：如果超过半数的 Master 节点挂掉，无论是否有从节点，集群也进入 fail 状态。</li>\n</ul>\n</li>\n</ul>\n<p>投票机制原理图如下：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1557645005629-3f876a67-45ec-4285-8821-3ebf42dd4345.png\" class=\"\" title=\"1557645005629-3f876a67-45ec-4285-8821-3ebf42dd4345.png\">\n</li>\n</ol>\n<h4 id=\"redis集群搭建\"><a class=\"markdownIt-Anchor\" href=\"#redis集群搭建\">#</a> Redis 集群搭建</h4>\n<p>要求：至少 6 个节点，3 主 3 从。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">Redis.conf配置：大致如下</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">port 7000</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">cluster-enabled <span class=\"built_in\">yes</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">cluster-config-file nodes.conf</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">cluster-node-timeout 5000</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">appendonly <span class=\"built_in\">yes</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">创建集群</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">redis集群的命令工具redis-trib可以让我们创建集群变得非常简单。</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">redis-trib是一个用ruby写的脚本，用于给各节点发指令创建集群、检查集群状态或给集群重新分片等。</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">redis-trib在Redis源码的src目录下，需要gem redis来运行redis-trib。</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">安装ruby环境</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">yum install rubygems -y</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">1.安装curl</span></span><br><span class=\"line\">sudo yum install curl</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">2. 安装RVM</span></span><br><span class=\"line\">curl -L get.rvm.io | bash -s stable </span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">3.</span> </span><br><span class=\"line\">source /usr/local/rvm/scripts/rvm</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">4. 查看rvm库中已知的ruby版本</span></span><br><span class=\"line\">rvm list known</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">5. 安装一个ruby版本</span></span><br><span class=\"line\">rvm install 2.3.3</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">6. 使用一个ruby版本</span></span><br><span class=\"line\">rvm use 2.3.3</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">7. 设置默认版本</span></span><br><span class=\"line\">rvm remove 2.0.0</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">8. 卸载一个已知版本</span></span><br><span class=\"line\">ruby --version</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">9. 再安装redis就可以了</span></span><br><span class=\"line\">gem install redis</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">启动集群</span></span><br><span class=\"line\">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">测试集群</span></span><br><span class=\"line\">7000/redis-4.0.10/src/redis-cli -c -p 7000</span><br><span class=\"line\">127.0.0.1:7000&gt; set name alex</span><br><span class=\"line\"><span class=\"meta prompt_\">-&gt; </span><span class=\"language-bash\">Redirected to slot [5798] located at 127.0.0.1:7001</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:7001&gt; get name</span><br><span class=\"line\">&quot;alex&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"redis集群迁移\"><a class=\"markdownIt-Anchor\" href=\"#redis集群迁移\">#</a> Redis 集群迁移</h4>\n<p>Redis 集群迁移是指将现有的 Redis 集群中的数据移动到另一个集群或新的硬件环境中的过程。<br>\n这种迁移可能是因为需要扩大容量、更换硬件、迁移至新的数据中心或云平台等原因。迁移过程中需要考虑数据的一致性、服务的连续性以及最小化对现有业务的影响。<br>\n迁移方法</p>\n<ol>\n<li>\n<p>使用 RDB 或 AOF 文件进行离线迁移</p>\n<ul>\n<li>RDB 方式：停止集群服务，执行 bgsave 命令生成 RDB 快照文件，然后将 RDB 文件复制到新的集群中，并重启服务。</li>\n<li>AOF 方式：暂停写服务，将 AOF 文件导出到新的 Redis 集群中完成数据迁移。<br>\n这种方式简单直接，但会导致服务中断一段时间，并且适用于数据量不大或能接受短暂服务中断的情况。</li>\n</ul>\n</li>\n<li>\n<p>使用 Redis-Shake 进行在线迁移</p>\n<ul>\n<li>Redis-Shake：这是一个开源工具，专为在线迁移设计，可以在不停止服务的情况下迁移数据。<br>\nRedis-Shake 支持多种迁移场景，包括 Redis 集群之间的数据迁移。</li>\n<li>实时迁移：在迁移过程中，Redis-Shake 会持续同步源集群和目标集群之间的数据变化，以保证数据的一致性。</li>\n</ul>\n<p>这种方式可以减少服务中断的时间，适合于数据量大且要求服务连续性的场景。</p>\n</li>\n<li>\n<p>利用 Sentinel 或其他工具进行故障转移式迁移</p>\n<ul>\n<li>利用 Sentinel：如果当前集群启用了 Sentinel，可以先将数据复制到新集群中，然后通过 Sentinel 触发故障转移，将流量逐渐转移到新集群。</li>\n<li>逐步迁移：这种方式可以在不影响现有服务的情况下，逐步将数据和服务转移到新的集群中。</li>\n</ul>\n<p>这种方式适合于已经有 Sentinel 架构的场景，并且可以灵活控制迁移的节奏。</p>\n</li>\n</ol>\n<p>迁移步骤</p>\n<ol>\n<li>准备阶段\n<ol>\n<li>评估迁移需求：明确迁移的目的地、迁移的规模、时间窗口等。</li>\n<li>备份现有集群：在迁移前对现有集群进行全量备份，以防迁移失败需要回滚。</li>\n<li>准备新集群：搭建新集群环境，包括硬件准备、软件安装、网络配置等。</li>\n</ol>\n</li>\n<li>执行阶段\n<ol>\n<li>\n<p>数据同步：根据选择的方法，开始数据同步或迁移。</p>\n<ul>\n<li>如果使用 Redis-Shake，启动迁移工具并配置源集群和目标集群的信息。</li>\n<li>如果使用 RDB 或 AOF，执行必要的命令生成快照文件，并将其导入到新集群。</li>\n</ul>\n</li>\n<li>\n<p>验证数据一致性：在迁移完成后，检查新集群的数据完整性，确保没有数据丢失或损坏。</p>\n</li>\n<li>\n<p>切换流量：当数据迁移完成并且验证无误后，开始将客户端流量切换到新集群。</p>\n</li>\n</ol>\n</li>\n<li>后期阶段\n<ol>\n<li>监控与优化：迁移完成后，持续监控新集群的性能指标，确保一切正常。</li>\n<li>清理旧集群：如果不再需要旧集群，可以安全地卸载或关闭旧集群的相关资源。</li>\n</ol>\n</li>\n</ol>\n<p>注意事项</p>\n<ul>\n<li>迁移窗口：尽量选择业务低谷时段进行迁移，以减少对业务的影响。</li>\n<li>数据一致性：确保在整个迁移过程中数据的一致性，尤其是在实时迁移过程中。</li>\n<li>测试验证：在正式迁移之前，最好在一个测试环境中模拟迁移过程，确保迁移脚本和工具的正确性。</li>\n<li>回滚计划：准备好回滚计划，以便在迁移过程中出现问题时能够迅速恢复到迁移前的状态。</li>\n</ul>\n<h2 id=\"常见面试问题\"><a class=\"markdownIt-Anchor\" href=\"#常见面试问题\">#</a> 常见面试问题</h2>\n<h3 id=\"redis-为何这么快\"><a class=\"markdownIt-Anchor\" href=\"#redis-为何这么快\">#</a> Redis 为何这么快</h3>\n<ul>\n<li>内存存储：Redis 将所有数据存储在内存中，而不是磁盘上。内存的读写速度远超磁盘，这使得 Redis 能够实现极低的延迟和高吞吐量。内存中的数据访问速度几乎是瞬时的，而磁盘则需要等待机械臂移动到正确的位置才能开始读写，这大大降低了速度。</li>\n<li>高效的数据结构：Redis 提供了多种高效的数据结构，如跳跃表（skiplist）用于实现有序集合（Sorted<br>\nSet），压缩列表（ziplist）用于节省空间，哈希表（hashtable）用于实现散列（Hash）等。这些数据结构经过优化，能够在内存中高效地存储和检索数据。</li>\n<li>合理的数据编码：Redis 根据数据的不同类型和大小，使用不同的编码格式来存储数据。例如，短字符串可能会使用更为紧凑的编码方式，从而减少内存占用并加快处理速度。</li>\n<li>单线程模型：Redis 采用单线程模型来处理客户端的所有请求。这意味着在任何给定的时间内，只有一个客户端请求正在被执行。虽然这限制了并发处理能力，但也消除了多线程之间上下文切换和锁的竞争，从而减少了不必要的开销。</li>\n<li>非阻塞 I/O：Redis 使用事件驱动模型来处理客户端连接和请求。它使用了类似于 epoll 的 I/O 多路复用技术来监听多个客户端连接上的事件，<br>\n当有事件发生时（例如，客户端发送了一个命令），Redis 会立即处理这个事件。这种方式使得 Redis 可以同时处理大量的客户端连接，而不会因为一个客户端的阻塞而影响其他客户端的响应速度。</li>\n<li>异步持久化：为了防止持久化操作影响 Redis 的性能，Redis 提供了异步持久化选项。例如，RDB 快照和 AOF 日志都可以在后台进程执行，不会阻塞主线程处理客户端请求。</li>\n<li>线程分离：Redis 6.0 引入了多线程处理部分 I/O 密集型任务，如 AOF 重写和 RDB 持久化，这样可以进一步提高 Redis 的性能，因为这些任务不再完全阻塞单一线程。</li>\n</ul>\n<h3 id=\"redis为何使用单线程\"><a class=\"markdownIt-Anchor\" href=\"#redis为何使用单线程\">#</a> Redis 为何使用单线程</h3>\n<p>Redis 选择单线程模型的原因有以下几个方面：</p>\n<ul>\n<li>内存操作速度快：Redis 的所有数据都存储在内存中，内存的读写速度非常快。因此，对于基于内存的操作而言，CPU 并不是性能瓶颈。如果使用多线程，反而需要解决多线程同步的问题，这可能会增加额外的 CPU 负担。</li>\n<li>数据结构简单：Redis 中的数据结构相对简单，操作也较为迅速，这使得单线程就能够高效地处理大量的客户端请求。</li>\n<li>非阻塞 I/O 模型：Redis 使用了非阻塞的 I/O 模型，即多路复用 I/O 机制（如 epoll、select 等）。<br>\n这种机制使得单线程可以同时监听多个客户端连接的请求，并在有请求到达时异步地处理这些请求，从而有效地利用了单线程的能力来处理高并发连接。</li>\n<li>简化设计：单线程模型简化了 Redis 的设计和实现。由于不存在多线程间的竞争和同步问题，Redis 的代码更加简洁易懂，同时也减少了潜在的 bug。</li>\n<li>避免上下文切换开销：多线程模型会导致频繁的上下文切换，这会消耗大量的 CPU 资源。单线程模型避免了这种开销，使得 Redis 可以更加高效地使用 CPU 资源。</li>\n<li>易于实现高一致性：单线程模型下，数据的一致性更容易保证，因为不存在多线程并发修改同一份数据的问题。</li>\n<li>避免锁的竞争：在多线程环境下，为了避免数据冲突，通常需要使用锁机制。而锁的竞争会导致一部分线程处于等待状态，从而降低了系统的整体吞吐量。单线程模型避免了这种锁的竞争。</li>\n</ul>\n<p>然而，单线程模型也有其局限性。例如，对于 CPU 密集型的任务，单线程模型可能不是最佳选择，因为这样的任务会阻塞主线程，影响 Redis 处理其他请求的能力。为了解决这个问题，Redis 在后来的版本中引入了多线程来处理 I/O 密集型任务，如 AOF 重写和 RDB 持久化，以此来提升性能。</p>\n<h3 id=\"缓存三大问题以及解决方案\"><a class=\"markdownIt-Anchor\" href=\"#缓存三大问题以及解决方案\">#</a> 缓存三大问题以及解决方案？</h3>\n<ol>\n<li>\n<p>缓存击穿：指的是当某个 key 非常热点，在并发访问量大的情况下，如果这个 key 恰好在这个时刻失效了，那么所有请求都会落到数据库上，造成数据库瞬间压力过大。</p>\n<p>解决方案：</p>\n<ul>\n<li>设置热点数据永不过期：对于热点数据，可以将其设置为永不过期，或者设置一个较长的过期时间。\n<ul>\n<li>优点：\n<ol>\n<li>减少了因缓存失效导致的数据库压力。</li>\n<li>简单易实施。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>可能会导致缓存中的数据长时间不更新，影响数据的新鲜度。</li>\n<li>如果数据量很大，可能会占用较多的内存资源。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>数据更新频率较低，且数据新鲜度要求不高的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>互斥锁：使用互斥锁（Mutex）机制来控制缓存更新的过程。当缓存失效时，先获取锁，然后检查数据库中是否有数据，如果有则更新缓存，最后释放锁。\n<ul>\n<li>优点：\n<ol>\n<li>可以确保在缓存失效时，只有一部分请求会真正落到数据库上，减少了数据库的压力。</li>\n<li>数据更新及时。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>锁的使用会增加系统的复杂性。</li>\n<li>如果并发量极高，可能会出现锁竞争激烈的情况。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>数据更新频繁，且数据新鲜度要求较高的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>懒加载：当缓存失效后，可以先返回旧数据或占位符，然后异步加载最新数据并更新缓存。\n<ul>\n<li>优点：\n<ol>\n<li>用户体验较好，不会立即感知到数据陈旧。</li>\n<li>减少了数据库的瞬时压力。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>数据更新可能有延迟。</li>\n<li>实现复杂度较高。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>数据更新频率适中，对用户体验有一定要求的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>缓存穿透：是指查询一个一定不存在的数据，这个数据在缓存中不存在，同时在数据库中也不存在，每次请求都会直接穿透缓存去查询数据库，造成数据库压力巨大。</p>\n<p>解决方案：</p>\n<ul>\n<li>设置空值缓存：当查询到数据库中不存在的数据时，可以将这个查询结果（通常是 null 或特殊标识）缓存起来，设置一定的过期时间。\n<ul>\n<li>优点：\n<ol>\n<li>直接解决了缓存穿透问题，减少了对数据库的无效请求。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>如果恶意攻击者利用不存在的 key 频繁请求，可能会导致缓存中存储大量无效数据。</li>\n<li>需要合理设置过期时间，避免长期占用缓存空间。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于存在大量无效查询请求的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>布隆过滤器（Bloom Filter）：使用布隆过滤器来判断数据是否存在，可以有效地拦截那些一定不存在的数据查询。\n<ul>\n<li>优点：\n<ol>\n<li>有效拦截不存在的数据查询，减少无效请求。</li>\n<li>占用空间小，查询速度快。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>存在一定的误判率，即可能存在少量的假阳性（False Positive）。</li>\n<li>需要合理设计布隆过滤器的容量和哈希函数数量。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于数据量大且对数据精确性有一定容忍度的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>API 层面的验证：在业务逻辑层面增加对输入数据的校验，提前过滤掉非法或无效的查询请求。\n<ul>\n<li>优点：\n<ol>\n<li>从源头上过滤掉非法请求，减轻后续处理层的压力。</li>\n<li>提升系统的安全性。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>需要在业务逻辑中增加额外的验证步骤，增加了开发工作量。</li>\n<li>可能需要维护一份合法 key 的列表或规则。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于存在非法请求可能性的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>缓存雪崩：是指当缓存中的数据集中过期，导致大量请求同时穿透缓存去查询数据库，造成数据库压力剧增甚至崩溃。</p>\n<p>解决方案：</p>\n<ul>\n<li>分散缓存过期时间：避免大量数据同时过期，可以通过随机化设置过期时间来分散数据的过期时间。\n<ul>\n<li>优点：\n<ol>\n<li>有效避免了大量数据同时过期的情况，降低了数据库的压力。</li>\n<li>实现简单。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>需要合理设置随机过期时间，以确保数据分布均匀。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于数据量较大且有过期时间一致性的风险的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>限流降级：在缓存失效前，通过限流算法来控制请求的流量，一旦超过阈值则进行降级处理，返回默认值或缓存中的旧数据。\n<ul>\n<li>优点：\n<ol>\n<li>通过限流机制保护了后端系统，避免了突发流量的影响。</li>\n<li>可以根据实际情况调整限流策略。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>需要设计合理的降级策略，以确保用户体验不受太大影响。</li>\n<li>实现复杂度较高。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于流量波动较大的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>备用缓存：准备一个备用缓存系统，当主缓存系统出现故障或过载时，可以切换到备用缓存继续服务。\n<ul>\n<li>优点：\n<ol>\n<li>提供了冗余保障，增强了系统的可用性。</li>\n<li>可以平滑地切换到备用系统，减少服务中断时间。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>需要维护两套缓存系统，增加了运维成本。</li>\n<li>切换逻辑需要考虑数据同步问题。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于对系统可用性要求较高的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>异步更新：当缓存失效时，可以先返回旧数据或占位符，然后异步加载最新数据并更新缓存。\n<ul>\n<li>优点：\n<ol>\n<li>用户体验较好，不会立即感知到数据陈旧。</li>\n<li>减少了数据库的瞬时压力。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>数据更新可能有延迟。</li>\n<li>实现复杂度较高。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于数据更新频率适中，对用户体验有一定要求的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"如何保证数据库和redis缓存一致性\"><a class=\"markdownIt-Anchor\" href=\"#如何保证数据库和redis缓存一致性\">#</a> 如何保证数据库和 Redis 缓存一致性？</h3>\n<ol>\n<li>\n<p>最终一致性（Eventual Consistency）</p>\n<p>在分布式系统中，通常追求的是最终一致性而非强一致性。最终一致性意味着在一段时间后，所有数据副本将收敛到同一个状态。对于缓存和数据库来说，这意味着在数据更新后，缓存最终会反映数据库中的最新状态。</p>\n</li>\n<li>\n<p>双写策略</p>\n<ol>\n<li>\n<p>先更新数据库，再删除缓存（Update Database First, Invalidate Cache）</p>\n<p>原理：当数据发生变化时，首先更新数据库中的数据，然后再删除缓存中的对应条目。当下次请求该数据时，由于缓存中没有该数据，所以会重新从数据库中读取并更新缓存。</p>\n<ul>\n<li>优点：\n<ul>\n<li>简单易实现。</li>\n<li>可以避免数据不一致的问题。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>如果删除缓存失败，则可能导致缓存中的数据比数据库中的数据旧。</li>\n<li>删除缓存操作可能会失败，需要有重试机制。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>更新操作较少，且对数据一致性要求较高的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>先删除缓存，再更新数据库（Invalidate Cache First, Update Database）</p>\n<p>原理：当数据发生变化时，先删除缓存中的数据，然后再更新数据库中的数据。</p>\n<ul>\n<li>优点：\n<ul>\n<li>可以避免缓存击穿问题。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>如果更新数据库失败，而缓存已经被删除，那么这段时间内将无法从缓存中获取数据，导致请求直接访问数据库，增加数据库压力。</li>\n<li>如果删除缓存和更新数据库之间有延迟，可能会导致短暂的数据不一致。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>更新操作频繁，但对数据一致性要求稍低的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>延迟双删策略（Double Eviction with Delay）</p>\n<p>原理：当数据更新时，先删除缓存中的数据，然后立即设置一个临时缓存项（如使用 Redis 的 EXPIRE 命令设置一个很短的过期时间），再更新数据库。当临时缓存项过期后，真正的更新操作完成。</p>\n<ul>\n<li>优点：\n<ul>\n<li>减少了直接访问数据库的概率。</li>\n<li>通过设置临时缓存项，可以减少更新数据库失败导致的数据不一致问题。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>实现相对复杂。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>高并发场景下，对数据一致性要求较高的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>使用消息队列</p>\n<p>原理：当数据在数据库中更新后，发送一个消息到消息队列中，由另一个消费者监听消息队列并更新缓存。</p>\n<ul>\n<li>优点：\n<ul>\n<li>解耦数据库和缓存更新操作。</li>\n<li>可以异步处理缓存更新，减少数据库更新时的延迟。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>增加了系统的复杂性。</li>\n<li>需要处理消息队列的可靠性和消息重复消费问题。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>高并发、大数据量的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>缓存预热</p>\n<p>原理：在系统启动或数据更新后，主动将数据加载到缓存中。</p>\n<ul>\n<li>优点：\n<ul>\n<li>避免冷启动时大量请求直接访问数据库。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>需要额外的机制来触发预热操作。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>系统启动或数据更新后，希望尽快恢复服务的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>乐观锁或版本号</p>\n<p>原理：在数据库中为数据添加一个版本号字段，每次更新时都需要检查版本号是否匹配。如果不匹配，则说明数据已被其他操作更新，需要重新获取最新数据并再次尝试更新。</p>\n<ul>\n<li>优点：\n<ul>\n<li>保证了数据的一致性。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>可能会出现更新冲突，需要重试机制。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>对数据一致性要求极高的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"如何保证-redis-的高并发\"><a class=\"markdownIt-Anchor\" href=\"#如何保证-redis-的高并发\">#</a> 如何保证 Redis 的高并发？</h3>\n<ol>\n<li>单机优化\n<ul>\n<li>硬件优化：选择高性能的硬件设备，如 SSD 硬盘、高速网络接口卡以及足够的内存。</li>\n<li>内存管理：合理设置 Redis 的最大内存限制，避免内存溢出导致的服务不可用。</li>\n<li>持久化策略：选择合适的持久化方式（RDB 或 AOF），并调整相关的配置，以减少对性能的影响。</li>\n<li>数据结构选择：根据应用场景选择合适的数据结构，以减少内存使用并提高访问效率。</li>\n</ul>\n</li>\n<li>主从复制\n<ul>\n<li>读写分离：通过主从复制实现读写分离，主节点负责写操作，从节点负责读操作，可以显著提高并发处理能力。</li>\n<li>自动故障转移：使用 Redis Sentinel（哨兵）机制来监控主从节点的状态，并在主节点发生故障时自动进行故障转移，保证高可用性。</li>\n</ul>\n</li>\n<li>分布式集群\n<ul>\n<li>Redis Cluster：使用 Redis 集群来水平扩展 Redis，集群可以自动将数据分片存储在不同的节点上，并提供数据复制功能。这样可以支持更高的并发量和更大的数据集。</li>\n<li>数据分片：手动将数据分片存储在不同的 Redis 实例上，可以减轻单个节点的压力。</li>\n</ul>\n</li>\n<li>客户端优化\n<ul>\n<li>连接池：使用连接池来复用客户端连接，减少建立和销毁连接的开销。</li>\n<li>批处理：批量处理请求，例如使用 MGET、MSET 等命令来一次处理多个键值对，减少网络往返次数。</li>\n<li>命令管道：使用 Redis 的命令管道（pipelining）特性，将多个命令一次性发送给 Redis 服务器，减少网络延迟。</li>\n</ul>\n</li>\n<li>调整配置\n<ul>\n<li>网络配置：优化网络配置，例如调整 TCP 缓冲区大小、禁用 Nagle 算法等，以提高网络传输效率。</li>\n<li>I/O 多路复用：Redis 使用事件驱动模型来处理客户端请求，可以处理大量的并发连接。确保操作系统和 Redis 的事件处理机制配置得当。</li>\n</ul>\n</li>\n<li>监控与调优\n<ul>\n<li>性能监控：定期监控 Redis 的性能指标，如 CPU 使用率、内存使用情况、网络延迟等，以便及时发现性能瓶颈。</li>\n<li>负载均衡：使用负载均衡器来分配客户端请求，确保各个 Redis 节点的负载均衡。</li>\n</ul>\n</li>\n<li>避免热点 Key\n<ul>\n<li>Key 的设计：合理设计 Key，避免热点 Key 的产生，例如使用哈希分片（Hash Ring）来分散请求。</li>\n<li>过期时间：为热点 Key 设置合理的过期时间，并且可以使用随机化过期时间来避免雪崩效应。</li>\n</ul>\n</li>\n<li>异步处理\n<ul>\n<li>异步持久化：使用异步的方式进行持久化操作，避免阻塞主线程。</li>\n<li>多线程处理：Redis 6.0 引入了多线程模型来处理部分 I/O 密集型任务，如 AOF 重写和 RDB 持久化，可以进一步提升性能。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"redis-如何保证原子性\"><a class=\"markdownIt-Anchor\" href=\"#redis-如何保证原子性\">#</a> Redis 如何保证原子性？</h3>\n<ol>\n<li>单线程模型: Redis 采用单线程模型来处理所有的客户端请求。这意味着在同一时间内，只有一个客户端请求被处理，因此消除了并发竞争条件，保证了命令执行的顺序性和原子性。</li>\n<li>命令级别的原子性: Redis 中的大多数命令都是原子性的，这意味着它们在执行过程中不会被其他操作打断。例如，SET, GET, INCR,<br>\nDECR, HSET, HGET 等命令在执行时，整个操作过程不会被中断，从而保证了操作的完整性。</li>\n<li>事务机制: Redis 提供了事务机制，允许用户将多个命令打包成一个事务，通过 MULTI 命令开启事务，然后执行一系列命令，最后通过 EXEC 命令提交事务。<br>\n在事务中，Redis 会将这些命令放入队列中，等到事务提交时，这些命令会按照顺序依次执行，从而保证了事务内的操作的原子性。</li>\n<li>WATCH 命令: WATCH 命令可以监视一个或多个键，如果监视的键在执行 EXEC 之前被其他客户端修改了，那么事务会被取消。这实际上是一种乐观锁机制，用来保证在某些特定场景下的数据一致性。</li>\n<li>Lua 脚本: Redis 允许在服务器端执行 Lua 脚本来处理复杂的操作。Lua 脚本在执行时具有原子性，即整个脚本作为一个整体执行，期间不会被打断。<br>\n这意味着脚本中的多个 Redis 命令会被作为一个单独的操作来执行，从而保证了操作的原子性。</li>\n<li>数据结构的设计: Redis 内部的数据结构设计也是为了支持高效的原子操作。例如，对于有序集合（Sorted<br>\nSets），Redis 使用了跳跃表（Skiplist），这是一种支持快速插入、删除和查找操作的数据结构，可以高效地支持原子性操作。</li>\n</ol>\n<h2 id=\"常用命令\"><a class=\"markdownIt-Anchor\" href=\"#常用命令\">#</a> 常用命令</h2>\n<h3 id=\"cmd访问redis\"><a class=\"markdownIt-Anchor\" href=\"#cmd访问redis\">#</a> cmd 访问 redis</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli.exe -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串string相关命令\"><a class=\"markdownIt-Anchor\" href=\"#字符串string相关命令\">#</a> 字符串 (String) 相关命令</h3>\n<ul>\n<li>SET key value：设置键 key 的值为 value。</li>\n<li>GET key：获取键 key 的值。</li>\n<li>GETSET key value：设置键 key 的值为 value，并返回键 key 的旧值。</li>\n<li>INCR key：将键 key 的值加一，仅支持整数值。</li>\n<li>INCRBY key increment：将键 key 的值加上指定的增量 increment。</li>\n<li>DECR key：将键 key 的值减一。</li>\n<li>DECRBY key decrement：将键 key 的值减去指定的减量 decrement。</li>\n<li>APPEND key value：将 value 追加到键 key 的值后面。</li>\n<li>STRLEN key：返回键 key 的值的长度。</li>\n</ul>\n<h3 id=\"列表list相关命令\"><a class=\"markdownIt-Anchor\" href=\"#列表list相关命令\">#</a> 列表 (List) 相关命令</h3>\n<ul>\n<li>LPUSH key value [value …]：将一个或多个值 value 插入到键 key 的列表头部。</li>\n<li>RPUSH key value [value …]：将一个或多个值 value 插入到键 key 的列表尾部。</li>\n<li>LPOP key：移除并返回键 key 的列表的第一个元素。</li>\n<li>RPOP key：移除并返回键 key 的列表的最后一个元素。</li>\n<li>LRANGE key start stop：返回键 key 的列表中指定范围内的元素。</li>\n<li>LREM key count value：移除键 key 的列表中等于 value 的元素，count 参数决定了移除的数量。</li>\n<li>LSET key index value：将键 key 的列表中的指定位置 index 的值设为 value。</li>\n<li>LLEN key：返回键 key 的列表的长度。</li>\n</ul>\n<h3 id=\"哈希hash相关命令\"><a class=\"markdownIt-Anchor\" href=\"#哈希hash相关命令\">#</a> 哈希 (Hash) 相关命令</h3>\n<ul>\n<li>HSET key field value：将哈希表 key 中的域 field 的值设为 value。</li>\n<li>HGET key field：返回哈希表 key 中域 field 的值。</li>\n<li>HGETALL key：返回哈希表 key 中所有域的值。</li>\n<li>HDEL key field [field …]：删除一个或多个哈希表 key 中的域 field。</li>\n<li>HEXISTS key field：查看哈希表 key 中指定域 field 是否存在。</li>\n<li>HLEN key：返回哈希表 key 中域的数量。</li>\n<li>HKEYS key：返回哈希表 key 中所有域的列表。</li>\n<li>HVALS key：返回哈希表 key 中所有值的列表。</li>\n</ul>\n<h3 id=\"集合set相关命令\"><a class=\"markdownIt-Anchor\" href=\"#集合set相关命令\">#</a> 集合 (Set) 相关命令</h3>\n<ul>\n<li>SADD key member [member …]：将一个或多个成员 member 加入到集合 key 中。</li>\n<li>SMEMBERS key：返回集合 key 中的所有成员。</li>\n<li>SCARD key：返回集合 key 中的成员数。</li>\n<li>SREM key member [member …]：将一个或多个成员 member 从集合 key 中移除。</li>\n<li>SISMEMBER key member：判断成员 member 是否是集合 key 的成员。</li>\n<li>SINTER key [key …]：返回给定多个集合的交集成员。</li>\n<li>SUNION key [key …]：返回给定多个集合的并集成员。</li>\n<li>SDIFF key [key …]：返回给定多个集合的差集成员。</li>\n</ul>\n<h3 id=\"有序集合sorted-set相关命令\"><a class=\"markdownIt-Anchor\" href=\"#有序集合sorted-set相关命令\">#</a> 有序集合 (Sorted Set) 相关命令</h3>\n<ul>\n<li>ZADD key score member [score member …]：将一个或多个成员 member 及其分数 score 加入到有序集合 key 中。</li>\n<li>ZRANGE key start stop [WITHSCORES]：返回有序集合 key 中指定范围内的成员。</li>\n<li>ZREVRANGE key start stop [WITHSCORES]：返回有序集合 key 中指定范围内的成员，成员按分数值递减排列。</li>\n<li>ZREM key member [member …]：将一个或多个成员 member 从有序集合 key 中移除。</li>\n<li>ZCARD key：返回有序集合 key 中的成员数。</li>\n<li>ZSCORE key member：返回有序集合 key 中成员 member 的分数值。</li>\n<li>ZCOUNT key min max：计算在有序集合 key 中指定区间分数的成员数。</li>\n</ul>\n<h3 id=\"通用命令\"><a class=\"markdownIt-Anchor\" href=\"#通用命令\">#</a> 通用命令</h3>\n<ul>\n<li>EXPIRE key seconds：为键 key 设置生存时间。</li>\n<li>TTL key：返回键 key 剩余的生存时间。</li>\n<li>DEL key [key …]：删除一个或多个键 key。</li>\n<li>SELECT index：选择编号为 index 的数据库。</li>\n<li>FLUSHDB：清除当前数据库中的所有数据。</li>\n<li>FLUSHALL：清除所有数据库中的所有数据。</li>\n<li>KEYS pattern：返回匹配 pattern 的所有键。</li>\n<li>TYPE key：返回键 key 的类型。</li>\n</ul>\n",
            "tags": [
                "后端",
                "数据库",
                "NoSQL",
                "缓存",
                "Redis"
            ]
        },
        {
            "id": "https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Spring%E3%80%91Spring%E8%AF%A6%E8%A7%A3/",
            "url": "https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Spring%E3%80%91Spring%E8%AF%A6%E8%A7%A3/",
            "title": "【Spring】Spring详解",
            "date_published": "2024-09-13T03:24:41.000Z",
            "content_html": "<h2 id=\"spring的基本概念\"><a class=\"markdownIt-Anchor\" href=\"#spring的基本概念\">#</a> Spring 的基本概念</h2>\n<h3 id=\"1-spring-是什么\"><a class=\"markdownIt-Anchor\" href=\"#1-spring-是什么\">#</a> 1、Spring 是什么？</h3>\n<p>Spring 是一个轻量级 Java 开发框架，最早有 Rod Johnson 创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的<br>\n JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发 Java 应用程序提供全面的基础架构支持。Spring 负责基础架构，因此 Java<br>\n 开发者可以专注于应用程序的开发。Spring 最根本的使命是解决企业级应用开发的复杂性，即简化 Java 开发。</p>\n<h3 id=\"2-spring-带来哪些好处\"><a class=\"markdownIt-Anchor\" href=\"#2-spring-带来哪些好处\">#</a> 2、Spring 带来哪些好处？</h3>\n<ul>\n<li>\n<p>基于 POJO 的轻量级和最小侵入性编程。</p>\n</li>\n<li>\n<p>DI 机制将对象之间的依赖关系交由框架处理，减低组件间的耦合性。</p>\n</li>\n<li>\n<p>基于 AOP 技术支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。</p>\n</li>\n<li>\n<p>对于主流的应用框架提供了集成支持。</p>\n</li>\n</ul>\n<h3 id=\"3-说说-spring-有哪些模块\"><a class=\"markdownIt-Anchor\" href=\"#3-说说-spring-有哪些模块\">#</a> 3、说说 Spring 有哪些模块？</h3>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Spring%E3%80%91Spring%E8%AF%A6%E8%A7%A3/26e3bd5f237ab05ae63f5a697805b33b.png\" class=\"\" title=\"Spring模块\">\n<p>上图对应的是 Spring 4.x 版本的架构图，主要包括以下八个模块：</p>\n<ul>\n<li>\n<p><strong>Spring Core</strong>：基础，提供 IOC 和 DI 能力，可以说 Spring 其他所有的功能都依赖于该类库。</p>\n</li>\n<li>\n<p><strong>Spring Aspects</strong>：该模块为集成 AspectJ 提供支持。</p>\n</li>\n<li>\n<p><strong>Spring AOP</strong>：提供面向方面的编程实现。</p>\n</li>\n<li>\n<p><strong>Spring JDBC</strong>：Java 数据库连接。</p>\n</li>\n<li>\n<p><strong>Spring JMS</strong>：Java 消息服务。</p>\n</li>\n<li>\n<p><strong>Spring ORM</strong>：用于支持 Hibernate、Mybatis 等 ORM 工具。</p>\n</li>\n<li>\n<p><strong>Spring Web</strong>：为创建 Web 应用程序提供支持。</p>\n</li>\n<li>\n<p><strong>Spring Test</strong>：提供了对 JUnit 和 TestNG 测试框架的支持。</p>\n</li>\n</ul>\n<h3 id=\"4-spring-中使用了哪些设计模式\"><a class=\"markdownIt-Anchor\" href=\"#4-spring-中使用了哪些设计模式\">#</a> 4、Spring 中使用了哪些设计模式？</h3>\n<ul>\n<li>\n<p><strong>工厂模式</strong>：包括简单工厂和工厂方法，如通过 BeanFactory 或 ApplicationContext 创建 Bean 对象。</p>\n</li>\n<li>\n<p><strong>单例模式</strong>：Spring 中的 Bean 对象默认就是单例模式。</p>\n</li>\n<li>\n<p><strong>代理模式</strong>：Spring AOP 就是基于代理实现的，包括 JDK 动态代理和 CGlib 技术。</p>\n</li>\n<li>\n<p><strong>模板方法模式</strong>：Spring 中 jdbcTemplate 等以 Template 结尾对数据库操作的类就使用到模板模式。</p>\n</li>\n<li>\n<p><strong>观察者模式</strong>：Spring 事件驱动模型就是观察者模式很经典的应用。</p>\n</li>\n<li>\n<p><strong>适配器模式</strong>：Spring MVC 中，DispatcherServlet 根据请求解析到对应的 Handler（也就是我们常说的 Controller）后，开始由<br>\n HandlerAdapter 适配器处理。</p>\n</li>\n<li>\n<p><strong>装饰者模式</strong>：使用 DataSource 在不改动代码情况下切换数据源。</p>\n</li>\n<li>\n<p><strong>策略模式</strong>：Spring 对资源的访问，如 Resource 接口。</p>\n</li>\n</ul>\n<h3 id=\"5-spring-中有哪些不同类型事件\"><a class=\"markdownIt-Anchor\" href=\"#5-spring-中有哪些不同类型事件\">#</a> 5、Spring 中有哪些不同类型事件？</h3>\n<p>Spring 提供了以下 5 种标准的事件：</p>\n<ul>\n<li>\n<p><strong>上下文更新事件（ContextRefreshedEvent）</strong>：在调用 ConfigurableApplicationContext 接口中的 refresh () 方法时被触发。</p>\n</li>\n<li>\n<p><strong>上下文开始事件（ContextStartedEvent）</strong>：当容器调用 ConfigurableApplicationContext 的 Start () 方法开始 / 重新开始容器时触发该事件。</p>\n</li>\n<li>\n<p><strong>上下文停止事件（ContextStoppedEvent）</strong>：当容器调用 ConfigurableApplicationContext 的 Stop () 方法停止容器时触发该事件。</p>\n</li>\n<li>\n<p><strong>上下文关闭事件（ContextClosedEvent）</strong>：当 ApplicationContext 被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。</p>\n</li>\n<li>\n<p><strong>请求处理事件（RequestHandledEvent）</strong>：在 Web 应用中，当一个 http 请求（request）结束触发该事件。</p>\n</li>\n</ul>\n<p>至于如果监听这些事件：</p>\n<p>一个 Bean 实现了 ApplicationListener 接口，当一个 ApplicationEvent 被发布以后，Bean 会自动被通知。</p>\n<h2 id=\"spring-ioc\"><a class=\"markdownIt-Anchor\" href=\"#spring-ioc\">#</a> Spring IOC</h2>\n<h3 id=\"1-什么是-ioc\"><a class=\"markdownIt-Anchor\" href=\"#1-什么是-ioc\">#</a> 1、什么是 IOC？</h3>\n<p>IOC 是 Inversion of Control 的缩写，即控制反转。IOC 不是一项技术，而是一种设计思想。在 Java 开发中，Ioc 意味着你可以将设计好的对象交给<br>\n IOC 容器，完成初始化和管理，当你需要时由容器提供控制。</p>\n<p>Spring IOC 可谓是 Spring 的核心，对于 Spring 框架而言，所谓 IOC 就是由 Spring<br>\n 来负责控制对象的生命周期和对象间的关系。正这个控制过程中，需要动态的向某个对象提供它所需要的其他对象，这一点是通过<br>\n DI（Dependency Injection，依赖注入）来实现的。</p>\n<h3 id=\"2-ioc-的作用或好处\"><a class=\"markdownIt-Anchor\" href=\"#2-ioc-的作用或好处\">#</a> 2、IOC 的作用或好处？</h3>\n<p>实现对象间的解耦，同时降低应用开发的代码量和复杂度，使开发人员更专注业务。</p>\n<h3 id=\"3-ioc-的实现原理\"><a class=\"markdownIt-Anchor\" href=\"#3-ioc-的实现原理\">#</a> 3、IOC 的实现原理？</h3>\n<p>Spring 的 IOC 是基于工厂设计模式在加上反射实现。</p>\n<h3 id=\"4-spring-有哪些容器类\"><a class=\"markdownIt-Anchor\" href=\"#4-spring-有哪些容器类\">#</a> 4、Spring 有哪些容器类？</h3>\n<ul>\n<li><strong>BeanFactory</strong>：这是一个最简单的容器，它主要的功能是为依赖注入（DI）提供支持。</li>\n<li><strong>ApplicationContext</strong>：Application Context 是 Spring 中的高级容器。和 BeanFactory 类似，它可以加载和管理配置文件中定义的<br>\n Bean。 另外，它还增加了企业所需要的功能，比如，从属性文件中解析文本信息和将事件传递给所指定的监听器。</li>\n</ul>\n<p>一些常被使用的 ApplicationContext 实现类：</p>\n<ul>\n<li><strong>FileSystemXmlApplicationContext</strong>：该容器从 XML 文件中加载已被定义的 Bean， 需要提供 XML 文件的完整路径。</li>\n<li><strong>ClassPathXmlApplicationContext</strong>：同样从 XML 文件中加载已被定义的 Bean，但无需提供完整路径，因为它会从 CLASSPATH<br>\n 中搜索配置文件。</li>\n<li><strong>WebXmlApplicationContext</strong>：该容器会在一个 Web 应用程序的范围内加载在 XML 文件中已被定义的 Bean。</li>\n</ul>\n<h3 id=\"5-beanfactory-和-applicationcontext-的区别\"><a class=\"markdownIt-Anchor\" href=\"#5-beanfactory-和-applicationcontext-的区别\">#</a> 5、BeanFactory 和 ApplicationContext 的区别？</h3>\n<p>二者都是 Spring 框架的两大核心接口，都可以当做 Spring 的容器。其中 ApplicationContext 是 BeanFactory 的子接口。</p>\n<ul>\n<li>\n<p>BeanFactory 是 Spring 里面最底层的接口，包含了各种 Bean 的定义，读取配置文档，管理 Bean 的加载、实例化，控制 Bean<br>\n 的生命周期，维护对象之间的依赖关系等功能。</p>\n</li>\n<li>\n<p>ApplicationContext 接口作为 BeanFactory 的派生，除了提供 BeanFactory 所具有的功能外，还提供了更完整的框架功能：</p>\n<ul>\n<li>继承 MessageSource，支持国际化。</li>\n<li>统一的资源文件访问方式。</li>\n<li>提供在监听器中注册 Bean 的事件。</li>\n<li>支持同时加载多个配置文件。</li>\n<li>载入多个（有继承关系）上下文，使得每一个上下文都专注于一个特定的层次，如应用的 Web 层。</li>\n</ul>\n</li>\n</ul>\n<p><strong>具体区别体现在以下三个方面：</strong></p>\n<ol>\n<li>\n<p>加载方式不同</p>\n<ul>\n<li>\n<p>BeanFactroy 采用的懒加载方式注入 Bean，即只有在使用到某个 Bean 时才对该 Bean 实例化。这样，我们就不能在程序启动时发现一些存在的<br>\n Spring 的配置问题。</p>\n</li>\n<li>\n<p>ApplicationContext 是在启动时一次性创建了所有的 Bean。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>创建方式不同</p>\n<ul>\n<li>BeanFactory 通常以编程的方式被创建。</li>\n<li>ApplicationContext 还能以声明的方式创建，如使用 ContextLoader。</li>\n</ul>\n</li>\n<li>\n<p>注册方式不同</p>\n<ul>\n<li>二者都支持 BeanPostProcessor、BeanFactoryPostProcessor 的使用，但 BeanFactory 需要手动注册，而 ApplicationContext<br>\n 则是自动注册。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"6-有哪些注入方式以及区别\"><a class=\"markdownIt-Anchor\" href=\"#6-有哪些注入方式以及区别\">#</a> 6、有哪些注入方式以及区别？</h3>\n<p>Spring 支持多种依赖注入的方式，包括但不限于：</p>\n<ul>\n<li>构造器注入（Constructor Injection）</li>\n<li>属性注入（Property or Setter Injection）</li>\n<li>字段注入（Field Injection）</li>\n</ul>\n<h4 id=\"构造器注入\"><a class=\"markdownIt-Anchor\" href=\"#构造器注入\">#</a> 构造器注入</h4>\n<p>构造器注入是指通过构造器参数来传递依赖项。这种方式可以确保依赖项在对象创建时就已经存在，有助于提高对象的不可变性和稳定性。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SomeService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SomeDependency dependency;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">SomeService</span><span class=\"params\">(SomeDependency dependency)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dependency = Objects.requireNonNull(dependency, <span class=\"string\">&quot;dependency must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 Spring Boot 中，可以使用 @Autowired 注解来标记构造器，表明这是一个需要依赖注入的构造器。如果类中有多个构造器，那么需要显式地使用 @Autowired 注解来标注哪个构造器是注入构造器。</p>\n<h4 id=\"属性注入\"><a class=\"markdownIt-Anchor\" href=\"#属性注入\">#</a> 属性注入</h4>\n<p>属性注入是通过对象的 setter 方法来注入依赖项。这是最常用的一种方式，因为它允许在对象创建后注入依赖项，增加了灵活性。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SomeService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> SomeDependency dependency;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setDependency</span><span class=\"params\">(SomeDependency dependency)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dependency = Objects.requireNonNull(dependency, <span class=\"string\">&quot;dependency must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"字段注入\"><a class=\"markdownIt-Anchor\" href=\"#字段注入\">#</a> 字段注入</h4>\n<p>字段注入是通过直接在类成员变量上使用 @Autowired 注解来注入依赖项。这种方式简洁，但是不如构造器注入或属性注入那样清晰地表达依赖关系。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SomeService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SomeDependency dependency;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"一些使用上的规约\"><a class=\"markdownIt-Anchor\" href=\"#一些使用上的规约\">#</a> 一些使用上的规约</h4>\n<p>尽管 Spring 支持上述所有依赖注入方式，但 Spring 团队推荐使用构造器注入，特别是对于必填依赖项。构造器注入有助于确保依赖项在对象创建时已经就位，并且有助于提高对象的不可变性。此外，构造器注入使得依赖关系更加明确，便于阅读和理解代码。<br>\n对于可选依赖项，可以使用属性注入或字段注入。然而，无论选择哪种方式，都应该遵循一些最佳实践：</p>\n<ul>\n<li>避免使用字段注入：除非你有非常明确的理由使用字段注入，否则应尽量避免使用。字段注入可能会导致依赖关系不明确，难以维护。</li>\n<li>使用构造器注入：对于必填依赖项，应该优先使用构造器注入。</li>\n<li>使用断言确保依赖项不为空：在构造器或 setter 方法中使用 Objects.requireNonNull () 或类似方法来确保依赖项不是空的。</li>\n<li>考虑使用 @Required 注解：虽然 Spring 现在主要使用 @Autowired，但在某些情况下，@Required 注解仍然有用，它可以用来标记 setter 方法，表示该方法必须被 Spring 的自动装配机制调用。</li>\n</ul>\n<p>这些依赖注入方式的选择取决于具体的应用场景和个人偏好。构造器注入通常被认为是更安全、更清晰的选择，而字段注入虽然简单，但在某些情况下可能会导致代码难以理解和维护。</p>\n<h2 id=\"spring-bean\"><a class=\"markdownIt-Anchor\" href=\"#spring-bean\">#</a> Spring Bean</h2>\n<h3 id=\"1-spring-bean-有哪些作用域\"><a class=\"markdownIt-Anchor\" href=\"#1-spring-bean-有哪些作用域\">#</a> 1、Spring Bean 有哪些作用域？</h3>\n<p>Spring 提供以下五种 Bean 的作用域：</p>\n<ul>\n<li>Singleton：单例模式，默认的作用域。在整个 Spring IoC 容器中，一个 Bean 定义对应一个实例。</li>\n<li>Prototype：原型模式。每次从容器中请求该 Bean 时都会创建一个新的实例。</li>\n<li>Request：对于每一个 HTTP 请求，都会创建一个新的 Bean 实例。这个作用域仅在 Web 环境中可用。</li>\n<li>Session：在一个 HTTP Session 中，一个 Bean 定义对应一个实例。这个作用域同样仅在 Web 环境中可用。</li>\n<li>Global-session：在一个全局的 HTTP Session 中，一个 Bean 定义对应一个实例。这个作用域主要用于 Portlet 环境。</li>\n</ul>\n<p>值的注意的是：使用 Prototype 作用域时需要慎重的思考，因为频繁创建和销毁 Bean 会带来很大的性能开销。</p>\n<h4 id=\"spring-bean-作用域配置方式\"><a class=\"markdownIt-Anchor\" href=\"#spring-bean-作用域配置方式\">#</a> Spring Bean 作用域配置方式</h4>\n<p>Spring 提供了三种配置 Bean 作用域的方式：</p>\n<ul>\n<li>\n<p>XML 配置</p>\n<p>使用基于 XML 的配置文件时，可以通过<bean>标签的 scope 属性来指定 Bean 的作用域。</p>\n<p>例如，配置一个原型模式的 Bean：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;exampleBean&quot;</span>class=<span class=\"string\">&quot;com.example.ExampleBean&quot;</span>scope=<span class=\"string\">&quot;prototype&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>Java 配置类配置</p>\n<p>使用 Java 配置类（通过 @Configuration 和 @Bean 注解）时，可以在 Bean 定义的方法上使用 @Scope 注解来指定作用域。</p>\n<p>例如，定义一个原型模式的 Bean：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ExampleBean <span class=\"title function_\">exampleBean</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExampleBean</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ExampleSingletonBean <span class=\"title function_\">exampleSingletonBean</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExampleSingletonBean</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>Java 注解配置</p>\n<p>使用注解的方式配置 Bean 的作用域也很常见，特别是在组件扫描（Component Scanning）的情况下。可以直接在类或者方法级别使用 @Scope 注解。</p>\n<p>例如将一个 Service 组件设置为原型模式：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExampleBean</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"2-spring-的单例是否线程安全\"><a class=\"markdownIt-Anchor\" href=\"#2-spring-的单例是否线程安全\">#</a> 2、Spring 的单例是否线程安全？</h3>\n<p>Spring 框架中的 Bean 默认是单例模式（Singleton），这意味着在整个应用上下文中只会存在一个 Bean 实例。</p>\n<p>对于无状态的服务层 Bean 来说，Spring 的单例模式本身是线程安全的，因为它们不保存任何实例变量的状态，所有操作都是基于输入参数进行计算。</p>\n<p>但是，如果单例 Bean 有实例变量，并且这些变量在多个线程间共享并且被修改，则可能会出现线程安全问题。</p>\n<p>如何保证线程安全</p>\n<ul>\n<li>避免使用可变对象：尽量使用不可变对象或者确保对象在初始化之后不再改变其状态。</li>\n<li>同步访问：如果必须维护一些可变状态，可以通过同步方法或同步代码块来保证同一时间只有一个线程可以访问和修改这些状态。</li>\n<li>使用并发工具类：利用 Java 并发库中的工具类如 ConcurrentHashMap 等来管理共享资源。</li>\n<li>将 Bean 设计为原型模式：如果每个请求确实都需要独立的数据结构或状态，可以将 Bean 的作用域设置为<br>\n prototype，这样每次请求都会创建一个新的 Bean 实例，这样可能导致性能降低，但可以避免线程安全问题。</li>\n<li>使用 ThreadLocal：对于某些特定场景，可以使用 ThreadLocal 来实现线程之间的隔离，确保每个线程都有自己的独立副本。</li>\n</ul>\n<h3 id=\"3-spring-bean-的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#3-spring-bean-的生命周期\">#</a> 3、Spring Bean 的生命周期？</h3>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Spring%E3%80%91Spring%E8%AF%A6%E8%A7%A3/0cb7664ed7f4ec62270c528f298e03a3.png\" class=\"\" title=\"Spring Bean 生命周期\">\n<p>Bean 在 Spring 容器中从创建到销毁经历了若干阶段，每一阶段都可以进行个性化定制。</p>\n<ol>\n<li>\n<p>Spring 对 Bean 进行实例化；</p>\n</li>\n<li>\n<p>Spring 将配置和 Bean 的引用注入到对应的属性中；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 BeanNameAware 接口，Spring 将 Bean 的 ID 传递给 setBeanName () 方法；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 BeanFactoryAware 接口，Spring 将调用 setBeanFactory () 方法将 BeanFactory 容器实例传入；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 ApplicationContextAware 接口，Spring 将调用 setApplicationContext () 方法将 Bean 所在的应用上下文的引用传入进来；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 postProcessBeforeInitialization () 方法；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 InitializingBean 接口，Spring 将调用它们的 afterPropertiesSet () 方法。类似地，如果 Bean 使用 initmethod<br>\n 声明了初始化方法，该方法也会被调用；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 postProcessAfterInitialization () 方法；</p>\n</li>\n<li>\n<p>此时，Bean 已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 DisposableBean 接口，Spring 将调用它的 destroy () 接口方法。同样，如果使用 destroymethod<br>\n 声明了销毁方法，该方法也会被调用。</p>\n</li>\n</ol>\n<h2 id=\"spring-aop\"><a class=\"markdownIt-Anchor\" href=\"#spring-aop\">#</a> Spring AOP</h2>\n<h3 id=\"1-什么是-aop-以及作用\"><a class=\"markdownIt-Anchor\" href=\"#1-什么是-aop-以及作用\">#</a> 1、什么是 AOP 以及作用？</h3>\n<p>AOP（Aspect Oriented Programming）是面向切面编程，是 OOP 的一个补充，它允许我们通过引入新的模块，来分离业务逻辑与非业务逻辑，从而实现代码复用。</p>\n<p>传统的 OOP 开发中代码逻辑是至上而下的过程中会长生一些横切性问题（大量与业务无关的重复代码），这些横切问题会散落在代码的各个地方且难以维护。AOP<br>\n 的编程思想就是把业务逻辑和横切的问题进行分离，从而达到解耦的目的，使代码的重用性和开发效率高（目的是重用代码，把公共的代码抽取出来）。</p>\n<p>即 AOP 的作用是对业务逻辑的各个部分进行隔离，降低业务逻辑的耦合性，提高程序的可重用型和开发效率。</p>\n<h3 id=\"2-有哪些应用场景\"><a class=\"markdownIt-Anchor\" href=\"#2-有哪些应用场景\">#</a> 2、有哪些应用场景？</h3>\n<ul>\n<li>事务管理：在多个服务或方法调用中需要统一管理事务的开始、提交或回滚。Spring AOP 可以通过声明式事务管理（例如使用<br>\n @Transactional 注解）来简化事务的控制逻辑。</li>\n<li>日志记录：对系统中的关键方法或接口的日志记录，包括方法调用前后的日志打印，以及异常捕获时的日志记录。这可以通过定义一个切面，在方法执行前后插入日志记录的逻辑来实现。</li>\n<li>权限验证：在调用某些敏感操作之前，需要进行权限验证。通过 AOP 可以在方法调用前进行权限检查，从而确保只有授权用户才能访问特定功能。</li>\n<li>性能监控：监控应用程序中方法的执行时间和资源消耗情况，这对于性能瓶颈分析非常有用。可以定义一个切面来记录方法执行的开始时间和结束时间，并计算执行时间。</li>\n<li>缓存操作：对数据访问操作的结果进行缓存，以减少数据库访问次数，提高响应速度。使用 AOP<br>\n 可以在方法执行前检查缓存，如果缓存中有数据则直接返回，否则执行方法并将结果存入缓存。</li>\n<li>输入输出参数校验：在方法执行前对传入的参数进行校验，确保参数的有效性；在方法执行后对返回值进行校验，确保返回值的正确性。</li>\n<li>资源锁定：在多线程环境中，为了防止资源竞争，可以使用 AOP 来添加锁定逻辑，确保资源的一致性和完整性。</li>\n<li>自定义注解：定义自定义注解，并通过 AOP 处理这些注解，实现特定的行为，如日志记录、性能统计等。</li>\n</ul>\n<h3 id=\"3-切面-切点-连接点-通知以及四者的关系\"><a class=\"markdownIt-Anchor\" href=\"#3-切面-切点-连接点-通知以及四者的关系\">#</a> 3、切面、切点、连接点、通知以及四者的关系？</h3>\n<p>在 Spring AOP 中，切面（Aspect）、切点（Pointcut）、连接点（Joinpoint）和通知（Advice）是核心概念，它们共同协作来实现面向切面编程的功能。下面是这些概念之间的关系：</p>\n<h4 id=\"1连接点-joinpoint\"><a class=\"markdownIt-Anchor\" href=\"#1连接点-joinpoint\">#</a> 1）连接点 (Joinpoint)</h4>\n<h5 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h5>\n<p>连接点是指程序执行过程中的某个特定点，比如方法执行、字段访问等。</p>\n<h5 id=\"示例\"><a class=\"markdownIt-Anchor\" href=\"#示例\">#</a> 示例</h5>\n<p>在代码中，连接点的具体表现形式通常是方法的调用。当你定义了一个方法，并且这个方法被 Spring AOP 所管理，那么这个方法的执行就是一个连接点。例如：</p>\n<pre><code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SomeService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 业务逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>在这个例子中，doSomething () 方法的执行就是一个连接点。</p>\n<p>不是所有的连接点都可以被切面所使用，只有那些被切点表达式匹配上的连接点才是 AOP 能够织入的连接点。</p>\n<h4 id=\"2切点-pointcut\"><a class=\"markdownIt-Anchor\" href=\"#2切点-pointcut\">#</a> 2）切点 (Pointcut)</h4>\n<h5 id=\"概念-2\"><a class=\"markdownIt-Anchor\" href=\"#概念-2\">#</a> 概念</h5>\n<p>切点（Pointcut）是 AOP 中的一个重要概念，它定义了哪些连接点（Joinpoint）会被切面（Aspect）所关注，确定哪些方法或类应该被切面所拦截。<br>\n一个切点可以匹配多个连接点，而一个连接点也可以被多个切点所匹配。</p>\n<p>在 Spring AOP 中，切点的表现形式通常包括以下几个方面：</p>\n<ul>\n<li>方法执行切点：最常用的形式，用于指定特定的方法执行。</li>\n<li>类执行切点：用于指定特定类的所有方法执行。</li>\n<li>异常切点：用于指定方法抛出特定异常时的切点。</li>\n<li>构造函数切点：用于指定构造函数的执行。</li>\n<li>字段访问切点：用于指定字段的访问或修改。</li>\n</ul>\n<p>Spring AOP 支持使用 AspectJ 的切点表达式语法来定义切点。基本语法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execution(modifier-pattern?ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)<span class=\"keyword\">throws</span>-pattern?)</span><br></pre></td></tr></table></figure>\n<p>其中：</p>\n<ul>\n<li>modifiers-pattern：修饰符模式（可选）。</li>\n<li>ret-type-pattern：返回类型模式。</li>\n<li>declaring-type-pattern：声明类型模式（可选）。</li>\n<li>name-pattern：方法名称模式。</li>\n<li>param-pattern：参数模式。</li>\n<li>throws-pattern：抛出异常模式（可选）。</li>\n</ul>\n<h5 id=\"示例-2\"><a class=\"markdownIt-Anchor\" href=\"#示例-2\">#</a> 示例</h5>\n<p>假设我们有一个 UserService 类，包含一个 login 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">login</span><span class=\"params\">(String username, String password)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 登录逻辑</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以通过注解表达式来定义切点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;execution(* com.example.service.UserService.login(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logBefore</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Logging before login&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">userServiceMethods</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;userServiceMethods()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logBeforeAllUserServiceMethods</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Logging before all UserService methods&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中：</p>\n<ul>\n<li><code>execution(* com.example.service.UserService.login(..))</code> ：表示拦截 UserService 类中的 login 方法。</li>\n<li><code>execution(* com.example.service.UserService.*(..))</code> ：表示拦截 UserService 类中的所有方法。</li>\n</ul>\n<h4 id=\"通知-advice\"><a class=\"markdownIt-Anchor\" href=\"#通知-advice\">#</a> 通知 (Advice)</h4>\n<h5 id=\"概念-3\"><a class=\"markdownIt-Anchor\" href=\"#概念-3\">#</a> 概念</h5>\n<p>通知（Advice）是 Spring AOP<br>\n 中的一个核心概念，它定义了在切点（Pointcut）匹配的连接点（Joinpoint）上执行的动作。通知可以分为多种类型，每种类型在不同的时机执行不同的逻辑。下面详细介绍通知的类型及其具体表现形式。</p>\n<p>Spring AOP 支持以下几种主要的通知类型：</p>\n<ol>\n<li>前置通知（Before Advice）：在方法执行前执行（关键字: Before）。</li>\n<li>后置通知（After Returning Advice）：仅当方法正常返回时执行（关键字: AfterReturning）。</li>\n<li>最终通知（After Advice）：无论方法是否抛出异常，都会在方法执行后执行（关键字: After）。</li>\n<li>异常通知（After Throwing Advice）：仅当方法抛出异常时执行（关键字: AfterThrowing）。</li>\n<li>环绕通知（Around Advice）：环绕通知，在方法执行前后都可执行，并且可以决定是否继续执行方法（关键字: Around）。</li>\n</ol>\n<p>不同类型的 AOP 通知适用于不同的场景：</p>\n<ol>\n<li>前置通知：适用于日志记录、权限验证、资源准备等。</li>\n<li>后置通知：适用于日志记录、资源释放、结果处理等。</li>\n<li>最终通知：适用于资源释放、日志记录等。</li>\n<li>异常通知：适用于异常记录、错误处理、资源释放等。</li>\n<li>环绕通知：适用于性能监控、事务管理、权限验证、资源控制等。</li>\n</ol>\n<h5 id=\"示例-3\"><a class=\"markdownIt-Anchor\" href=\"#示例-3\">#</a> 示例</h5>\n<ol>\n<li>\n<p>前置通知（Before Advice）</p>\n<p>前置通知是在方法执行前执行的通知。它可以用来进行一些准备工作，如日志记录、权限验证等。<br>\n示例代码：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logBefore</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Executing: &quot;</span> + method.getName());</span><br><span class=\"line\">        Object[] args = joinPoint.getArgs();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object arg : args) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Argument: &quot;</span> + arg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，logBefore 方法是一个前置通知，它会在 UserService 类中的所有方法执行前被调用。</p>\n</li>\n<li>\n<p>后置通知（After Returning Advice）</p>\n<p>后置通知是在方法正常返回后执行的通知。它可以用来进行一些清理工作，如关闭资源、记录日志等。<br>\n示例代码：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning(pointcut = &quot;execution(* com.example.service.UserService.*(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logAfterReturning</span><span class=\"params\">(JoinPoint joinPoint, Object result)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; returned: &quot;</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，logAfterReturning 方法是一个后置通知，它会在 UserService 类中的所有方法正常返回后被调用，并接收方法的返回值。</p>\n</li>\n<li>\n<p>最终通知（After Advice）</p>\n<p>最终通知是在方法执行后（无论方法是否正常返回或抛出异常）都会执行的通知。它可以用来进行一些必要的清理工作，如关闭资源等。<br>\n示例代码：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@After(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logFinally</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; has been executed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，logFinally 方法是一个最终通知，它会在 UserService 类中的所有方法执行后被调用。</p>\n</li>\n<li>\n<p>异常通知（After Throwing Advice）</p>\n<p>异常通知是在方法抛出异常后执行的通知。它可以用来记录异常信息、发送报警等。<br>\n示例代码：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterThrowing(pointcut = &quot;execution(* com.example.service.UserService.*(..))&quot;, throwing = &quot;ex&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logAfterThrowing</span><span class=\"params\">(JoinPoint joinPoint, Exception ex)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; threw exception: &quot;</span> + ex.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，logAfterThrowing 方法是一个异常通知，它会在 UserService 类中的所有方法抛出异常后被调用，并接收异常对象。</p>\n</li>\n<li>\n<p>环绕通知（Around Advice）</p>\n<p>环绕通知是在方法执行前后都可执行的通知。它可以完全控制方法的执行流程，包括是否继续执行方法、如何执行等。<br>\n示例代码：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">logAround</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before executing: &quot;</span> + method.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> joinPoint.proceed(); <span class=\"comment\">// 继续执行方法</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;After executing: &quot;</span> + method.getName());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; threw exception: &quot;</span> + e.getMessage());</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，logAround 方法是一个环绕通知，它会在 UserService 类中的所有方法执行前后都被调用，并且可以控制方法的执行流程。</p>\n</li>\n</ol>\n<h4 id=\"切面-aspect\"><a class=\"markdownIt-Anchor\" href=\"#切面-aspect\">#</a> 切面 (Aspect)</h4>\n<h5 id=\"概念-4\"><a class=\"markdownIt-Anchor\" href=\"#概念-4\">#</a> 概念</h5>\n<p>切面（Aspect）是 Spring AOP 中的核心概念之一，它将横切关注点（Cross-cutting<br>\nConcern）模块化为独立的组件。切面包含了多个通知（Advice）和切点（Pointcut），并通过这些通知和切点来实现特定的功能。下面详细介绍切面的概念、组成以及具体的应用场景。</p>\n<p>切面通常由以下几个部分组成：</p>\n<ul>\n<li>切点（Pointcut）：定义了哪些连接点（Joinpoint）会被切面所关注。</li>\n<li>通知（Advice）：定义了在切点匹配的连接点上执行的动作。</li>\n<li>引入（Introduction）：允许向现有类添加新的方法或属性。</li>\n<li>织入（Weaving）：将切面与应用程序的其他部分结合起来的过程。</li>\n</ul>\n<h5 id=\"示例-4\"><a class=\"markdownIt-Anchor\" href=\"#示例-4\">#</a> 示例</h5>\n<p>在 Spring AOP 中，切面通常通过 @Aspect 注解来定义，并且可以包含多个切点和通知。<br>\n示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 前置通知</span></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logBefore</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Executing: &quot;</span> + method.getName());</span><br><span class=\"line\">        Object[] args = joinPoint.getArgs();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object arg : args) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Argument: &quot;</span> + arg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 后置通知</span></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning(pointcut = &quot;execution(* com.example.service.UserService.*(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logAfterReturning</span><span class=\"params\">(JoinPoint joinPoint, Object result)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; returned: &quot;</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 最终通知</span></span><br><span class=\"line\">    <span class=\"meta\">@After(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logFinally</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; has been executed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 异常通知</span></span><br><span class=\"line\">    <span class=\"meta\">@AfterThrowing(pointcut = &quot;execution(* com.example.service.UserService.*(..))&quot;, throwing = &quot;ex&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logAfterThrowing</span><span class=\"params\">(JoinPoint joinPoint, Exception ex)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; threw exception: &quot;</span> + ex.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 环绕通知</span></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">logAround</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before executing: &quot;</span> + method.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> joinPoint.proceed(); <span class=\"comment\">// 继续执行方法</span></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">endTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;After executing: &quot;</span> + method.getName() + <span class=\"string\">&quot; (Time: &quot;</span> + (endTime - startTime) + <span class=\"string\">&quot;ms)&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; threw exception: &quot;</span> + e.getMessage());</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-aop-的实现原理\"><a class=\"markdownIt-Anchor\" href=\"#4-aop-的实现原理\">#</a> 4、AOP 的实现原理？</h3>\n<p>AOP 是基于代理实现的，Spring 提供了 JDK 动态代理和 CGlib 两种方式来生成代理对象。</p>\n<p>Spring AOP 会根据目标对象是否实现了接口来决定使用哪种代理策略：<br>\n如果目标对象实现了接口，则使用 JDK 动态代理。<br>\n如果目标对象没有实现任何接口，则使用 CGLIB 代理。<br>\n这种策略使得 Spring AOP 能够灵活地适应不同的情况，并且保证了代理对象能够正确地执行增强逻辑。</p>\n<p>以下介绍两种不同的代理策略原理。</p>\n<h4 id=\"jdk-动态代理\"><a class=\"markdownIt-Anchor\" href=\"#jdk-动态代理\">#</a> JDK 动态代理</h4>\n<p>JDK 动态代理是基于 Java 语言反射机制实现的。它要求被代理的对象必须实现一个或多个接口。Spring AOP 会利用这个特性，当目标对象实现了接口时，就会使用<br>\n JDK 动态代理来创建代理对象。</p>\n<p>工作原理：</p>\n<ul>\n<li>当一个对象实现了某个接口时，Spring 会通过 java.lang.reflect.Proxy 类来创建一个代理对象。</li>\n<li>这个代理对象实现了相同的接口，并且其内部持有对原始对象的引用。</li>\n<li>代理对象通过 InvocationHandler 接口来处理方法调用，这样可以在方法调用前后添加额外的行为。</li>\n</ul>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设有一个接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Doing something...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建代理对象</span></span><br><span class=\"line\">    <span class=\"type\">Service</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceImpl</span>();</span><br><span class=\"line\">    <span class=\"type\">Service</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (Service) Proxy.newProxyInstance(</span><br><span class=\"line\">            Service.class.getClassLoader(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[]&#123;Service.class&#125;,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;Before method call&quot;</span>);</span><br><span class=\"line\">                    <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(service, args);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;After method call&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">proxy.doSomething();</span><br></pre></td></tr></table></figure>\n<h4 id=\"cglib\"><a class=\"markdownIt-Anchor\" href=\"#cglib\">#</a> CGlib</h4>\n<p>CGLIB（Code Generation Library）是一个高性能的字节码生成库，它可以在运行时动态生成一个目标类的子类。这意味着即使目标对象没有实现任何接口，也可以通过<br>\n CGLIB 来创建代理对象。<br>\n工作原理：</p>\n<ul>\n<li>CGLIB 通过继承目标类来创建一个新的子类对象。</li>\n<li>在这个子类中，对父类的方法进行增强，也就是在方法调用前后添加额外的行为。</li>\n<li>这种方式不需要目标类实现任何接口，因此更加灵活。</li>\n</ul>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设有一个未实现接口的类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Doing something...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建代理对象</span></span><br><span class=\"line\">    <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\">enhancer.setSuperclass(Service.class);</span><br><span class=\"line\">        enhancer.setCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">MethodInterceptor</span>()&#123;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object obj,Method method,Object[]args,MethodProxy proxy)</span><span class=\"keyword\">throws</span> Throwable&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before method call&quot;</span>);</span><br><span class=\"line\">        Object result=proxy.invokeSuper(obj,args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After method call&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Service service=(Service)enhancer.create();</span><br><span class=\"line\">        service.doSomething();</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "后端",
                "java",
                "spring"
            ]
        },
        {
            "id": "https://silvercrow42.github.io/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/",
            "url": "https://silvercrow42.github.io/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/",
            "title": "【分布式】通过Zookeeper与Redisson实现Spring注解式分布式锁",
            "date_published": "2024-09-10T02:00:01.000Z",
            "content_html": "<p>在分布式系统中，由于服务部署在多个节点中，在运行时数据层面上天生无法互通，因此在处理多线程敏感的数据时，无法像单机应用开发一样通过 java 内部实现的多线程方案来解决。此时我们就需要通过分布式锁的方式来处理数据。</p>\n<p>本文将提供一个在 spring-cloud 基础上通过 ZooKeeper 或者 Redisson 实现的注解式的加锁方案。需要使用到 Spring<br>\nAOP，通过 ZooKeeper 加锁时需要 ZooKeeper 服务，使用 Redisson 加锁时需要使用 Redis 数据库。</p>\n<h2 id=\"依赖\"><a class=\"markdownIt-Anchor\" href=\"#依赖\">#</a> 依赖</h2>\n<p>当使用 Redisson 方式时需要引入 Redisson 依赖，版本号自行匹配替换。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/org.redisson/redisson --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.redisson<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>redisson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;redisson.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当使用 ZooKeeper 方式时需要引入连接 ZooKeeper 的依赖，版本号自行匹配替换。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-recipes --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;curator-recipes.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"配置访问锁服务的组件\"><a class=\"markdownIt-Anchor\" href=\"#配置访问锁服务的组件\">#</a> 配置访问锁服务的组件</h2>\n<h3 id=\"redisson\"><a class=\"markdownIt-Anchor\" href=\"#redisson\">#</a> Redisson</h3>\n<p>使用 redisson 作为锁服务的实现时，需要如下配置类配置 RedissonClient 组件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedissonLockConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.redis.url:redis://localhost:6379&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String redisUrl;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.redis.password:&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String redisPassword;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RedissonClient <span class=\"title function_\">redissonClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Config</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Config</span>();</span><br><span class=\"line\">        <span class=\"type\">SingleServerConfig</span> <span class=\"variable\">singleServerConfig</span> <span class=\"operator\">=</span> config.useSingleServer();</span><br><span class=\"line\">        singleServerConfig.setAddress(redisUrl);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isNotEmpty(redisPassword)) &#123;</span><br><span class=\"line\">            singleServerConfig.setPassword(redisPassword);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Redisson.create(config);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 redisUrl 为 Redis 服务的地址，redisPassword 为 Redis 服务的密码。</p>\n<p>RedissonClient 连接配置可以按需进行调整。</p>\n<h3 id=\"zookeeper\"><a class=\"markdownIt-Anchor\" href=\"#zookeeper\">#</a> ZooKeeper</h3>\n<p>使用 ZooKeeper 作为锁服务的实现时，需要如下配置类配置 CuratorFramework 组件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZooKeeperLockConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.url:localhost:2181&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.timeout:1000&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> timeout;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.retry:3&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> retry;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CuratorFramework <span class=\"title function_\">zkClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ExponentialBackoffRetry</span> <span class=\"variable\">exponentialBackoffRetry</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExponentialBackoffRetry</span>(timeout, retry);</span><br><span class=\"line\">        <span class=\"type\">CuratorFramework</span> <span class=\"variable\">curatorFramework</span> <span class=\"operator\">=</span> CuratorFrameworkFactory.newClient(url, exponentialBackoffRetry);</span><br><span class=\"line\">        curatorFramework.start();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> curatorFramework;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 url 是 ZooKeeper 服务地址，timeout 是连接超时时间，retry 是连接失败重试次数。</p>\n<p>CuratorFramework 连接配置可以按需进行调整。</p>\n<h2 id=\"加锁逻辑\"><a class=\"markdownIt-Anchor\" href=\"#加锁逻辑\">#</a> 加锁逻辑</h2>\n<p>在分布式系统中，多系统之间的数据很可能不互通，因此加锁肯定不是通过原始数据进行加锁。</p>\n<p>在加锁时，我们应该对应原始数据，生成唯一的对应该数据的 token 作为加锁依据的 key，同时该 key 在无论何时对于该原始数据而言生成的都是这个 key。这样一来，通过该 key 明确地指向原始数据进行加锁与解锁。</p>\n<p>例如在系统中，存在张 User 表，该表中 id 列为其主键。那么在进行数据加锁时，则可以考虑以如下格式：“User-[id 数据]” 来进行加锁解锁操作。</p>\n<h3 id=\"redisson-2\"><a class=\"markdownIt-Anchor\" href=\"#redisson-2\">#</a> Redisson</h3>\n<p>Redisson 的 “红锁”（Red Lock）是一种基于 Redis 的分布式锁实现，它提供了高可用性和一致性保证。红锁的设计目的是为了克服单点故障问题，通过在多个<br>\n Redis 实例上实现分布式锁来提高系统的可靠性和可用性。</p>\n<p>红锁的基本原理<br>\n红锁的核心思想是在多个 Redis 实例上分别尝试获取锁，只有当大多数实例成功获取锁时，才认为整个分布式锁成功获取。具体步骤如下：</p>\n<ol>\n<li>尝试获取锁：在多个 Redis 实例上尝试获取锁。</li>\n<li>判断是否成功：只有当大多数 Redis 实例成功获取锁时，才认为整个分布式锁成功获取。</li>\n<li>释放锁：在所有成功获取锁的 Redis 实例上释放锁。</li>\n</ol>\n<p>实现步骤</p>\n<ol>\n<li>首先需要创建一个或多个 Redis 客户端，并初始化 Redisson 框架。</li>\n<li>使用 Redisson 框架创建红锁。</li>\n<li>尝试在多个 Redis 实例上获取锁。</li>\n<li>在所有成功获取锁的 Redis 实例上释放锁。</li>\n</ol>\n<h3 id=\"zookeeper-2\"><a class=\"markdownIt-Anchor\" href=\"#zookeeper-2\">#</a> ZooKeeper</h3>\n<p>ZooKeeper 分布式锁是一种常用的分布式协调机制，用于解决多个进程或服务之间的互斥访问问题。<br>\n在分布式系统中，多个节点可能需要同时访问共享资源，而分布式锁可以确保这些访问是互斥的，从而避免数据不一致的问题。<br>\n同时 ZooKeeper 集群化部署的高可用性和一致性使得它可以可靠地处理高并发加锁场景。</p>\n<p>分布式锁的基本原理<br>\n分布式锁的基本原理是在 ZooKeeper 中创建一个临时有序节点（ephemeral sequential node），每个客户端通过创建这样的节点来表示自己持有锁的状态。具体步骤如下：</p>\n<ol>\n<li>创建临时有序节点：客户端在 ZooKeeper 中创建一个临时有序节点。</li>\n<li>判断是否是最小节点：客户端检查自己创建的节点是否是最小的节点。</li>\n<li>加锁与释放锁：如果是最小节点，则客户端获得锁；否则，客户端等待前一个节点释放锁。</li>\n</ol>\n<p>实现步骤</p>\n<ol>\n<li>创建锁节点\n<ol>\n<li>定义锁路径：\n<ol>\n<li>选择一个固定的路径作为锁的根节点，例如 /distributed-lock。</li>\n<li>客户端在该路径下创建一个临时有序节点。</li>\n</ol>\n</li>\n<li>创建临时有序节点：\n<ol>\n<li>使用 create API 创建临时有序节点，例如 /distributed-lock/lock-0000000001。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>判断是否是最小节点\n<ol>\n<li>获取所有子节点：\n<ol>\n<li>客户端获取锁路径下的所有子节点，例如 /distributed-lock 下的所有子节点。</li>\n</ol>\n</li>\n<li>比较节点序号：\n<ol>\n<li>客户端将自己的节点序号与其他节点的序号进行比较。</li>\n<li>如果当前节点序号是最小的，则获得锁；否则，等待前一个节点释放锁。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>加锁与释放锁\n<ol>\n<li>加锁：\n<ol>\n<li>如果当前节点序号是最小的，则获得锁。</li>\n<li>否则，等待前一个节点释放锁。</li>\n</ol>\n</li>\n<li>释放锁：\n<ol>\n<li>当客户端不再需要锁时，删除自己创建的临时有序节点。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"加锁实现\"><a class=\"markdownIt-Anchor\" href=\"#加锁实现\">#</a> 加锁实现</h2>\n<p>在进行实现时，首先考虑到一次加锁时可能涉及到多个数据，因此使用 key 集合来进行加锁，timeout 与 timeunit 用于指代锁的超时时长。</p>\n<p>抽象出如下方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(List&lt;String&gt; keys,Long timeout,TimeUnit unit)</span><span class=\"keyword\">throws</span> Exception;</span><br></pre></td></tr></table></figure>\n<p>LockEntity 为锁实例，用于进行解锁操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockEntity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object lock;</span><br><span class=\"line\"></span><br><span class=\"line\">    LockEntity(Object lock) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.lock = lock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lock <span class=\"keyword\">instanceof</span> RLock rLock) &#123;</span><br><span class=\"line\">            rLock.unlock();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lock <span class=\"keyword\">instanceof</span> InterProcessLock interProcessLock) &#123;</span><br><span class=\"line\">            interProcessLock.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>针对不同的锁类型，采取不同的解锁方法</p>\n<h3 id=\"redisson-3\"><a class=\"markdownIt-Anchor\" href=\"#redisson-3\">#</a> Redisson</h3>\n<p>逻辑：先通过 RedissonClient 组件遍历 keys 集合获取所有锁实例，再将以这些锁实例来获取一个 MultiLock 实例，来进行多锁的统一加锁解锁，再根据提供的 timeout 和 unit 加锁并返回 LockEntity 对象用来操作解锁。</p>\n<p>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys,Long timeout,TimeUnit unit)</span>&#123;</span><br><span class=\"line\">        ArrayList&lt;RLock&gt; rLocks=<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(keys.size());</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String key:keys)&#123;</span><br><span class=\"line\">        rLocks.add(redissonClient.getLock(key));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        RLock multiLock=redissonClient.getMultiLock(rLocks.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">RLock</span>[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(timeout!=<span class=\"literal\">null</span>&amp;&amp;timeout&gt;<span class=\"number\">0</span>&amp;&amp;unit!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">        multiLock.lock(timeout,unit);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        multiLock.lock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"zookeeper-3\"><a class=\"markdownIt-Anchor\" href=\"#zookeeper-3\">#</a> ZooKeeper</h3>\n<p>逻辑：同 Redisson 类似，先构造多锁对象，然后使用该对象进行加锁并返回</p>\n<p>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; lockKeys,Long timeout,TimeUnit unit)</span><span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">        InterProcessMultiLock multiLock=<span class=\"keyword\">new</span> <span class=\"title class_\">InterProcessMultiLock</span>(zkClient,lockKeys.stream().toList());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(timeout!=<span class=\"literal\">null</span>&amp;&amp;timeout&gt;<span class=\"number\">0</span>&amp;&amp;unit!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">        multiLock.acquire(timeout,unit);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        multiLock.acquire();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现通过注解加锁\"><a class=\"markdownIt-Anchor\" href=\"#实现通过注解加锁\">#</a> 实现通过注解加锁</h2>\n<h3 id=\"定义注解\"><a class=\"markdownIt-Anchor\" href=\"#定义注解\">#</a> 定义注解</h3>\n<ol>\n<li>\n<p>首先针对锁的实现方式，定义区分注解：</p>\n<ul>\n<li>\n<p>@RedisLock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RedisLock &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">timeout</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimeUnit <span class=\"title function_\">unit</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> TimeUnit.SECONDS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>@ZkLock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ZkLock &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">timeout</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimeUnit <span class=\"title function_\">unit</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> TimeUnit.SECONDS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这两个注解作用于方法上，用于表明当前方法需要使用到分布式锁，以及需要使用到哪种分布式锁，并提供锁的超时时间。</p>\n</li>\n<li>\n<p>其次针对方法参数中的的同步参数，提供一个注解 @SyncArg。</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.PARAMETER&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SyncArg &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 加锁依据，填入Spel表达式，用于生成锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * 应该确保每一个加锁对象能够生成一个固定的且独立的key</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用时可用上下文包括 arg：当前参数，method：当前运行的方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    String <span class=\"title function_\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"string\">&quot;#arg.hashCode()&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 是否采用多对象解析方式，多对象时将产生多个锁并同步加锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 当传入对象实现了 Iterable时，将遍历每一个子项，并且生成key时arg为当前遍历到的对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 当传入对象实现了Map时，将遍历每个Entry，生成key时arg为当前Entry</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">isMulti</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该注解作用于方法参数，表明该参数需要参照 value 值生成 key 来加锁，isMulti 用于标识当前参数是否是多对象参数。</p>\n</li>\n</ol>\n<h3 id=\"处理注解\"><a class=\"markdownIt-Anchor\" href=\"#处理注解\">#</a> 处理注解</h3>\n<p>首先，通过一个上下文对象用来自动生成加锁的 key。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockContext</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 被加锁的参数对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object arg;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成key的Spel表达式</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String keyExpression;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 是否为多对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> multi;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Getter(AccessLevel.PACKAGE)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; params;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(SyncArg syncArg, Object arg)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(arg, syncArg.value(), syncArg.isMulti());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(Object arg, String keyExpression, <span class=\"type\">boolean</span> multi)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(arg, keyExpression, multi, <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(Object arg, String keyExpression, <span class=\"type\">boolean</span> multi, Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.arg = arg;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.keyExpression = keyExpression;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.multi = multi;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.params = params;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key   key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 用于链式调用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockContext <span class=\"title function_\">addParam</span><span class=\"params\">(String key, Object value)</span> &#123;</span><br><span class=\"line\">        params.put(key, value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 用于链式调用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockContext <span class=\"title function_\">removeParam</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        params.remove(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getKey(<span class=\"keyword\">new</span> <span class=\"title class_\">SpelExpressionParser</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成key</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> parser Spel表达式解析器</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getKey</span><span class=\"params\">(SpelExpressionParser parser)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StandardEvaluationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StandardEvaluationContext</span>();</span><br><span class=\"line\">        HashMap&lt;String, Object&gt; contextMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(params);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!contextMap.containsKey(<span class=\"string\">&quot;arg&quot;</span>)) &#123;</span><br><span class=\"line\">            contextMap.put(<span class=\"string\">&quot;arg&quot;</span>, arg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        context.setVariables(contextMap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parser.parseExpression(keyExpression).getValue(context, String.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里通过继承抽象类的方式在抽象类中提供一些公共方法，由子类进行加锁的实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 格式化生成的key，在生成加锁key时会经过该方法，并以返回的key作为最终加锁时的key</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> generatedKey 通过上下文对象自动生成的key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 格式化后的key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过LockContext的形式生成锁key再加锁</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockContexts 用于生成锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeout      锁超时时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit         时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 锁对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> LockEntity <span class=\"title function_\">doLockByContext</span><span class=\"params\">(List&lt;LockContext&gt; lockContexts, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> doLock(getLockKeys(lockContexts), timeout, unit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> doLock(keys, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过锁keys进行加锁，由子类实现</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> keys    锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeout 超时时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit    时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 锁对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据方法及入参解析出LockContext列表</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method 加锁的方法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args   入参</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> LockContext列表</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> List&lt;LockContext&gt; <span class=\"title function_\">getLockContexts</span><span class=\"params\">(Method method, Object[] args)</span> &#123;</span><br><span class=\"line\">        Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class=\"line\">        ArrayList&lt;LockContext&gt; lockContexts = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; parameterAnnotations.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取参数注解，与参数一一对应</span></span><br><span class=\"line\">            Annotation[] annotations = parameterAnnotations[i];</span><br><span class=\"line\">            <span class=\"comment\">//找到@SyncArg注解</span></span><br><span class=\"line\">            <span class=\"type\">SyncArg</span> <span class=\"variable\">syncArg</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Annotation annotation : annotations) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (annotation <span class=\"keyword\">instanceof</span> SyncArg syncArgA) &#123;</span><br><span class=\"line\">                    syncArg = syncArgA;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (syncArg != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//注解存在则通过注解构造上下文对象</span></span><br><span class=\"line\">                <span class=\"type\">LockContext</span> <span class=\"variable\">lockContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(syncArg, args[i]);</span><br><span class=\"line\">                lockContext.addParam(<span class=\"string\">&quot;method&quot;</span>, method);</span><br><span class=\"line\">                lockContexts.add(lockContext);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lockContexts;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过上下文对象列表生成key集合</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockContexts 上下文对象列表</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> key集合</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> HashSet&lt;String&gt; <span class=\"title function_\">getLockKeys</span><span class=\"params\">(List&lt;LockContext&gt; lockContexts)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//解析上下文列表，生成key</span></span><br><span class=\"line\">        HashSet&lt;String&gt; keys = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">SpelExpressionParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SpelExpressionParser</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (LockContext lockContext : lockContexts) &#123;</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">multi</span> <span class=\"operator\">=</span> lockContext.isMulti();</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">arg</span> <span class=\"operator\">=</span> lockContext.getArg();</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">keyExpression</span> <span class=\"operator\">=</span> lockContext.getKeyExpression();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (multi &amp;&amp; arg <span class=\"keyword\">instanceof</span> Iterable&lt;?&gt; iterable) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//多对象模式且参数对象为Iterable时</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Object o : iterable) &#123;</span><br><span class=\"line\">                    <span class=\"type\">LockContext</span> <span class=\"variable\">singleContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(o, keyExpression, <span class=\"literal\">false</span>, lockContext.getParams());</span><br><span class=\"line\">                    keys.add(formatKey(singleContext.getKey(parser)));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (multi &amp;&amp; arg <span class=\"keyword\">instanceof</span> Map&lt;?, ?&gt; map) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//多对象模式且参数对象为map时</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Map.Entry&lt;?, ?&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">LockContext</span> <span class=\"variable\">singleContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(entry, keyExpression, <span class=\"literal\">false</span>, lockContext.getParams());</span><br><span class=\"line\">                    keys.add(formatKey(singleContext.getKey(parser)));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                keys.add(formatKey(lockContext.getKey(parser)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> keys;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"redisson实现\"><a class=\"markdownIt-Anchor\" href=\"#redisson实现\">#</a> Redisson 实现</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedissonLockService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RedissonClient redissonClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedissonLockService</span><span class=\"params\">(RedissonClient redissonClient)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redissonClient = redissonClient;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;@annotation(org.joker.commons.cloud.lock.annotation.RedisLock)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doLockByContext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;doLockByContext()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint point)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取方法对象</span></span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) point.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        <span class=\"comment\">//解析用于生成锁的上下文</span></span><br><span class=\"line\">        List&lt;LockContext&gt; lockContexts = getLockContexts(method, point.getArgs());</span><br><span class=\"line\">        <span class=\"comment\">//加锁并执行</span></span><br><span class=\"line\">        <span class=\"type\">RedisLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> method.getAnnotation(RedisLock.class);</span><br><span class=\"line\">        <span class=\"type\">LockEntity</span> <span class=\"variable\">lockEntity</span> <span class=\"operator\">=</span> doLockByContext(lockContexts, lock.timeout(), lock.unit());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> point.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lockEntity.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;cloud:lock:&quot;</span> + generatedKey;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys, Long timeout, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;RLock&gt; rLocks = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(keys.size());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">            rLocks.add(redissonClient.getLock(key));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">RLock</span> <span class=\"variable\">multiLock</span> <span class=\"operator\">=</span> redissonClient.getMultiLock(rLocks.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">RLock</span>[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timeout != <span class=\"literal\">null</span> &amp;&amp; timeout &gt; <span class=\"number\">0</span> &amp;&amp; unit != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            multiLock.lock(timeout, unit);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            multiLock.lock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 AOP 的方法，在 @RedisLock 注解处创建切面，在执行该方法之前先对该方法的参数进行处理，产生上下文列表，并依据该列表生成对应的 key 集合，再通过该 key 集合尝试获取锁。在获取锁成功后再执行对应的方法，在 finally 代码块中释放锁。</p>\n<h5 id=\"zookeeper实现\"><a class=\"markdownIt-Anchor\" href=\"#zookeeper实现\">#</a> ZooKeeper 实现</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZooKeeperLockService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CuratorFramework zkClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ZooKeeperLockService</span><span class=\"params\">(CuratorFramework zkClient)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.zkClient = zkClient;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;@annotation(org.joker.commons.cloud.lock.annotation.ZkLock)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doLockByContext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;doLockByContext()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint point)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取方法对象</span></span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) point.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        <span class=\"comment\">//解析用于生成锁的上下文</span></span><br><span class=\"line\">        List&lt;LockContext&gt; lockContexts = getLockContexts(method, point.getArgs());</span><br><span class=\"line\">        <span class=\"comment\">//加锁并执行</span></span><br><span class=\"line\">        <span class=\"type\">ZkLock</span> <span class=\"variable\">zkLock</span> <span class=\"operator\">=</span> method.getAnnotation(ZkLock.class);</span><br><span class=\"line\">        <span class=\"type\">LockEntity</span> <span class=\"variable\">lockEntity</span> <span class=\"operator\">=</span> doLockByContext(lockContexts, zkLock.timeout(), zkLock.unit());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> point.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lockEntity.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;/cloud/lock/&quot;</span> + generatedKey;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; lockKeys, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">InterProcessMultiLock</span> <span class=\"variable\">multiLock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InterProcessMultiLock</span>(zkClient, lockKeys.stream().toList());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timeout != <span class=\"literal\">null</span> &amp;&amp; timeout &gt; <span class=\"number\">0</span> &amp;&amp; unit != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            multiLock.acquire(timeout, unit);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            multiLock.acquire();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同 Redisson 类似，在 ZkLock 处创建切面，先根据注解解析对应参数的锁 key 后，再获取锁，然后执行方法并释放锁。</p>\n<h2 id=\"完整代码\"><a class=\"markdownIt-Anchor\" href=\"#完整代码\">#</a> 完整代码</h2>\n<p>以下按照包结构排列</p>\n<ul>\n<li>\n<p>…</p>\n<ul>\n<li>\n<p>lock</p>\n<ul>\n<li>\n<p>annotation</p>\n<ul>\n<li>\n<p>RedisLock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RedisLock &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">timeout</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimeUnit <span class=\"title function_\">unit</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> TimeUnit.SECONDS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>SyncArg</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.PARAMETER&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SyncArg &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 加锁依据，填入Spel表达式，用于生成锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * 应该确保每一个加锁对象能够生成一个固定的且独立的key</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用时可用上下文包括 arg：当前参数，method：当前运行的方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    String <span class=\"title function_\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"string\">&quot;#arg.hashCode()&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 是否采用多对象解析方式，多对象时将产生多个锁并同步加锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 当传入对象实现了 Iterable时，将遍历每一个子项，并且生成key时arg为当前遍历到的对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 当传入对象实现了Map时，将遍历每个Entry，生成key时arg为当前Entry</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">isMulti</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>ZkLock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ZkLock &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">timeout</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimeUnit <span class=\"title function_\">unit</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> TimeUnit.SECONDS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>config</p>\n<ul>\n<li>\n<p>RedissonLockConfig</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedissonLockConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.redis.url:redis://localhost:6379&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String redisUrl;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.redis.password:&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String redisPassword;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RedissonClient <span class=\"title function_\">redissonClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Config</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Config</span>();</span><br><span class=\"line\">        <span class=\"type\">SingleServerConfig</span> <span class=\"variable\">singleServerConfig</span> <span class=\"operator\">=</span> config.useSingleServer();</span><br><span class=\"line\">        singleServerConfig.setAddress(redisUrl);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isNotEmpty(redisPassword)) &#123;</span><br><span class=\"line\">            singleServerConfig.setPassword(redisPassword);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Redisson.create(config);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>ZooKeeperLockConfig</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZooKeeperLockConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.url:localhost:2181&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.timeout:1000&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> timeout;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.retry:3&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> retry;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CuratorFramework <span class=\"title function_\">zkClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ExponentialBackoffRetry</span> <span class=\"variable\">exponentialBackoffRetry</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExponentialBackoffRetry</span>(timeout, retry);</span><br><span class=\"line\">        <span class=\"type\">CuratorFramework</span> <span class=\"variable\">curatorFramework</span> <span class=\"operator\">=</span> CuratorFrameworkFactory.newClient(url, exponentialBackoffRetry);</span><br><span class=\"line\">        curatorFramework.start();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> curatorFramework;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>AbstractLockService</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 格式化生成的key，在生成加锁key时会经过该方法，并以返回的key作为最终加锁时的key</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> generatedKey 通过上下文对象自动生成的key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 格式化后的key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过LockContext的形式生成锁key再加锁</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockContexts 用于生成锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeout      锁超时时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit         时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 锁对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> LockEntity <span class=\"title function_\">doLockByContext</span><span class=\"params\">(List&lt;LockContext&gt; lockContexts, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> doLock(getLockKeys(lockContexts), timeout, unit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> doLock(keys, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过锁keys进行加锁，由子类实现</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> keys    锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeout 超时时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit    时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 锁对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据方法及入参解析出LockContext列表</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method 加锁的方法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args   入参</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> LockContext列表</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> List&lt;LockContext&gt; <span class=\"title function_\">getLockContexts</span><span class=\"params\">(Method method, Object[] args)</span> &#123;</span><br><span class=\"line\">        Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class=\"line\">        ArrayList&lt;LockContext&gt; lockContexts = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; parameterAnnotations.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取参数注解，与参数一一对应</span></span><br><span class=\"line\">            Annotation[] annotations = parameterAnnotations[i];</span><br><span class=\"line\">            <span class=\"comment\">//找到@SyncArg注解</span></span><br><span class=\"line\">            <span class=\"type\">SyncArg</span> <span class=\"variable\">syncArg</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Annotation annotation : annotations) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (annotation <span class=\"keyword\">instanceof</span> SyncArg syncArgA) &#123;</span><br><span class=\"line\">                    syncArg = syncArgA;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (syncArg != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//注解存在则通过注解构造上下文对象</span></span><br><span class=\"line\">                <span class=\"type\">LockContext</span> <span class=\"variable\">lockContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(syncArg, args[i]);</span><br><span class=\"line\">                lockContext.addParam(<span class=\"string\">&quot;method&quot;</span>, method);</span><br><span class=\"line\">                lockContexts.add(lockContext);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lockContexts;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过上下文对象列表生成key集合</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockContexts 上下文对象列表</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> key集合</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> HashSet&lt;String&gt; <span class=\"title function_\">getLockKeys</span><span class=\"params\">(List&lt;LockContext&gt; lockContexts)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//解析上下文列表，生成key</span></span><br><span class=\"line\">        HashSet&lt;String&gt; keys = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">SpelExpressionParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SpelExpressionParser</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (LockContext lockContext : lockContexts) &#123;</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">multi</span> <span class=\"operator\">=</span> lockContext.isMulti();</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">arg</span> <span class=\"operator\">=</span> lockContext.getArg();</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">keyExpression</span> <span class=\"operator\">=</span> lockContext.getKeyExpression();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (multi &amp;&amp; arg <span class=\"keyword\">instanceof</span> Iterable&lt;?&gt; iterable) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//多对象模式且参数对象为Iterable时</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Object o : iterable) &#123;</span><br><span class=\"line\">                    <span class=\"type\">LockContext</span> <span class=\"variable\">singleContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(o, keyExpression, <span class=\"literal\">false</span>, lockContext.getParams());</span><br><span class=\"line\">                    keys.add(formatKey(singleContext.getKey(parser)));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (multi &amp;&amp; arg <span class=\"keyword\">instanceof</span> Map&lt;?, ?&gt; map) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//多对象模式且参数对象为map时</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Map.Entry&lt;?, ?&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">LockContext</span> <span class=\"variable\">singleContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(entry, keyExpression, <span class=\"literal\">false</span>, lockContext.getParams());</span><br><span class=\"line\">                    keys.add(formatKey(singleContext.getKey(parser)));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                keys.add(formatKey(lockContext.getKey(parser)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> keys;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>LockContext</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockContext</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 被加锁的参数对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object arg;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成key的Spel表达式</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String keyExpression;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 是否为多对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> multi;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Getter(AccessLevel.PACKAGE)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; params;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(SyncArg syncArg, Object arg)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(arg, syncArg.value(), syncArg.isMulti());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(Object arg, String keyExpression, <span class=\"type\">boolean</span> multi)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(arg, keyExpression, multi, <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(Object arg, String keyExpression, <span class=\"type\">boolean</span> multi, Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.arg = arg;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.keyExpression = keyExpression;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.multi = multi;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.params = params;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key   key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 用于链式调用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockContext <span class=\"title function_\">addParam</span><span class=\"params\">(String key, Object value)</span> &#123;</span><br><span class=\"line\">        params.put(key, value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 用于链式调用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockContext <span class=\"title function_\">removeParam</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        params.remove(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getKey(<span class=\"keyword\">new</span> <span class=\"title class_\">SpelExpressionParser</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成key</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> parser Spel表达式解析器</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getKey</span><span class=\"params\">(SpelExpressionParser parser)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StandardEvaluationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StandardEvaluationContext</span>();</span><br><span class=\"line\">        HashMap&lt;String, Object&gt; contextMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(params);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!contextMap.containsKey(<span class=\"string\">&quot;arg&quot;</span>)) &#123;</span><br><span class=\"line\">            contextMap.put(<span class=\"string\">&quot;arg&quot;</span>, arg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        context.setVariables(contextMap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parser.parseExpression(keyExpression).getValue(String.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>LockEntity</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockEntity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object lock;</span><br><span class=\"line\"></span><br><span class=\"line\">    LockEntity(Object lock) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.lock = lock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lock <span class=\"keyword\">instanceof</span> RLock rLock) &#123;</span><br><span class=\"line\">            rLock.unlock();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lock <span class=\"keyword\">instanceof</span> InterProcessLock interProcessLock) &#123;</span><br><span class=\"line\">            interProcessLock.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>RedissonLockService</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedissonLockService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RedissonClient redissonClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedissonLockService</span><span class=\"params\">(RedissonClient redissonClient)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redissonClient = redissonClient;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;@annotation(org.joker.commons.cloud.lock.annotation.RedisLock)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doLockByContext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;doLockByContext()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint point)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取方法对象</span></span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) point.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        <span class=\"comment\">//解析用于生成锁的上下文</span></span><br><span class=\"line\">        List&lt;LockContext&gt; lockContexts = getLockContexts(method, point.getArgs());</span><br><span class=\"line\">        <span class=\"comment\">//加锁并执行</span></span><br><span class=\"line\">        <span class=\"type\">RedisLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> method.getAnnotation(RedisLock.class);</span><br><span class=\"line\">        <span class=\"type\">LockEntity</span> <span class=\"variable\">lockEntity</span> <span class=\"operator\">=</span> doLockByContext(lockContexts, lock.timeout(), lock.unit());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> point.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lockEntity.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;cloud:lock:&quot;</span> + generatedKey;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys, Long timeout, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;RLock&gt; rLocks = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(keys.size());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">            rLocks.add(redissonClient.getLock(key));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">RLock</span> <span class=\"variable\">multiLock</span> <span class=\"operator\">=</span> redissonClient.getMultiLock(rLocks.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">RLock</span>[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timeout != <span class=\"literal\">null</span> &amp;&amp; timeout &gt; <span class=\"number\">0</span> &amp;&amp; unit != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            multiLock.lock(timeout, unit);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            multiLock.lock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>ZooKeeper</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZooKeeperLockService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CuratorFramework zkClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ZooKeeperLockService</span><span class=\"params\">(CuratorFramework zkClient)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.zkClient = zkClient;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;@annotation(org.joker.commons.cloud.lock.annotation.ZkLock)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doLockByContext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;doLockByContext()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint point)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取方法对象</span></span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) point.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        <span class=\"comment\">//解析用于生成锁的上下文</span></span><br><span class=\"line\">        List&lt;LockContext&gt; lockContexts = getLockContexts(method, point.getArgs());</span><br><span class=\"line\">        <span class=\"comment\">//加锁并执行</span></span><br><span class=\"line\">        <span class=\"type\">ZkLock</span> <span class=\"variable\">zkLock</span> <span class=\"operator\">=</span> method.getAnnotation(ZkLock.class);</span><br><span class=\"line\">        <span class=\"type\">LockEntity</span> <span class=\"variable\">lockEntity</span> <span class=\"operator\">=</span> doLockByContext(lockContexts, zkLock.timeout(), zkLock.unit());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> point.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lockEntity.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;/cloud/lock/&quot;</span> + generatedKey;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; lockKeys, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">InterProcessMultiLock</span> <span class=\"variable\">multiLock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InterProcessMultiLock</span>(zkClient, lockKeys.stream().toList());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timeout != <span class=\"literal\">null</span> &amp;&amp; timeout &gt; <span class=\"number\">0</span> &amp;&amp; unit != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            multiLock.acquire(timeout, unit);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            multiLock.acquire();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"测试效果\"><a class=\"markdownIt-Anchor\" href=\"#测试效果\">#</a> 测试效果</h2>\n<p>采用如下 Spring 服务类进行效果测试，其中 run 中为测试代码，表达式 “#arg.getClass ().getSimpleName ()+#arg.getId ()<br>\n” 以 id 作为唯一主键生成 key，当前示例下生成的 key 为 Usertest01。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Getter</span></span><br><span class=\"line\">    <span class=\"meta\">@Setter</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;test01&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;测试用户&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">(User user)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        log.info(user.getName());</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">//模拟业务过程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RedisLock</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testRedisSync</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">            <span class=\"meta\">@SyncArg(&quot;#arg.getClass().getSimpleName()+#arg.getId()&quot;)</span> User user</span></span><br><span class=\"line\"><span class=\"params\">    )</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        test(user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ZkLock</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testZooKeeperSync</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">            <span class=\"meta\">@SyncArg(&quot;#arg.getClass().getSimpleName()+#arg.getId()&quot;)</span> User user</span></span><br><span class=\"line\"><span class=\"params\">    )</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        test(user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"不加锁\"><a class=\"markdownIt-Anchor\" href=\"#不加锁\">#</a> 不加锁</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestRunner</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestService testService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        TestService.<span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TestService</span>.User();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            testService.test(user);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>服务一：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/378a9d360acf6a6c560d3c2e9f68be60.png\" class=\"\" title=\"不加锁服务1log\">\n<p>服务二：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/248294a19780cc9e924184e26670a0c3.png\" class=\"\" title=\"不加锁服务2log\">\n<p>根据时间可以看到两个服务几乎同时在进行，如果存在变更数据的情况则可能存在出现数据不一致情况的风险。</p>\n<h3 id=\"使用redis锁\"><a class=\"markdownIt-Anchor\" href=\"#使用redis锁\">#</a> 使用 Redis 锁</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestRunner</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestService testService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        TestService.<span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TestService</span>.User();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            testService.testRedisSync(user);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>服务一：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/4507c4421a934baec554f92cea7b0038.png\" class=\"\" title=\"Redis锁服务1log\">\n<p>服务二：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/9158b26eab49184d53d500eb7c0e07b6.png\" class=\"\" title=\"Redis锁服务2log\">\n<p>根据时间可以看到两个服务在逐一有序地进行，能够实现锁的效果。</p>\n<h3 id=\"使用zookeeper锁\"><a class=\"markdownIt-Anchor\" href=\"#使用zookeeper锁\">#</a> 使用 ZooKeeper 锁</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestRunner</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestService testService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        TestService.<span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TestService</span>.User();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            testService.testZooKeeperSync(user);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>服务一：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/7ed3a36d886af2366487ddf9e679c224.png\" class=\"\" title=\"ZooKeeper服务1log\">\n<p>服务二：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/b00b26556a04f89fc3e1224726755a96.png\" class=\"\" title=\"ZooKeeper服务2log\">\n<p>同样能够实现锁的效果。</p>\n",
            "tags": [
                "后端",
                "Zookeeper",
                "Redis",
                "Redisson",
                "分布式锁"
            ]
        },
        {
            "id": "https://silvercrow42.github.io/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/",
            "url": "https://silvercrow42.github.io/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/",
            "title": "【RocketMQ】SpringBoot整合与使用RocketMQ（Windows）",
            "date_published": "2024-09-09T05:06:48.000Z",
            "content_html": "<p>由于是开发相关的文档，因此默认读者已经具备有 IDE，编者使用的是 IDEA 2022.1.3 以该版本作为演示基础。</p>\n<h1 id=\"spring引入rocketmq\"><a class=\"markdownIt-Anchor\" href=\"#spring引入rocketmq\">#</a> Spring 引入 RocketMQ</h1>\n<p>在适配 Spring 生态方面，RocketMQ 由于本身就是 Java 语言开发并且开源，拥有 Spring 开发基础就能够参照源码进行调试，并且其本身也提供了可直接用于 SpringBoot 整合的父项目，pom.xml 中通过如下配置即可引入该父项目。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.rocketmq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"学习springrocketmq范例\"><a class=\"markdownIt-Anchor\" href=\"#学习springrocketmq范例\">#</a> 学习 SpringRocketMQ 范例</h1>\n<p>RocketMQ 对于 Spring 拥有良好的适配，并且拥有对应的参考项目，接下来我们借助该项目了解一下 RocketMQ 的架构及用法。</p>\n<h2 id=\"基本概念\"><a class=\"markdownIt-Anchor\" href=\"#基本概念\">#</a> 基本概念</h2>\n<p>首先，为了方便理解，我们需要了解一下 RocketMQ 中的一些基本概念、运行逻辑与名词，方便后续理解掌握。</p>\n<blockquote>\n<p>该章节整理自文章<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc4MDk2OA==\"> RocketMQ 简介 - 阿里云开发者社区 (aliyun.com) </span>原文更加详细，可通过链接了解详情。</p>\n</blockquote>\n<h3 id=\"专有名词\"><a class=\"markdownIt-Anchor\" href=\"#专有名词\">#</a> 专有名词</h3>\n<h4 id=\"基本\"><a class=\"markdownIt-Anchor\" href=\"#基本\">#</a> 基本</h4>\n<ul>\n<li><strong>NameServer</strong>：注册中心，相当于 ZooKeeper，不过 RocketMQ 进行了另外的实现，比较轻便。</li>\n<li><strong>Broker</strong>：消息的管理中心，其负责管理 Topic 与保存传入的消息，并且会将自己注册到 NameServer 中供其调度，其由 RocketMQ 实现。</li>\n<li><strong>Producer</strong>：也称为消息发布者，负责产生消息，需要我们自行产生消息。</li>\n<li><strong>Consumer</strong>：也称为消息订阅者，负责接收消息并处理消息，需要我们自行处理消息。</li>\n</ul>\n<h4 id=\"消息属性相关\"><a class=\"markdownIt-Anchor\" href=\"#消息属性相关\">#</a> 消息属性相关</h4>\n<ul>\n<li><strong>Topic</strong>：消息主题，一级消息类型，生产者向其发送消息，消费者从中取出消息进行消费。</li>\n<li><strong>Message</strong>：生产者向 Topic 发送并最终传送给消费者的数据消息体。</li>\n<li><strong>Message ID</strong>：消息的全局唯一标识，由消息队列 RocketMQ 系统自动生成，唯一标识某条消息。</li>\n<li><strong>Message Key</strong>：消息的业务标识，由消息生产者（Producer）自行设置，可作为标识符使用标识一类业务逻辑，也可不提供。</li>\n<li><strong>Tag</strong>：消息标签，二级消息类型，由消息生产者（Producer）自行设置，用来进一步区分某个 Topic 下的消息</li>\n</ul>\n<h4 id=\"运行逻辑相关\"><a class=\"markdownIt-Anchor\" href=\"#运行逻辑相关\">#</a> 运行逻辑相关</h4>\n<ul>\n<li><strong>分区</strong>：即 Topic Partition，物理上的概念。每个 Topic 包含一个或多个分区，由 RocketMQ 实现。</li>\n<li><strong>消费位点</strong>：每个 Topic 会有多个分区，每个分区会统计当前消息的总条数，这个称为最大位点 MaxOffset；分区的起始位置对应的位置叫做起始位点 MinOffset。</li>\n<li><a id=\"Group\"><strong>Group</strong></a>：对生产者或消费者进行分组，同一组的生产者或消费者通常仅生产或消费同一类消息，且消息发布或订阅的逻辑一致，因此通常需要保证同组中的生产者与生产者之间或者消费者与消费者之间业务逻辑一致。在<a href=\"#%E9%9B%86%E7%BE%A4%E6%B6%88%E8%B4%B9\"> 集群消费 </a>模式下，该设计方式能够方便地对于生产者与消费者进行拓展。比如当某组中任务负载较大时，给组中额外增加多个生产者与消费者来分担该组的任务，降低负载。</li>\n<li><strong>Group ID</strong>：Group 的唯一标识，用于定位 Group，可以自行定制。</li>\n<li><strong>队列</strong>：一个 Topic 下会由一到多个队列来存储消息，其由 RocketMQ 实现。</li>\n<li><strong>Exactly-Once 投递语义</strong>：Exactly-Once 投递语义是指发送到消息系统的消息只能被 Consumer 处理且仅处理一次，即使 Producer 重试消息发送导致某消息重复投递，该消息在 Consumer 也只被消费一次。</li>\n</ul>\n<h4 id=\"消息收发相关\"><a class=\"markdownIt-Anchor\" href=\"#消息收发相关\">#</a> 消息收发相关</h4>\n<ul>\n<li><span id=\"集群消费\"><strong>集群消费</strong></span>：一个 Group ID 所标识的所有 Consumer 平均分摊消费消息。例如某个 Topic 有 9 条消息，一个 Group ID 有 3 个 Consumer 实例，那么在集群消费模式下每个实例平均分摊，只消费其中的 3 条消息。</li>\n<li><strong>广播消费</strong>：一个 Group ID 所标识的所有 Consumer 都会各自消费某条消息一次。例如某个 Topic 有 9 条消息，一个 Group ID 有 3 个 Consumer 实例，那么在广播消费模式下每个实例都会各自消费 9 条消息。</li>\n<li><strong>定时消息</strong>：Producer 将消息发送到消息队列 RocketMQ 服务端，但并不期望这条消息立马投递，而是推迟到在当前时间点之后的某一个时间投递到 Consumer 进行消费，该消息即定时消息。</li>\n<li><a id=\"延时消息\"><strong>延时消息</strong></a>：Producer 将消息发送到消息队列 RocketMQ 服务端，但并不期望这条消息立马投递，而是延迟一定时间后才投递到 Consumer 进行消费，该消息即延时消息。</li>\n<li><strong>事务消息</strong>：RocketMQ 提供类似 X/Open XA 的分布事务功能，通过消息队列 RocketMQ 的事务消息能达到分布式事务的最终一致。</li>\n<li><a id=\"顺序消息\"><strong>顺序消息</strong></a>：RocketMQ 提供的一种按照顺序进行发布和消费的消息类型，分为全局顺序消息和分区顺序消息。\n<ul>\n<li><strong>全局顺序消息</strong>：对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。</li>\n<li><strong>分区顺序消息</strong>：对于指定的一个 Topic，所有消息根据 Sharding Key 进行区块分区。同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。Sharding Key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Message Key 是完全不同的概念。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"概念相关\"><a class=\"markdownIt-Anchor\" href=\"#概念相关\">#</a> 概念相关</h4>\n<ul>\n<li><strong>消息堆积</strong>：Producer 已经将消息发送到消息队列 RocketMQ 的服务端，但由于 Consumer 消费能力有限，未能在短时间内将所有消息正确消费掉，此时在消息队列 RocketMQ 的服务端保存着未被消费的消息，该状态即消息堆积。</li>\n<li><strong>消息过滤</strong>：Consumer 可以根据消息标签（Tag）对消息进行过滤，确保 Consumer 最终只接收被过滤后的消息类型。消息过滤在消息队列 RocketMQ 的服务端完成。</li>\n<li><strong>消息轨迹</strong>：在一条消息从 Producer 发出到 Consumer 消费处理过程中，由各个相关节点的时间、地点等数据汇聚而成的完整链路信息。通过消息轨迹，您能清晰定位消息从 Producer 发出，经由消息队列 RocketMQ 服务端，投递给 Consumer 的完整链路，方便定位排查问题。</li>\n<li><strong>重置消费位点</strong>：以时间轴为坐标，在消息持久化存储的时间范围内（默认 3 天），重新设置 Consumer 对已订阅的 Topic 的消费进度，设置完成后 Consumer 将接收设定时间点之后由 Producer 发送到消息队列 RocketMQ 服务端的消息。</li>\n<li><strong>死信队列</strong>：死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明 Consumer 在正常情况下无法正确地消费该消息。此时，消息队列 RocketMQ 不会立刻将消息丢弃，而是将这条消息发送到该 Consumer 对应的特殊队列中。<br>\n消息队列 RocketMQ 将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。</li>\n</ul>\n<h3 id=\"消息流转模型\"><a class=\"markdownIt-Anchor\" href=\"#消息流转模型\">#</a> 消息流转模型</h3>\n<p>消息队列 RocketMQ 支持发布和订阅模型，消息生产者应用创建 Topic 并将消息发送到 Topic。消费者应用创建对 Topic 的订阅以便从其接收消息。通信可以是一对多（扇出）、多对一（扇入）和多对多。具体通信如下图所示。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/8c2f59ab52f03f20d7a859e7c8bb82b4.png\" class=\"\" title=\"消息流转模型\">\n<ul>\n<li><strong>生产者集群</strong>：用来表示发送消息应用，一个生产者集群下包含多个生产者实例，可以是多台机器，也可以是一台机器的多个进程，或者一个进程的多个生产者对象。<br>\n一个生产者集群可以发送多个 Topic 消息。发送分布式事务消息时，如果生产者中途意外宕机，消息队列 RocketMQ 服务端会主动回调生产者集群的任意一台机器来确认事务状态。</li>\n<li><strong>消费者集群</strong>：用来表示消费消息应用，一个消费者集群下包含多个消费者实例，可以是多台机器，也可以是多个进程，或者是一个进程的多个消费者对象。<br>\n一个消费者集群下的多个消费者以均摊方式消费消息。如果设置的是广播方式，那么这个消费者集群下的每个实例都消费全量数据。<br>\n一个消费者集群对应一个 Group ID，一个 Group ID 可以订阅多个 Topic，如上图中的 Group 2 所示。Group 和 Topic 的订阅关系可以通过直接在程序中设置即可。</li>\n</ul>\n<h2 id=\"获取范例项目\"><a class=\"markdownIt-Anchor\" href=\"#获取范例项目\">#</a> 获取范例项目</h2>\n<p>在安装文档中涉及到的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcS1leHRlcm5hbHM=\"> GitHub - apache/rocketmq-externals</span> 项目 ReadMe 中也提及到了一个关联 Spring 的 RocketMQ 项目。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/3dff3ecbdea41baddb69e24f1b1508d0.png\" class=\"\" title=\"拓展项目\">\n<p>项目地址如下<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcS1zcHJpbmc=\"> GitHub - apache/rocketmq-spring</span>。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/7f17ece34decafc3f316002155feaace.png\" class=\"\" title=\"拓展项目2\">\n<p>在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcS1zcHJpbmcvdHJlZS9tYXN0ZXIvcm9ja2V0bXEtc3ByaW5nLWJvb3Qtc2FtcGxlcw==\"> rocketmq-spring-boot-samples</span> 中则是基于 Spring 搭建的 RocketMQ 的范例项目，包含生产者与消费者 demo，可以进行参考学习。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/00ec143cf8ed26fc1976f7b12d66bc0d.png\" class=\"\" title=\"拓展项目3\">\n<p>由于该项目未依赖父项目，可以单独将其拉下来运行，也可以将该 rocketmq-spring 项目完整拉取下来使用。</p>\n<h3 id=\"span-id单独拉取单独拉取span\"><a class=\"markdownIt-Anchor\" href=\"#span-id单独拉取单独拉取span\">#</a> <span id=\"单独拉取\">单独拉取</span></h3>\n<p>项目拉取下来后使用 IDE 打开，IDEA 会自动加载 rocketmq-spring-boot-starter 的依赖，此时可能会出现依赖版本问题。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/1855df2c2cc50f3a51b2be2fbcec82b3.png\" class=\"\" title=\"下载样例项目\">\n<p>当前版本的 pom，此处给 rocketmq-spring-boot-starter 配置的是 2.2.3 快照版本，但是在 maven 仓库中已经修改 2.2.3 为正式的版本号，rocketmq-spring-boot-starter 源码版本也已经定义为 2.2.4-SNAPSHOT，此处应该是版本升级的疏漏。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/c6b66903f7110483a2f6fbb565e1611f.png\" class=\"\" title=\"下载样例项目2\">\n<p>对应修改一下版本号即可，修改为 2.2.3 直接重新运行一下 maven 导入。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/829c1285ceee1dc98d4b41a5f7df3182.png\" class=\"\" title=\"下载样例项目3\">\n<p>子项目均被解析为 maven 项目（项目图标右下角带蓝色小方格即表示已被解析为 maven 项目，且其中的文件结构不再是普通的文件夹结构，而是已包结构排列，并且特定的文件夹具有特定图标，如 java、resources、test 等），并且依赖项不报红，代表项目导入成功。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/cc2e1fedcb6a16cd07d8f3765e39c30a.png\" class=\"\" title=\"下载样例项目4\">\n<h3 id=\"完整拉取\"><a class=\"markdownIt-Anchor\" href=\"#完整拉取\">#</a> 完整拉取</h3>\n<p>项目拉取下来之后使用 IDE 打开，等待其安装依赖项，防止依赖项安装失败，或者找不到依赖项可以使用阿里的 maven 镜像。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mirrors</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>alimaven<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>aliyun maven<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">mirrorOf</span>&gt;</span>central<span class=\"tag\">&lt;/<span class=\"name\">mirrorOf</span>&gt;</span>        </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>项目导入成功。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/33ebac62954c73bc818a6b382c3fa99b.png\" class=\"\" title=\"下载样例项目5\">\n<p>编者此处 samples 并没有被解析为 maven，是由于在根目录的 pom.xml 中，该模块被默认注释掉了。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/6131a66f3f3e5ef5034e7b983c52b9e4.png\" class=\"\" title=\"下载样例项目6\">\n<p>将 module 标签处的注释放开然后重新跑 maven 一遍，maven 就会去解析 rocketmq-spring-boot-samples 下的 pom.xml 文件。此时可能会遇到与上文<a href=\"#%E5%8D%95%E7%8B%AC%E6%8B%89%E5%8F%96\"> 单独拉取 </a>时相同的情况，进入到 rocketmq-spring-boot-samples 下的 pom 中采用相同方式解决即可。</p>\n<h2 id=\"补充说明\"><a class=\"markdownIt-Anchor\" href=\"#补充说明\">#</a> 补充说明</h2>\n<p>此处补充一些范例项目中出现的不常见的且不涉及 RocketMQ 逻辑的代码的解析，方便对范例项目进行理解。</p>\n<h3 id=\"commandlinerunner\"><a class=\"markdownIt-Anchor\" href=\"#commandlinerunner\">#</a> CommandLineRunner</h3>\n<p>在生产者与消费者项目中都使用了 CommandLineRunner 接口。这里来探究以下该接口的效果。</p>\n<p>在启动 spring 应用时，会使用到如下的基本的 spring 启动代码 <code>SpringApplication.run(ProducerApplication.class, args)</code> ，进入到该方法中可以看到在经过多个默认的 run 方法后最终调用到了一个 run 方法中。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/2a07379410e7944edce47ae2826160c1.png\" class=\"\" title=\"run\">\n<p>我们可以看到在该方法中 spring 进行了一系列环境的初始化操作，将 spring 环境运行起来。这部分的逻辑都不重要。</p>\n<p>在 try 代码段的末尾，我们可以看到其调用了一段 <code>callRunners(context, applicationArguments)</code>  方法，传入了 spring 容器对象以及通过启动参数 args 构造出来的 ApplicationArguments 参数对象。</p>\n<p>进入到该方法中可以看到如下方法体。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/8b8970858a59e8a0e33e6f90dc0713f3.png\" class=\"\" title=\"run2\">\n<p>可以推出该方法的逻辑是将 ApplicationRunner.class 与 CommandLineRunner.class 构造出来的 Bean 添加到 runners 列表中，排序后依次将运行参数传入然后进行调用。</p>\n<p>简而言之，在启动 Spring 应用后，会在应用装配完毕时，运行 CommandLineRunner 与 ApplicationRunner 中的代码。并且该运行时机是要晚于 InitializingBean 的，能够确保所有 Bean 均已加载完毕。可以用来作为 Spring 应用启动后的初始化数据的方案，因为 bean 已装填完毕，可以正常使用 Spring 的功能。</p>\n<p>需要注意的是此处的代码是影响到 Spring 主线程的，如果出现异常会打断 Spring 应用的启动过程。</p>\n<p>在 demo 中的效果就是，对应的方法仅仅在启动时运行一遍，里面涉及到的就是一些演示代码。</p>\n<h2 id=\"理解范例项目\"><a class=\"markdownIt-Anchor\" href=\"#理解范例项目\">#</a> 理解范例项目</h2>\n<h3 id=\"生产者producer\"><a class=\"markdownIt-Anchor\" href=\"#生产者producer\">#</a> 生产者（Producer）</h3>\n<h4 id=\"extrocketmqtemplateconfiguration\"><a class=\"markdownIt-Anchor\" href=\"#extrocketmqtemplateconfiguration\">#</a> @ExtRocketMQTemplateConfiguration</h4>\n<p>该类是一个注解类，其携带了 Spring 中的 @Component 类，因此被该注解修饰的类会被 Spring 解析为一个 bean 组件，可以直接通过 spring bean 的一些方式来使用。</p>\n<p>很容易就能看出，该注解是用来修饰 RocketMQTemplate 及其拓展类，并且主要修饰发送方，即生产者端的 RocketMQTemplate。该注解能够为 RocketMQTemplate 及其拓展类规定一些默认的运行参数，生产者 demo 中就使用了其中的 nameServer 参数用于指定目标 NameServer 地址，使用了 tlsEnable 用于指定是否开启 tls 加密，使用 instanceName 指定实例名称。</p>\n<h4 id=\"rocketmqtemplate\"><a class=\"markdownIt-Anchor\" href=\"#rocketmqtemplate\">#</a> RocketMQTemplate</h4>\n<p>在生产者 demo 中，使用了该类中非常多种的发送方法，并且该类大多数方法都是用于生产者发送消息。因此将该类放到生产者部分讲解。需要注意的是对于每一类功能逻辑而言，应该单独拓展一个 RocketMQTemplate 子类，因为<a id=\"当使用事务消息时\">当使用事务消息时</a>，事务监听器是直接与 RocketMQTemplate 类进行绑定的，因此为了防止事务状态紊乱出错，推荐每个功能模块单独拓展一个 RocketMQTemplate 子类，后续会进行详述。因为该类中的方法众多，为了节省篇幅且便于拓展理解，这里对其进行大概的分类解释，便于自行了解这些方法的含义。</p>\n<h5 id=\"常见参数\"><a class=\"markdownIt-Anchor\" href=\"#常见参数\">#</a> 常见参数</h5>\n<ul>\n<li>\n<p>destination：用来定位当前参数需要发送到哪个 Topic，以及携带什么 Tag，标准格式为 <code>topicName:tags</code> （文档注释中此处为 tags，但是据查生产者是无法为消息指定多个 tag 的）。<br>\n例如：“test:tag1”，表示当前消息将会发送到名为 test 的 Topic 中，并且 tag 为 tag1。</p>\n</li>\n<li>\n<p>payload：消息载体，可以接收任何类对象，在发送前一般都会经过 MessageBuilder.withPayload (payload) 转化为 Message 对象。</p>\n</li>\n<li>\n<p>message/messages：一般是 Message 类对象，发送动作主要就是通过该类对象来进行，可以通过 MessageBuilder 获得</p>\n</li>\n<li>\n<p>timeout：发送超时时间，单位毫秒，当不指定时一般默认为 3 秒。</p>\n</li>\n<li>\n<p>delayLevel：延时级别，该参数不支持任意时间精度，仅支持特定的 level，例如定时 5s,10s,1m 等。其中 level=0 级表示不延时，level=1 表示 1 级延时，level=2 表示 2 级延时，以此类推。<br>\n延时级别的配置在 broker 配置（ROCKETMQ 根路径 /conf/broker.conf）中 <code>messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</code> 。时间单位支持：s、m、h、d，分别表示秒、分、时、天。</p>\n</li>\n<li>\n<p>delayTime：延时时间，可以详细指定延时时间，默认单位为毫秒。</p>\n</li>\n<li>\n<p>deliverTimeMills：交付时间，可以详细指定延时时间，默认单位为毫秒。</p>\n</li>\n<li>\n<p>mode：与 delayTime 或 deliverTimeMills 同时出现，接收 DelayMode 枚举对象。具有三种值，分别是 DELAY_SECONDS，DELAY_MILLISECONDS，DELIVER_TIME_MILLISECONDS。</p>\n<ul>\n<li>单独使用 deliverTimeMills 时，mode 默认为 DelayMode.DELIVER_TIME_MILLISECONDS</li>\n<li>单独使用 delayTime 时，默认 mode 为 DELAY_MILLISECONDS</li>\n</ul>\n<p>未查到二者的详细说明可能为新增 api，判断二者区别可能在于延时投递的方式不同。</p>\n</li>\n<li>\n<p>hashKey：用于为消息进行定位和排序。</p>\n</li>\n<li>\n<p>type：一般出现于同步消息时，用于规定返回消息的类型。</p>\n</li>\n<li>\n<p>sendCallback/rocketMQLocalRequestCallback：用于异步消息时的回调。</p>\n<ul>\n<li>sendCallback：为 SendCallback 对象，其中接收返回值时使用的是 SendResult 对象，内部以 byte 数组保存信息。</li>\n<li>rocketMQLocalRequestCallback：为 RocketMQLocalRequestCallback&lt;T&gt; 对象，返回值可以直接用泛型 T 接收，内部会自动转换成 T。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"同步与异步\"><a class=\"markdownIt-Anchor\" href=\"#同步与异步\">#</a> 同步与异步</h5>\n<ul>\n<li>\n<p>带 sync 的方法：表示同步方法，调用该方法之后会阻塞当前线程，直达该方法成功完成、超时或抛错。<br>\n例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SendResult</span> <span class=\"variable\">sendResult</span> <span class=\"operator\">=</span> rocketMQTemplate.syncSend(springTopic, <span class=\"string\">&quot;Hello, World!&quot;</span>);</span><br><span class=\"line\">System.out.printf(<span class=\"string\">&quot;syncSend1 to topic %s sendResult=%s %n&quot;</span>, springTopic, sendResult);</span><br></pre></td></tr></table></figure>\n<p>这里必须要等到 syncSend 返回了 SendResult 后才会来到下方的 printf。</p>\n</li>\n<li>\n<p>带 async 的方法：表示异步方法，其中需要定义对应的回调，即 SendCallback。调用该方法后并不会阻塞当前线程，当该方法处理成功或者失败是则会自行运行 SendCallback 中对应的代码块。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rocketMQTemplate.asyncSend(orderPaidTopic, <span class=\"keyword\">new</span> <span class=\"title class_\">OrderPaidEvent</span>(<span class=\"string\">&quot;T_001&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;88.00&quot;</span>)), <span class=\"keyword\">new</span> <span class=\"title class_\">SendCallback</span>() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span><span class=\"params\">(SendResult var1)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;async onSucess SendResult=%s %n&quot;</span>, var1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onException</span><span class=\"params\">(Throwable var1)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;async onException Throwable=%s %n&quot;</span>, var1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里该方法并没有返回值，该 async 方法会启用另外一个线程去发送消息，开始发送后放行主线程，由该线程完成剩下的接收并回调 SendCallback 操作。</p>\n</li>\n</ul>\n<h5 id=\"发送模式\"><a class=\"markdownIt-Anchor\" href=\"#发送模式\">#</a> 发送模式</h5>\n<ul>\n<li>\n<p>send：普通的发送方法，发送一条普通消息并通过 SendResult 接收返回消息，其中的数据形式为序列化后的 byte 数组形式，不可直接使用。</p>\n</li>\n<li>\n<p>convertAndSend：来自 Spring 的默认实现 AbstractMessageSendingTemplate 提供的方法，该方法会调用配置好的 MessageConverter 为消息载体进行转化，转化成 Message 对象后再进行发送，效果上与 send 并无不同。</p>\n</li>\n<li>\n<p>sendAndReceive：发送并接收远端的响应，同步与异步方式均可用。该可以将远端的响应反序列化成指定类型的对象，同步方式下需要提供 Type 对象来表明返回值类型，而异步方式下则需要提供 <code>RocketMQLocalRequestCallback&lt;T&gt;</code>  对象用来异步回调，该对象回调时则是通过其所提供的泛型来确定返回值类型。</p>\n</li>\n<li>\n<p>oneWay：发送消息，但是不追踪其返回，也就无法判断是否发送成功，拥有较高的运行性能，但是通过该方式发送可能会出现消息丢失的情况。</p>\n</li>\n<li>\n<p>delay：发送延时消息，需要提供一个延时，其他与普通消息一致，基本逻辑同上方对<a href=\"#%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF\"> 延时消息 </a>的表述一致。</p>\n</li>\n<li>\n<p>orderly：发送顺序消息，需要为消息提供一个 hashKey，用于对消息的排序，其他与普通消息一致，基本逻辑同上方对<a href=\"#%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF\"> 顺序消息 </a>的表述一致。</p>\n</li>\n</ul>\n<h5 id=\"发送事务消息\"><a class=\"markdownIt-Anchor\" href=\"#发送事务消息\">#</a> 发送事务消息</h5>\n<p>sendMessageInTransaction 用于发送事务消息，在构造消息时，可以通过 <code>setHeader(RocketMQHeaders.TRANSACTION_ID, [事务id])</code>  的方式向 header 中设置事务 id 用作事务标识，后续也可以从 header 中取出来使用。</p>\n<h6 id=\"事务监听器\"><a class=\"markdownIt-Anchor\" href=\"#事务监听器\">#</a> 事务监听器</h6>\n<p>在使用事务前，我们需要为事务实现一个事务监听器，节省篇幅，我们这里使用 demo 中较简单的监听器示例来讲解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RocketMQTransactionListener(rocketMQTemplateBeanName = &quot;extRocketMQTemplate&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExtTransactionListenerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">RocketMQLocalTransactionListener</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RocketMQLocalTransactionState <span class=\"title function_\">executeLocalTransaction</span><span class=\"params\">(Message msg, Object arg)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;ExtTransactionListenerImpl executeLocalTransaction and return UNKNOWN. \\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RocketMQLocalTransactionState.UNKNOWN;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RocketMQLocalTransactionState <span class=\"title function_\">checkLocalTransaction</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;ExtTransactionListenerImpl checkLocalTransaction and return COMMIT. \\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现事务监听器后，需要通过 @RocketMQTransactionListener 注解将监听器与 rocketMQTemplate 的 bean 进行关联，参数 rocketMQTemplateBeanName 用来确定需要关联的 RocketMQTemplate 的 bean 的名称，其默认值为 rocketMQTemplate。其与 RocketMQTemplate 是一一对应的关系，这也就是为什么上文提到<a href=\"#%E5%BD%93%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%97%B6\">当使用事务消息时</a>，最好单独拓展一个 rocketMQTemplate。</p>\n<p>并且该监听器也会被注册为 bean，并通过 org.apache.rocketmq.spring.autoconfigure.RocketMQTransactionConfiguration 类中的以下方法将 bean 对象与对应的 rocketMQTemplate 的 bean 对象进行关联。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterSingletonsInstantiated</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Map&lt;String, Object&gt; beans = <span class=\"built_in\">this</span>.applicationContext.getBeansWithAnnotation(RocketMQTransactionListener.class)</span><br><span class=\"line\">        .entrySet().stream().filter(entry -&gt; !ScopedProxyUtils.isScopedTarget(entry.getKey()))</span><br><span class=\"line\">        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span><br><span class=\"line\"></span><br><span class=\"line\">    beans.forEach(<span class=\"built_in\">this</span>::registerTransactionListener);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerTransactionListener</span><span class=\"params\">(String beanName, Object bean)</span> &#123;</span><br><span class=\"line\">    Class&lt;?&gt; clazz = AopProxyUtils.ultimateTargetClass(bean);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!RocketMQLocalTransactionListener.class.isAssignableFrom(bean.getClass())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(clazz + <span class=\"string\">&quot; is not instance of &quot;</span> + RocketMQLocalTransactionListener.class.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">RocketMQTransactionListener</span> <span class=\"variable\">annotation</span> <span class=\"operator\">=</span> clazz.getAnnotation(RocketMQTransactionListener.class);</span><br><span class=\"line\">    <span class=\"type\">RocketMQTemplate</span> <span class=\"variable\">rocketMQTemplate</span> <span class=\"operator\">=</span> (RocketMQTemplate) applicationContext.getBean(annotation.rocketMQTemplateBeanName());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (((TransactionMQProducer) rocketMQTemplate.getProducer()).getTransactionListener() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(annotation.rocketMQTemplateBeanName() + <span class=\"string\">&quot; already exists RocketMQLocalTransactionListener&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ((TransactionMQProducer) rocketMQTemplate.getProducer()).setExecutorService(<span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(annotation.corePoolSize(), annotation.maximumPoolSize(),</span><br><span class=\"line\">                                                                                                       annotation.keepAliveTime(), annotation.keepAliveTimeUnit(), <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingDeque</span>&lt;&gt;(annotation.blockingQueueSize())));</span><br><span class=\"line\">    ((TransactionMQProducer) rocketMQTemplate.getProducer()).setTransactionListener(RocketMQUtil.convert((RocketMQLocalTransactionListener) bean));</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;RocketMQLocalTransactionListener &#123;&#125; register to &#123;&#125; success&quot;</span>, clazz.getName(), annotation.rocketMQTemplateBeanName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说最终事务中使用到的监听器，是注入到 spring 容器中的监听器 bean，并不是新创建的，设计上需要注意。</p>\n<h6 id=\"监听器的用处\"><a class=\"markdownIt-Anchor\" href=\"#监听器的用处\">#</a> 监听器的用处</h6>\n<p>在事务监听器中包含两个方法，分别是<a id=\"executeLocalTransaction\"> <code>executeLocalTransaction</code> </a>和<a id=\"checkLocalTransaction\"> <code>checkLocalTransaction</code> </a>。，从事务的运行逻辑顺序入手，来探究一下这些方法的作用。以下给出事务的运行逻辑。</p>\n<blockquote>\n<p>图片引用自文章<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzaDIwNTAvYXJ0aWNsZS9kZXRhaWxzLzEyNDUxNzM1NQ==\"> RocketMQ 事务消息机制_rocketmqtransactionlistener</span></p>\n</blockquote>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/c2eb61b0adcdc503d4314ecc070e2f25.png\" class=\"\" title=\"引用图片\">\n<ol>\n<li>在调用 Transaction 相关方法后，会先将消息发送出去，此时采用的是同步方式，即当前线程会被阻塞，直到获取到远端返回过来的发送结果。此时来到远端 broker 中的事务消息并不是一个可用消息，而是一个半消息，是无法被消费者消费的 **（此处对应图中第 1 步）**。</li>\n<li>根据发送结果的状态来进行，最终会提供一个 LocalTransactionState 来作为最终事务处理的依据：\n<ol>\n<li>当状态为 SEND_OK 时 **（此处对应图中第 2 步）<strong>，就会来到<a href=\"#executeLocalTransaction\"> executeLocalTransaction</a> 方法将此前发送的消息传入作为参数传入，由其进行本地事务的后续处理，然后提供一个事务状态 RocketMQLocalTransactionState 枚举。其中包含三种值并最终与 LocalTransactionState 相对应</strong>（此处对应图中第 3 步）**。\n<ul>\n<li>COMMIT 对应 LocalTransactionState 的<a href=\"#%E6%8F%90%E4%BA%A4\">提交</a>态</li>\n<li>ROLLBACK 对应 LocalTransactionState 的<a href=\"#%E5%9B%9E%E6%BB%9A\">回滚</a>态</li>\n<li>UNKNOWN 对应 LocalTransactionState 的<a href=\"#%E6%9C%AA%E7%9F%A5\">未知</a>态。</li>\n</ul>\n</li>\n<li>当状态为 FLUSH_DISK_TIMEOUT，FLUSH_SLAVE_TIMEOUT 或者 SLAVE_NOT_AVAILABLE 时，LocalTransactionState 将被置为<a href=\"#%E5%9B%9E%E6%BB%9A\">回滚</a>态。</li>\n<li>其他情况下，状态默认为<a href=\"#%E6%9C%AA%E7%9F%A5\">未知</a>态。</li>\n</ol>\n</li>\n<li>最后根据 LocalTransactionState 来对事务进行处理：\n<ul>\n<li><a id=\"提交\">提交</a>，告知 Broker 将当前事务消息置为可用，可以提供给消费者消费 **（此处对应图中第 4 步 Commit）**。</li>\n<li><a id=\"回滚\">回滚</a>，告知 Broker 回滚当前事务，删除对应的事务消息 **（此处对应图中第 4 步 Rollback）**。</li>\n<li><a id=\"未知\">未知</a>，可能当前事务应故（网络断开，回传消息受阻等）未能获取到消息的发送状态，或者由 executeLocalTransaction 提供了 UNKNOWN 的状态，接下来等待固定的时间后，broker 发起对事务的回查请求回查事务状态 **（此处对应图中第 5 步）<strong>。<br>\n消费者此时正常响应后，会进入到事务监听器的<a href=\"#checkLocalTransaction\"> <code>checkLocalTransaction</code> </a> 中来给出一个事务状态，判断事务接下来的处理方式</strong>（此处对应图中第 6 步）<strong>。最后发送给 broker 进行响应处理</strong>（此处对应图中第 7 步）**</li>\n</ul>\n</li>\n</ol>\n<p>可见监听器的主要用处，就是让开发者能够自行决定事务的提交和回滚，自定义实现消息的事务流程。发送事务消息的默认实现来自于 <code>org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl#sendMessageInTransaction</code>  方法，可以自行跟踪查看。</p>\n<h6 id=\"demo理解\"><a class=\"markdownIt-Anchor\" href=\"#demo理解\">#</a> demo 理解</h6>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RocketMQTransactionListener(rocketMQTemplateBeanName = &quot;extRocketMQTemplate&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExtTransactionListenerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">RocketMQLocalTransactionListener</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RocketMQLocalTransactionState <span class=\"title function_\">executeLocalTransaction</span><span class=\"params\">(Message msg, Object arg)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;ExtTransactionListenerImpl executeLocalTransaction and return UNKNOWN. \\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RocketMQLocalTransactionState.UNKNOWN;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RocketMQLocalTransactionState <span class=\"title function_\">checkLocalTransaction</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;ExtTransactionListenerImpl checkLocalTransaction and return COMMIT. \\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再看 demo 中的监听器梳理逻辑，就不难看出，该监听器关联名称为 <code>extRocketMQTemplate</code>  的 bean 组件，当我们通过使用该组件的 <code>sendMessageInTransaction</code>  方法发送事务消息时。</p>\n<ol>\n<li>消息发送成功后首先进入到 <code>executeLocalTransaction</code>  方法中，此处返回 UNKNOWN，也就是此时 broker 并不能确定当前事务需要如何处理，因此 broker 仍然将消息置为半消息状态，保存消息但是该消息不能被访问。</li>\n<li>再一段时间后，broker 再次尝试回查事务状态，此时来到 <code>checkLocalTransaction</code>  方法，此处返回 COMMIT，表示可以提交消息了，于是 broker 将消息置为可用状态。</li>\n</ol>\n<h3 id=\"消费者consumer\"><a class=\"markdownIt-Anchor\" href=\"#消费者consumer\">#</a> 消费者（Consumer）</h3>\n<p>对于消费者而言，消费消息具有两种模式，一种是 PUSH 模式，即当队列中存在消息，则 RocketMQ 服务端便将该消息 push 给对应消费该消息的消费者，即消费者被动消费消息，一种是 PULL 模式，即消费者通过 PULL 主动从 RocketMQ 服务端中获取未被消费的所有消息进行消费，即消费者主动消费。接下来讲解一下这两种模式的实现。</p>\n<h4 id=\"push模式\"><a class=\"markdownIt-Anchor\" href=\"#push模式\">#</a> PUSH 模式</h4>\n<p>push 模式下比较简单，消费者被动消费消息，只需要实现对应的监听器即可，由 RocketMQ 自行管理推送的逻辑。</p>\n<h5 id=\"rocketmqmessagelistener\"><a class=\"markdownIt-Anchor\" href=\"#rocketmqmessagelistener\">#</a> @RocketMQMessageListener</h5>\n<p>该类是一个注解类 ，用于添加到消费者监听器上，为该监听器指定一些对应的运行参数。例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RocketMQMessageListener(nameServer = &quot;$&#123;demo.rocketmq.myNameServer&#125;&quot;, topic = &quot;$&#123;demo.rocketmq.topic.user&#125;&quot;, consumerGroup = &quot;user_consumer&quot;)</span></span><br></pre></td></tr></table></figure>\n<p>这里为监听器指定了 NameServer 地址，并且指定了对应订阅的 topic，同时也可以通过 selectorType（默认值为 SelectorType.TAG）与 selectorExpression 为监听器指定对应的 tag 等分类信息，consumerGroup 为消费者指定了对应的<a href=\"#Group\">消费者组</a>。</p>\n<p>需要注意的是，该注解并不包含 Component 注解，因此不会将对应的监听器注册为 Spring bean 组件，需要自己另行注册或添加对应注解。</p>\n<h5 id=\"rocketmqlistener\"><a class=\"markdownIt-Anchor\" href=\"#rocketmqlistener\">#</a> RocketMQListener</h5>\n<p>该类为一个接口，是作为消费者需要实现的监听器接口之一，其接口代码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">RocketMQListener</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">onMessage</span><span class=\"params\">(T message)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该接口接受一个泛型参数，该泛型参数用于指定接受到的消息类型，当接受到对应的消息时，对应的消息内容会被转换为 T 所指定的类型传入到参数 message 中。</p>\n<p>demo 样例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RocketMQMessageListener(nameServer = &quot;$&#123;demo.rocketmq.myNameServer&#125;&quot;, topic = &quot;$&#123;demo.rocketmq.topic.user&#125;&quot;, consumerGroup = &quot;user_consumer&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserConsumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">RocketMQListener</span>&lt;User&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onMessage</span><span class=\"params\">(User message)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;######## user_consumer received: %s ; age: %s ; name: %s \\n&quot;</span>, message, message.getUserAge(), message.getUserName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该监听器会自动接收配置项 demo.rocketmq.topic.user 中的消息，当接收到消息时，会将消息中的二进制码部分反序列化为 User 对象作为 message 传入然后进行消费。</p>\n<h5 id=\"rocketmqreplylistener\"><a class=\"markdownIt-Anchor\" href=\"#rocketmqreplylistener\">#</a> RocketMQReplyListener</h5>\n<p>该类为一个接口，是作为消费者需要实现的监听器接口之一，其接口代码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">RocketMQReplyListener</span>&lt;T, R&gt; &#123;</span><br><span class=\"line\">    R <span class=\"title function_\">onMessage</span><span class=\"params\">(T message)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现该接口的监听器就支持对传入的消息回传进行对应的响应结果。该类接受的两个类型泛型 T、R 中，T 表示接受到的消息类型，效果同 RocketMQListener 中的 T；R 表示回传的响应数据的类型。</p>\n<p>demo 样例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RocketMQMessageListener(topic = &quot;$&#123;demo.rocketmq.objectRequestTopic&#125;&quot;, consumerGroup = &quot;$&#123;demo.rocketmq.objectRequestConsumer&#125;&quot;, selectorExpression = &quot;$&#123;demo.rocketmq.tag&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ObjectConsumerWithReplyUser</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">RocketMQReplyListener</span>&lt;User, User&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">onMessage</span><span class=\"params\">(User user)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;------- ObjectConsumerWithReplyUser received: %s \\n&quot;</span>, user);</span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">replyUser</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>();</span><br><span class=\"line\">        replyUser.setUserAge((<span class=\"type\">byte</span>) <span class=\"number\">10</span>);</span><br><span class=\"line\">        replyUser.setUserName(<span class=\"string\">&quot;replyUserName&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> replyUser;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该监听器能够接收配置项 demo.rocketmq.objectRequestTopic 指定的 topic 中具有由配置项 demo.rocketmq.tag 指定的 tag 的消息，当接收到消息时，会将消息中的二进制码部分反序列化为 User 对象作为 message 传入然后进行消费，完毕后构造了一个新的 User 对象作为响应返回，RocketMQ 将会将该返回值回传给消费者。</p>\n<h4 id=\"pull模式\"><a class=\"markdownIt-Anchor\" href=\"#pull模式\">#</a> PULL 模式</h4>\n<p>PULL 模式需要使用到此前提到的 RocketMQTemplate 类中的 receive 方法。</p>\n<h5 id=\"extrocketmqconsumerconfiguration\"><a class=\"markdownIt-Anchor\" href=\"#extrocketmqconsumerconfiguration\">#</a> @ExtRocketMQConsumerConfiguration</h5>\n<p>该类是一个注解类，同 @ExtRocketMQTemplateConfiguration 注解类似，作用于 RocketMQTemplate 子类上，不过主要用于提供给消费者主动拉取消息。例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ExtRocketMQConsumerConfiguration(topic = &quot;$&#123;demo.rocketmq.topic&#125;&quot;, group = &quot;string_consumer&quot;, tlsEnable = &quot;$&#123;demo.ext.consumer.tlsEnable&#125;&quot;)</span></span><br></pre></td></tr></table></figure>\n<p>这里为 RocketMQTemplate 指定了拉取的 topic，并指定了当前的消费者组，指定了是否开启 tls 加密。<br>\nser 对象作为响应返回，RocketMQ 将会将该返回值回传给消费者。</p>\n<h4 id=\"pull模式-2\"><a class=\"markdownIt-Anchor\" href=\"#pull模式-2\">#</a> PULL 模式</h4>\n<p>PULL 模式需要使用到此前提到的 RocketMQTemplate 类中的 receive 方法。</p>\n<h5 id=\"extrocketmqconsumerconfiguration-2\"><a class=\"markdownIt-Anchor\" href=\"#extrocketmqconsumerconfiguration-2\">#</a> @ExtRocketMQConsumerConfiguration</h5>\n<p>该类是一个注解类，同 @ExtRocketMQTemplateConfiguration 注解类似，作用于 RocketMQTemplate 子类上，不过主要用于提供给消费者主动拉取消息。例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ExtRocketMQConsumerConfiguration(topic = &quot;$&#123;demo.rocketmq.topic&#125;&quot;, group = &quot;string_consumer&quot;, tlsEnable = &quot;$&#123;demo.ext.consumer.tlsEnable&#125;&quot;)</span></span><br></pre></td></tr></table></figure>\n<p>这里为 RocketMQTemplate 指定了拉取的 topic，并指定了当前的消费者组，指定了是否开启 tls 加密。</p>\n",
            "tags": [
                "后端",
                "MQ",
                "RocketMQ"
            ]
        },
        {
            "id": "https://silvercrow42.github.io/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/",
            "url": "https://silvercrow42.github.io/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/",
            "title": "【RocketMQ】安装与部署（Windows）",
            "date_published": "2024-09-09T03:46:16.000Z",
            "content_html": "<h1 id=\"准备工作\"><a class=\"markdownIt-Anchor\" href=\"#准备工作\">#</a> 准备工作</h1>\n<h2 id=\"下载\"><a class=\"markdownIt-Anchor\" href=\"#下载\">#</a> 下载</h2>\n<p>可以在官网上下载<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yb2NrZXRtcS5hcGFjaGUub3JnL3poLw==\"> RocketMQ・官方网站 | RocketMQ (apache.org)</span><br>\n 或者直接到 Apache 的文件站点下<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcmNoaXZlLmFwYWNoZS5vcmcvZGlzdC9yb2NrZXRtcS8=\"> Index of /dist/rocketmq (apache.org)</span> 找到对应版本下载。</p>\n<p>这里以编写时的最新版本为例，选择 Binary 版本下载，该版本为编译后的版本，可以直接使用。</p>\n<p>Source 下载获取的是源码，需要经过编译后才可以使用，不过比较方便自行扩展，有扩展需求可以使用该版本自行编译。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/c687d3c664944954288c48a951b7aa5e.png\" class=\"\" title=\"官网下载页\">\n<p>下载完成后解压出来是如下的文件结构。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/7e6608c24fb49bcd9982d9b25fa9c819.png\" class=\"\" title=\"下载后的文件结构\">\n<p>以下以 windows 为环境演示。</p>\n<p>RocketMQ 依赖的是 Java 的运行环境，因此系统上应该安装 Java 并且拥有对应的环境变量 JAVA_HOME.</p>\n<p>RocketMQ 使用的 java 环境是 java8，对于高版本环境可能需要进行一些适配性的改动。</p>\n<p>在 RocketMQ 目录下的 bin 文件夹中有对应的服务启动脚本，包含 Linux 可运行的 sh 文件以及 Windows 可运行的 cmd 文件。</p>\n<h2 id=\"环境变量\"><a class=\"markdownIt-Anchor\" href=\"#环境变量\">#</a> 环境变量</h2>\n<p>解压完毕后需要手动添加名为 ROCKETMQ_HOME 的环境变量，索引到 RocketMQ 的解压目录即可，设置完毕后需要重启电脑。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/b9d692cbe18a30e8c27f757d0208f0ec.png\" class=\"\" title=\"环境变量设置\">\n<h1 id=\"nameserver\"><a class=\"markdownIt-Anchor\" href=\"#nameserver\">#</a> NameServer</h1>\n<p>打开 cmd 命令行后，通过 cd 命令进入到解压目录的 bin 目录下。然后使用 <code>start mqnamesrv.cmd </code> 命令新开一个命令行窗口启动 NameServer</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/31d4e322a0dd35ade7d8198071115f27.png\" class=\"\" title=\"新窗口启动NameServer\">\n<p>或者直接使用 <code>mqnamesrv.cmd</code>  在当前命令行中启动。</p>\n<p>其本质是通过此前设置的环境变量找到 RocketMQ 的 bin 路径，再通过该路径下的 runserver.cmd 脚本文件实现运行的，因此启动项配置其实来自 runserver.cmd 中。</p>\n<p>出现 The Name Server boot success 提示则表示 NameServer 服务启动成功，启动成功后不要关闭该命令窗口。</p>\n<h2 id=\"可能出现的问题\"><a class=\"markdownIt-Anchor\" href=\"#可能出现的问题\">#</a> 可能出现的问题</h2>\n<h3 id=\"please-set-the-rocketmq_home-variable-in-your-environment\"><a class=\"markdownIt-Anchor\" href=\"#please-set-the-rocketmq_home-variable-in-your-environment\">#</a> Please set the ROCKETMQ_HOME variable in your environment!</h3>\n<p>这个问题提示其实不够准确，并不一定是在我们没有设置环境变量时出现。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/45ac5254ebbaf057393dc8743474c119.png\" class=\"\" title=\"问题定位1\">\n<p>因为在运行过程中，脚本文件是通过环境变量来定位到 runserver.cmd 的位置再通过该脚本来启动应用的，因此在当 runserver.cmd 文件定位不到时才会出现该问题。</p>\n<p><strong>处理方法</strong>：可以重新打开一个命令行，然后通过 <code>echo %ROCKETMQ_HOME%</code> <br>\n 打印一下环境变量出来检查一下环境变量是否有误。同时这种方式也能够让环境变量刷新，如果此前曾经修改过环境变量而没有重启电脑，则这种方式能够让环境变量刷新成修改后的值。</p>\n<p>如果仍然没有解决，则可以进入到该对应路径下看看是否缺失了 runserver.cmd 文件，到这一步也都没有发现问题，那就只能重启一下试试，可能环境变量的更改并没有生效。</p>\n<h3 id=\"unrecognized-vm-option\"><a class=\"markdownIt-Anchor\" href=\"#unrecognized-vm-option\">#</a> Unrecognized VM option</h3>\n<p>在通过 runserver.cmd 运行时，如果以高于 java8 的版本作为环境运行可能会出现如下错误：<strong>Unrecognized VM option ’<br>\nUseConcMarkSweepGC’</strong></p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/41367fb287fe7a305b9b51f4c0fc252b.png\" class=\"\" title=\"问题定位2-1\">\n<p>这是因为在运行脚本中，包含了一些对 CMSGC 的一些调优参数。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/32ef686e52b0f1c87d1ef0640b87d779.png\" class=\"\" title=\"问题定位2-2\">\n<p>据查在 java9 中使用 G1 来作为 GC 的默认实现，从而废弃了 CMS 相关的一些参数。因此启动时需要进行一些相关参数的改动，或者将 java 降级，指定特定的 jre8 来作为虚拟机运行。</p>\n<p>在 sh 版本的 runserver 脚本中对 java 的版本进行了专门的适配，可以识别 java 版本采用特定的指令。如果使用 cmd 脚本时仍需要在 Java 高版本环境中运行，也可以参照 sh 版本脚本修改一下对应的虚拟机参数。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/3e12c58e5dd33d6864284ce2a5f8b783.png\" class=\"\" title=\"问题定位2-3\">\n<p><strong>处理方法</strong>：这里提供一个根据 sh 脚本修改过来的适配高版本 java 的 cmd 脚本，使用高版本运行时用该脚本替代原本的 runserver.cmd 即可。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\">rem Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class=\"line\">rem contributor license agreements.  See the NOTICE file distributed with</span><br><span class=\"line\">rem this work <span class=\"keyword\">for</span> additional information regarding copyright ownership.</span><br><span class=\"line\">rem The ASF licenses this file to You under the Apache License, Version <span class=\"number\">2.0</span></span><br><span class=\"line\">rem (the <span class=\"string\">&quot;License&quot;</span>); you may not use this file except <span class=\"keyword\">in</span> compliance with</span><br><span class=\"line\">rem the License.  You may obtain a <span class=\"built_in\">copy</span> of the License at</span><br><span class=\"line\">rem</span><br><span class=\"line\">rem     http://www.apache.org/licenses/LICENSE<span class=\"literal\">-2</span>.<span class=\"number\">0</span></span><br><span class=\"line\">rem</span><br><span class=\"line\">rem Unless required by applicable law or agreed to <span class=\"keyword\">in</span> writing, software</span><br><span class=\"line\">rem distributed under the License is distributed on an <span class=\"string\">&quot;AS IS&quot;</span> BASIS,</span><br><span class=\"line\">rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class=\"line\">rem See the License <span class=\"keyword\">for</span> the specific language governing permissions and</span><br><span class=\"line\">rem limitations under the License.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> not exist <span class=\"string\">&quot;%JAVA_HOME%\\bin\\java.exe&quot;</span> <span class=\"built_in\">echo</span> Please <span class=\"built_in\">set</span> the JAVA_HOME variable <span class=\"keyword\">in</span> your environment, We need java(x64)! &amp; <span class=\"keyword\">EXIT</span> /B <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA=%JAVA_HOME%\\bin\\java.exe&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">setlocal</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> BASE_DIR=%~dp0</span><br><span class=\"line\"><span class=\"built_in\">set</span> BASE_DIR=%BASE_DIR:~<span class=\"number\">0</span>,<span class=\"literal\">-1</span>%</span><br><span class=\"line\"><span class=\"keyword\">for</span> %%d <span class=\"keyword\">in</span> (%BASE_DIR%) <span class=\"keyword\">do</span> <span class=\"built_in\">set</span> BASE_DIR=%%~dpd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> CLASSPATH=.;%BASE_DIR%conf;%BASE_DIR%lib\\*;%CLASSPATH%</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -server -Xms4g -Xmx4g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=25 -XX:InitiatingHeapOccupancyPercent=30 -XX:SoftRefLRUPolicyMSPerMB=0&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -verbose:gc -Xloggc:&quot;</span>%USERPROFILE%\\rmq_srv_gc.log<span class=\"string\">&quot; -XX:+PrintGCDetails&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -XX:-OmitStackTraceInFastThrow&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -XX:-UseLargePages&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% %JAVA_OPT_EXT% -cp &quot;</span>%CLASSPATH%<span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> %*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;%JAVA%&quot;</span> %JAVA_OPT% %*</span><br></pre></td></tr></table></figure>\n<p><strong>为什么不对 cmd 脚本进行适配呢？</strong></p>\n<p>sh 脚本中的 java 版本适配其本质上，是通过运行  <code>java -version</code>  命令<br>\n获取到控制台输出的完整 java 版本信息。再通过字符串匹配的方式来获取 java 版本号，再去以 8 为基准去匹配对应的运行参数。</p>\n<p>经过测试，windows 平台下的 java -version 获取到的版本字符串通过命令行是无法捕获到的。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/b7e356d6851105053394a790c1b7de7f.png\" class=\"\" title=\"问题定位2-4\">\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/f051b72f858d696bb84b1f1c4eed0d5b.png\" class=\"\" title=\"问题定位2-5\">\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/1c6676e01f035d76dad63ad38e9526d7.png\" class=\"\" title=\"问题定位2-6\">\n<p>推测也就是这个原因 windows 导致没有办法单独通过命令行来确定 java 版本号，也自然就没有办法参照其进行适配了。</p>\n<h3 id=\"找不到或无法加载主类\"><a class=\"markdownIt-Anchor\" href=\"#找不到或无法加载主类\">#</a> 找不到或无法加载主类</h3>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/1e4aced6e93a87a20cd4152794c4fe3b.png\" class=\"\" title=\"问题定位3-1\">\n<p>该问题的主要诱因是环境变量中存在空格。导致解析命令时环境变量被分割成了两个命令。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/7ac4047b712f71097b7aff8518a1ec40.png\" class=\"\" title=\"问题定位3-2\">\n<p><strong>处理方法</strong>：最好的解决办法是变更目录，在 RocketMQ 的路径中不要存在空格。</p>\n<p>还有，其实当命令中存在不需要被分割的空格时，只需要使用 双引号 &quot;&quot; 将对应的命令包裹起来即可。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/3de37e56ef97c4035b99d58bca794e1a.png\" class=\"\" title=\"问题定位3-3\">\n<p>但是此处经过尝试后发现，该处被错误分割的情况消失，但是仍然存在问题，可能在 runserver 中的 BASE_DIR 与 CLASSPATH 等变量也需要加上双引号防止错误分割，解决起来较为麻烦，而且不清楚后续会不会造成其他问题，因此不再对这种情况进行处理。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/58845da6a693a14c8060ad228ef530fa.png\" class=\"\" title=\"问题定位3-4\">\n<h1 id=\"broker\"><a class=\"markdownIt-Anchor\" href=\"#broker\">#</a> Broker</h1>\n<h2 id=\"启动\"><a class=\"markdownIt-Anchor\" href=\"#启动\">#</a> 启动</h2>\n<p>在启动前需要先添加一个环境变量 NAMESRV_ADDR，用来指向 nameServer 服务的地址。因为测试部署时服务部署在本机，所以使用 localhost 地址，加上此前默认的端口 9876 作为环境变量值。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/66fc0e9db8f6c85a73f5ccd3f895102c.png\" class=\"\" title=\"broker环境变量\">\n<p>打开 cmd 命令行后，通过 cd 命令进入到 RocketMQ 解压目录的 bin 目录下，运行命令 <code>start mqbroker.cmd autoCreateTopicEnable=true</code>  启动服务。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/5ddf87816c70d2451863102cdf413784.png\" class=\"\" title=\"broker启动\">\n<p>出现 The broker […] boot success 提示则表示 broker 服务启动成功，启动成功后同样不要关闭该命令窗口。</p>\n<h3 id=\"可能出现的问题-2\"><a class=\"markdownIt-Anchor\" href=\"#可能出现的问题-2\">#</a> 可能出现的问题</h3>\n<p>因为运行逻辑类似，因此也会出现上述情况类似的问题，此处不过多阐述，对照着修改即可。</p>\n<p>关于 java 版本适配的问题，此处也提供一个高版本可用的运行脚本:</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\">rem Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class=\"line\">rem contributor license agreements.  See the NOTICE file distributed with</span><br><span class=\"line\">rem this work <span class=\"keyword\">for</span> additional information regarding copyright ownership.</span><br><span class=\"line\">rem The ASF licenses this file to You under the Apache License, Version <span class=\"number\">2.0</span></span><br><span class=\"line\">rem (the <span class=\"string\">&quot;License&quot;</span>); you may not use this file except <span class=\"keyword\">in</span> compliance with</span><br><span class=\"line\">rem the License.  You may obtain a <span class=\"built_in\">copy</span> of the License at</span><br><span class=\"line\">rem</span><br><span class=\"line\">rem     http://www.apache.org/licenses/LICENSE<span class=\"literal\">-2</span>.<span class=\"number\">0</span></span><br><span class=\"line\">rem</span><br><span class=\"line\">rem Unless required by applicable law or agreed to <span class=\"keyword\">in</span> writing, software</span><br><span class=\"line\">rem distributed under the License is distributed on an <span class=\"string\">&quot;AS IS&quot;</span> BASIS,</span><br><span class=\"line\">rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class=\"line\">rem See the License <span class=\"keyword\">for</span> the specific language governing permissions and</span><br><span class=\"line\">rem limitations under the License.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> not exist <span class=\"string\">&quot;%JAVA_HOME%\\bin\\java.exe&quot;</span> <span class=\"built_in\">echo</span> Please <span class=\"built_in\">set</span> the JAVA_HOME variable <span class=\"keyword\">in</span> your environment, We need java(x64)! &amp; <span class=\"keyword\">EXIT</span> /B <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA=%JAVA_HOME%\\bin\\java.exe&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">setlocal</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> BASE_DIR=%~dp0</span><br><span class=\"line\"><span class=\"built_in\">set</span> BASE_DIR=%BASE_DIR:~<span class=\"number\">0</span>,<span class=\"literal\">-1</span>%</span><br><span class=\"line\"><span class=\"keyword\">for</span> %%d <span class=\"keyword\">in</span> (%BASE_DIR%) <span class=\"keyword\">do</span> <span class=\"built_in\">set</span> BASE_DIR=%%~dpd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> CLASSPATH=.;%BASE_DIR%conf;%BASE_DIR%lib\\*;%CLASSPATH%</span><br><span class=\"line\"></span><br><span class=\"line\">rem ===========================================================================================</span><br><span class=\"line\">rem  JVM Configuration</span><br><span class=\"line\">rem ===========================================================================================</span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -server -Xms2g -Xmx2g&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=25 -XX:InitiatingHeapOccupancyPercent=30 -XX:SoftRefLRUPolicyMSPerMB=0 -XX:SurvivorRatio=8&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -verbose:gc -Xlog:gc*:file=%USERPROFILE%/mq_gc.log:time,tags:filecount=5,filesize=30M&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -XX:-OmitStackTraceInFastThrow&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -XX:+AlwaysPreTouch&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -XX:MaxDirectMemorySize=15g&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -XX:-UseLargePages -XX:-UseBiasedLocking&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -Drocketmq.client.logUseSlf4j=true&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% %JAVA_OPT_EXT% -cp %CLASSPATH%&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;%JAVA%&quot;</span> %JAVA_OPT% %*</span><br></pre></td></tr></table></figure>\n<p>用其取代 runbroker.cmd 即可。</p>\n<h4 id=\"导包问题\"><a class=\"markdownIt-Anchor\" href=\"#导包问题\">#</a> 导包问题</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalAccessError: <span class=\"keyword\">class</span> <span class=\"title class_\">org</span>.apache.rocketmq.common.UtilAll (in unnamed <span class=\"keyword\">module</span> @<span class=\"number\">0x4bde3f8a</span>) cannot access <span class=\"keyword\">class</span> <span class=\"title class_\">sun</span>.nio.ch.DirectBuffer (in <span class=\"keyword\">module</span> java.base) because <span class=\"keyword\">module</span> java.base does not export sun.nio.ch to unnamed <span class=\"keyword\">module</span> @<span class=\"number\">0x4bde3f8a</span></span><br></pre></td></tr></table></figure>\n<p>在启动参数中额外添加一句 <code>--add-exports=java.base/sun.nio.ch=ALL-UNNAMED</code>  即可.。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;%JAVA%&quot;</span> %JAVA_OPT% %*</span><br></pre></td></tr></table></figure>\n<p>更改为</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;%JAVA%&quot;</span> <span class=\"literal\">--add-exports</span>=java.base/sun.nio.ch=ALL<span class=\"literal\">-UNNAMED</span>  %JAVA_OPT% %*</span><br></pre></td></tr></table></figure>\n<h1 id=\"控制台\"><a class=\"markdownIt-Anchor\" href=\"#控制台\">#</a> 控制台</h1>\n<p>上述服务搭建成功后服务就已经可用了，但是为了便于管理其中的数据，我们需要搭建一个控制台，用来提供一个前端页面供我们管理数据。</p>\n<h2 id=\"获取源码\"><a class=\"markdownIt-Anchor\" href=\"#获取源码\">#</a> 获取源码</h2>\n<p>在早些时候，控制台项目隶属于<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcS1leHRlcm5hbHM=\"> GitHub - apache/rocketmq-externals</span><br>\n 项目下，位于其中的 rocketmq-console 中，其中还包含一些其他的 RocketMQ 的拓展项目，可以参考使用。后来控制台项目单独独立了出来，我们可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcS1kYXNoYm9hcmQ=\"> GitHub - apache/rocketmq-dashboard</span><br>\n 仓库中找到。</p>\n<p>首先将其源码通过以下 git 指令克隆到本地。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/apache/rocketmq-dashboard.git</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装依赖\"><a class=\"markdownIt-Anchor\" href=\"#安装依赖\">#</a> 安装依赖</h2>\n<p>克隆完毕后因为还需要处理依赖，有条件的话可以直接使用 JAVA 编译器打开，使用 IDEA 导入为 maven 项目的话会自动加载依赖，其本质上就是 java<br>\nspring 的项目。如果依赖下载较慢可以使用阿里的 maven 仓库作为中央仓库，因为本来就是阿里的项目，应该不会存在依赖版本等的问题。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mirrors</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>alimaven<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>aliyun maven<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">mirrorOf</span>&gt;</span>central<span class=\"tag\">&lt;/<span class=\"name\">mirrorOf</span>&gt;</span>        </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>不借助编译器处理依赖的话可以 cd 到项目目录下，自行使用 mvn 的指令去处理依赖。</p>\n<h2 id=\"启动-2\"><a class=\"markdownIt-Anchor\" href=\"#启动-2\">#</a> 启动</h2>\n<p>在依赖安装完成之后，在运行之前先要修改一下配置。其实配置项的功能描述在 application.yml 中都有，没有的大多是 spring 的基本配置，查 spring 对应的配置项即可。此处只包括影响到应用启动的配置。</p>\n<h3 id=\"配置nameserver地址\"><a class=\"markdownIt-Anchor\" href=\"#配置nameserver地址\">#</a> 配置 NameServer 地址</h3>\n<p>在 application.yml 中，需要配置一下此前的 NameServer 的 ip 地址，因为源码中的配置文件中 NameServer 地址配置多了一个 127.0.0.2:<br>\n9876 地址，运行过程中连接不上可能会报错，删掉即可。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/ab64039c47990f681af7755c6bd38b34.png\" class=\"\" title=\"配置控制台1\">\n<p>此处可以配置一个，也可以配置多个，使用 yml 的数组写法即可，即在每一项数组元素均使用 “-” 开头。</p>\n<p>如果在 properties 文件中数组则是类似于通常数组的写法，只不过每个元素都要单独写一项，比较麻烦。</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">rocketmq.config.namesrvAddrs[0]</span>=<span class=\"string\">127.0.0.1:9876</span></span><br><span class=\"line\"><span class=\"attr\">rocketmq.config.namesrvAddrs[1]</span>=<span class=\"string\">127.0.0.2:9876</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"配置启动端口\"><a class=\"markdownIt-Anchor\" href=\"#配置启动端口\">#</a> 配置启动端口</h3>\n<p>也可以配置一下当前控制台的启动使用的访问端口，随意一个空闲端口即可。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/b8fde91e184e69dc9ff077345526cc86.png\" class=\"\" title=\"配置控制台2\">\n<h3 id=\"启动-3\"><a class=\"markdownIt-Anchor\" href=\"#启动-3\">#</a> 启动</h3>\n<p>使用编译器启动，通过 <code>mvn spring-boot:run</code>  启动或者通过 maven 打包成 jar 包然后运行 jar 包均可，运行成功后如下图。</p>\n<h2 id=\"部署\"><a class=\"markdownIt-Anchor\" href=\"#部署\">#</a> 部署</h2>\n<p>部署时可以参照传统的 maven 项目进行打包部署，另外官方也提供了 docker 镜像来便捷部署，根据 ReadMe 中描述，通过以下 docker 指令拉取 docker 镜像。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull apacherocketmq/rocketmq<span class=\"literal\">-dashboard</span>:latest</span><br></pre></td></tr></table></figure>\n<p>然后通过以下指令修改参数后运行即可</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run <span class=\"literal\">-d</span> <span class=\"literal\">--name</span> rocketmq<span class=\"literal\">-dashboard</span> <span class=\"literal\">-e</span> <span class=\"string\">&quot;JAVA_OPTS=-Drocketmq.namesrv.addr=127.0.0.1:9876&quot;</span> <span class=\"literal\">-p</span> <span class=\"number\">8080</span>:<span class=\"number\">8080</span> <span class=\"literal\">-t</span> apacherocketmq/rocketmq<span class=\"literal\">-dashboard</span>:latest</span><br></pre></td></tr></table></figure>\n<p>其中 rockermq.namesrv.addr 的值为此前部署的 NameServer 的地址，-p 参数冒号前的值为应用在虚拟机中的启动端口，后面的值应该映射到宿主机开放给该服务的端口。</p>\n<h2 id=\"访问\"><a class=\"markdownIt-Anchor\" href=\"#访问\">#</a> 访问</h2>\n<p>启动后通过部署的 ip+port 端口的形式访问即可。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/3dad91ef206cef1c546745174e4bf0ea.png\" class=\"\" title=\"控制台界面\">\n<p>需要中文界面的话可以通过 ChangeLanguage 来切换语言。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/017a22bd9ca7d08ef9fe8bfd5559ad35.png\" class=\"\" title=\"英文\">\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/de23f48aafc56e32495a4e8b2ef513b7.png\" class=\"\" title=\"汉语\">\n<p>多语化文件放置在源码目录下的 <code>src/main/resources/static/src/i18n</code>  文件夹中，可参照前端的 i18n 标准自行修改翻译或者添加其他语言。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/cf3c5cd85f377a8d290e097b17e8dadd.png\" class=\"\" title=\"多语\">\n",
            "tags": [
                "后端",
                "MQ",
                "RocketMQ"
            ]
        }
    ]
}