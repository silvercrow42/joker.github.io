{
    "version": "https://jsonfeed.org/version/1",
    "title": "Joker • All posts by \"spring\" tag",
    "description": "",
    "home_page_url": "https://silvercrow42.github.io/joker.github.io",
    "items": [
        {
            "id": "https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Spring%E3%80%91spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/",
            "url": "https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Spring%E3%80%91spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/",
            "title": "spring面试题汇总",
            "date_published": "2024-09-13T03:24:41.000Z",
            "content_html": "<p><ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">Spring的基本概念</a>\n<ul>\n<li><a href=\"#1-spring-%E6%98%AF%E4%BB%80%E4%B9%88\">1、Spring 是什么？</a></li>\n<li><a href=\"#2-spring-%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E5%A5%BD%E5%A4%84\">2、Spring 带来哪些好处？</a></li>\n<li><a href=\"#3-%E8%AF%B4%E8%AF%B4-spring-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%9D%97\">3、说说 Spring 有哪些模块？</a></li>\n<li><a href=\"#4-spring-%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\">4、Spring 中使用了哪些设计模式？</a></li>\n<li><a href=\"#5-spring-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E4%BA%8B%E4%BB%B6\">5、Spring 中有哪些不同类型事件？</a></li>\n</ul>\n</li>\n<li><a href=\"#spring-ioc\">Spring IOC</a>\n<ul>\n<li><a href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF-ioc\">1、什么是 IOC？</a></li>\n<li><a href=\"#2-ioc-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%88%96%E5%A5%BD%E5%A4%84\">2、IOC 的作用或好处？</a></li>\n<li><a href=\"#3-ioc-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E9%87%8C\">3、IOC 的实现原里？</a></li>\n<li><a href=\"#4-spring-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%B9%E5%99%A8%E7%B1%BB\">4、Spring 有哪些容器类？</a></li>\n<li><a href=\"#5-beanfactory-%E5%92%8C-applicationcontext-%E7%9A%84%E5%8C%BA%E5%88%AB\">5、BeanFactory 和 ApplicationContext 的区别？</a></li>\n<li><a href=\"#6-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB\">6、有哪些注入方式以及区别？</a>\n<ul>\n<li><a href=\"#%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5\">构造器注入</a></li>\n<li><a href=\"#%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5\">属性注入</a></li>\n<li><a href=\"#%E5%AD%97%E6%AE%B5%E6%B3%A8%E5%85%A5\">字段注入</a></li>\n<li><a href=\"#%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%9A%84%E8%A7%84%E7%BA%A6\">一些使用上的规约</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#spring-bean\">Spring Bean</a>\n<ul>\n<li><a href=\"#1-spring-bean-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8%E5%9F%9F\">1、Spring Bean 有哪些作用域？</a>\n<ul>\n<li><a href=\"#spring-bean-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F\">Spring Bean 作用域配置方式</a></li>\n</ul>\n</li>\n<li><a href=\"#2-spring-%E7%9A%84%E5%8D%95%E4%BE%8B%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\">2、Spring 的单例是否线程安全？</a></li>\n<li><a href=\"#3-spring-bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">3、Spring Bean 的生命周期？</a></li>\n</ul>\n</li>\n<li><a href=\"#spring-aop\">Spring AOP</a>\n<ul>\n<li><a href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF-aop-%E4%BB%A5%E5%8F%8A%E4%BD%9C%E7%94%A8\">1、什么是 AOP 以及作用？</a></li>\n<li><a href=\"#2-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\">2、有哪些应用场景？</a></li>\n<li><a href=\"#3-%E5%88%87%E9%9D%A2-%E5%88%87%E7%82%B9-%E8%BF%9E%E6%8E%A5%E7%82%B9-%E9%80%9A%E7%9F%A5%E4%BB%A5%E5%8F%8A%E5%9B%9B%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB\">3、切面、切点、连接点、通知以及四者的关系？</a>\n<ul>\n<li><a href=\"#1%E8%BF%9E%E6%8E%A5%E7%82%B9-joinpoint\">1）连接点 (Joinpoint)</a>\n<ul>\n<li><a href=\"#%E6%A6%82%E5%BF%B5\">概念</a></li>\n<li><a href=\"#%E7%A4%BA%E4%BE%8B\">示例</a></li>\n</ul>\n</li>\n<li><a href=\"#2%E5%88%87%E7%82%B9-pointcut\">2）切点 (Pointcut)</a>\n<ul>\n<li><a href=\"#%E6%A6%82%E5%BF%B5-2\">概念</a></li>\n<li><a href=\"#%E7%A4%BA%E4%BE%8B-2\">示例</a></li>\n</ul>\n</li>\n<li><a href=\"#%E9%80%9A%E7%9F%A5-advice\">通知 (Advice)</a>\n<ul>\n<li><a href=\"#%E6%A6%82%E5%BF%B5-3\">概念</a></li>\n<li><a href=\"#%E7%A4%BA%E4%BE%8B-3\">示例</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%88%87%E9%9D%A2-aspect\">切面 (Aspect)</a>\n<ul>\n<li><a href=\"#%E6%A6%82%E5%BF%B5-4\">概念</a></li>\n<li><a href=\"#%E7%A4%BA%E4%BE%8B-4\">示例</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#4-aop-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\">4、AOP 的实现原理？</a>\n<ul>\n<li><a href=\"#jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\">JDK 动态代理</a></li>\n<li><a href=\"#cglib\">CGlib</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n(【Spring】spring 面试题汇总与详解)</p>\n<h2 id=\"spring的基本概念\"><a class=\"markdownIt-Anchor\" href=\"#spring的基本概念\">#</a> Spring 的基本概念</h2>\n<h3 id=\"1-spring-是什么\"><a class=\"markdownIt-Anchor\" href=\"#1-spring-是什么\">#</a> 1、Spring 是什么？</h3>\n<p>Spring 是一个轻量级 Java 开发框架，最早有 Rod Johnson 创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的<br>\n JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发 Java 应用程序提供全面的基础架构支持。Spring 负责基础架构，因此 Java<br>\n 开发者可以专注于应用程序的开发。Spring 最根本的使命是解决企业级应用开发的复杂性，即简化 Java 开发。</p>\n<h3 id=\"2-spring-带来哪些好处\"><a class=\"markdownIt-Anchor\" href=\"#2-spring-带来哪些好处\">#</a> 2、Spring 带来哪些好处？</h3>\n<ul>\n<li>\n<p>基于 POJO 的轻量级和最小侵入性编程。</p>\n</li>\n<li>\n<p>DI 机制将对象之间的依赖关系交由框架处理，减低组件间的耦合性。</p>\n</li>\n<li>\n<p>基于 AOP 技术支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。</p>\n</li>\n<li>\n<p>对于主流的应用框架提供了集成支持。</p>\n</li>\n</ul>\n<h3 id=\"3-说说-spring-有哪些模块\"><a class=\"markdownIt-Anchor\" href=\"#3-说说-spring-有哪些模块\">#</a> 3、说说 Spring 有哪些模块？</h3>\n<p><img data-src=\"26e3bd5f237ab05ae63f5a697805b33b.png\" alt=\"Spring模块\"></p>\n<p>上图对应的是 Spring 4.x 版本的架构图，主要包括以下八个模块：</p>\n<ul>\n<li>\n<p>Spring Core：基础，提供 IOC 和 DI 能力，可以说 Spring 其他所有的功能都依赖于该类库。</p>\n</li>\n<li>\n<p>Spring Aspects：该模块为集成 AspectJ 提供支持。</p>\n</li>\n<li>\n<p>Spring AOP：提供面向方面的编程实现。</p>\n</li>\n<li>\n<p>Spring JDBC：Java 数据库连接。</p>\n</li>\n<li>\n<p>Spring JMS：Java 消息服务。</p>\n</li>\n<li>\n<p>Spring ORM：用于支持 Hibernate、Mybatis 等 ORM 工具。</p>\n</li>\n<li>\n<p>Spring Web：为创建 Web 应用程序提供支持。</p>\n</li>\n<li>\n<p>Spring Test：提供了对 JUnit 和 TestNG 测试框架的支持。</p>\n</li>\n</ul>\n<h3 id=\"4-spring-中使用了哪些设计模式\"><a class=\"markdownIt-Anchor\" href=\"#4-spring-中使用了哪些设计模式\">#</a> 4、Spring 中使用了哪些设计模式？</h3>\n<ul>\n<li>\n<p>工厂模式 包括简单工厂和工厂方法，如通过 BeanFactory 或 ApplicationContext 创建 Bean 对象。</p>\n</li>\n<li>\n<p>单例模式：Spring 中的 Bean 对象默认就是单例模式。</p>\n</li>\n<li>\n<p>代理模式：Spring AOP 就是基于代理实现的，包括 JDK 动态代理和 CGlib 技术。</p>\n</li>\n<li>\n<p>模板方法模式：Spring 中 jdbcTemplate 等以 Template 结尾对数据库操作的类就使用到模板模式。</p>\n</li>\n<li>\n<p>观察者模式：Spring 事件驱动模型就是观察者模式很经典的应用。</p>\n</li>\n<li>\n<p>适配器模式：Spring MVC 中，DispatcherServlet 根据请求解析到对应的 Handler（也就是我们常说的 Controller）后，开始由<br>\n HandlerAdapter 适配器处理。</p>\n</li>\n<li>\n<p>装饰者模式：使用 DataSource 在不改动代码情况下切换数据源。</p>\n</li>\n<li>\n<p>策略模式：Spring 对资源的访问，如 Resource 接口。</p>\n</li>\n</ul>\n<h3 id=\"5-spring-中有哪些不同类型事件\"><a class=\"markdownIt-Anchor\" href=\"#5-spring-中有哪些不同类型事件\">#</a> 5、Spring 中有哪些不同类型事件？</h3>\n<p>Spring 提供了以下 5 种标准的事件：</p>\n<ul>\n<li>\n<p>上下文更新事件（ContextRefreshedEvent）：在调用 ConfigurableApplicationContext 接口中的 refresh () 方法时被触发。</p>\n</li>\n<li>\n<p>上下文开始事件（ContextStartedEvent）：当容器调用 ConfigurableApplicationContext 的 Start () 方法开始 / 重新开始容器时触发该事件。</p>\n</li>\n<li>\n<p>上下文停止事件（ContextStoppedEvent）：当容器调用 ConfigurableApplicationContext 的 Stop () 方法停止容器时触发该事件。</p>\n</li>\n<li>\n<p>上下文关闭事件（ContextClosedEvent）：当 ApplicationContext 被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。</p>\n</li>\n<li>\n<p>请求处理事件（RequestHandledEvent）：在 Web 应用中，当一个 http 请求（request）结束触发该事件。</p>\n</li>\n</ul>\n<p>至于如果监听这些事件：</p>\n<p>一个 Bean 实现了 ApplicationListener 接口，当一个 ApplicationEvent 被发布以后，Bean 会自动被通知。</p>\n<h2 id=\"spring-ioc\"><a class=\"markdownIt-Anchor\" href=\"#spring-ioc\">#</a> Spring IOC</h2>\n<h3 id=\"1-什么是-ioc\"><a class=\"markdownIt-Anchor\" href=\"#1-什么是-ioc\">#</a> 1、什么是 IOC？</h3>\n<p>IOC 是 Inversion of Control 的缩写，即控制反转。IOC 不是一项技术，而是一种设计思想。在 Java 开发中，Ioc 意味着你可以将设计好的对象交给<br>\n IOC 容器，完成初始化和管理，当你需要时由容器提供控制。</p>\n<p>Spring IOC 可谓是 Spring 的核心，对于 Spring 框架而言，所谓 IOC 就是由 Spring<br>\n 来负责控制对象的生命周期和对象间的关系。正这个控制过程中，需要动态的向某个对象提供它所需要的其他对象，这一点是通过<br>\n DI（Dependency Injection，依赖注入）来实现的。</p>\n<h3 id=\"2-ioc-的作用或好处\"><a class=\"markdownIt-Anchor\" href=\"#2-ioc-的作用或好处\">#</a> 2、IOC 的作用或好处？</h3>\n<p>实现对象间的解耦，同时降低应用开发的代码量和复杂度，使开发人员更专注业务。</p>\n<h3 id=\"3-ioc-的实现原里\"><a class=\"markdownIt-Anchor\" href=\"#3-ioc-的实现原里\">#</a> 3、IOC 的实现原里？</h3>\n<p>Spring 的 IOC 是基于工厂设计模式在加上反射实现。</p>\n<h3 id=\"4-spring-有哪些容器类\"><a class=\"markdownIt-Anchor\" href=\"#4-spring-有哪些容器类\">#</a> 4、Spring 有哪些容器类？</h3>\n<ul>\n<li>BeanFactory：这是一个最简单的容器，它主要的功能是为依赖注入（DI）提供支持。</li>\n<li>ApplicationContext：Application Context 是 Spring 中的高级容器。和 BeanFactory 类似，它可以加载和管理配置文件中定义的<br>\n Bean。 另外，它还增加了企业所需要的功能，比如，从属性文件中解析文本信息和将事件传递给所指定的监听器。</li>\n</ul>\n<p>一些常被使用的 ApplicationContext 实现类：</p>\n<ul>\n<li>FileSystemXmlApplicationContext：该容器从 XML 文件中加载已被定义的 Bean， 需要提供 XML 文件的完整路径。</li>\n<li>ClassPathXmlApplicationContext：同样从 XML 文件中加载已被定义的 Bean，但无需提供完整路径，因为它会从 CLASSPATH<br>\n 中搜索配置文件。</li>\n<li>WebXmlApplicationContext：该容器会在一个 Web 应用程序的范围内加载在 XML 文件中已被定义的 Bean。</li>\n</ul>\n<h3 id=\"5-beanfactory-和-applicationcontext-的区别\"><a class=\"markdownIt-Anchor\" href=\"#5-beanfactory-和-applicationcontext-的区别\">#</a> 5、BeanFactory 和 ApplicationContext 的区别？</h3>\n<p>二者都是 Spring 框架的两大核心接口，都可以当做 Spring 的容器。其中 ApplicationContext 是 BeanFactory 的子接口。</p>\n<ul>\n<li>\n<p>BeanFactory 是 Spring 里面最底层的接口，包含了各种 Bean 的定义，读取配置文档，管理 Bean 的加载、实例化，控制 Bean<br>\n 的生命周期，维护对象之间的依赖关系等功能。</p>\n</li>\n<li>\n<p>ApplicationContext 接口作为 BeanFactory 的派生，除了提供 BeanFactory 所具有的功能外，还提供了更完整的框架功能：</p>\n<ul>\n<li>继承 MessageSource，支持国际化。</li>\n<li>统一的资源文件访问方式。</li>\n<li>提供在监听器中注册 Bean 的事件。</li>\n<li>支持同时加载多个配置文件。</li>\n<li>载入多个（有继承关系）上下文，使得每一个上下文都专注于一个特定的层次，如应用的 Web 层。</li>\n</ul>\n</li>\n</ul>\n<p><strong>具体区别体现在以下三个方面：</strong></p>\n<ol>\n<li>\n<p>加载方式不同</p>\n<ul>\n<li>\n<p>BeanFactroy 采用的懒加载方式注入 Bean，即只有在使用到某个 Bean 时才对该 Bean 实例化。这样，我们就不能在程序启动时发现一些存在的<br>\n Spring 的配置问题。</p>\n</li>\n<li>\n<p>ApplicationContext 是在启动时一次性创建了所有的 Bean。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>创建方式不同</p>\n<ul>\n<li>BeanFactory 通常以编程的方式被创建。</li>\n<li>ApplicationContext 还能以声明的方式创建，如使用 ContextLoader。</li>\n</ul>\n</li>\n<li>\n<p>注册方式不同</p>\n<ul>\n<li>二者都支持 BeanPostProcessor、BeanFactoryPostProcessor 的使用，但 BeanFactory 需要手动注册，而 ApplicationContext<br>\n 则是自动注册。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"6-有哪些注入方式以及区别\"><a class=\"markdownIt-Anchor\" href=\"#6-有哪些注入方式以及区别\">#</a> 6、有哪些注入方式以及区别？</h3>\n<p>Spring 支持多种依赖注入的方式，包括但不限于：</p>\n<ul>\n<li>构造器注入（Constructor Injection）</li>\n<li>属性注入（Property or Setter Injection）</li>\n<li>字段注入（Field Injection）</li>\n</ul>\n<h4 id=\"构造器注入\"><a class=\"markdownIt-Anchor\" href=\"#构造器注入\">#</a> 构造器注入</h4>\n<p>构造器注入是指通过构造器参数来传递依赖项。这种方式可以确保依赖项在对象创建时就已经存在，有助于提高对象的不可变性和稳定性。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SomeService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SomeDependency dependency;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">SomeService</span><span class=\"params\">(SomeDependency dependency)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dependency = Objects.requireNonNull(dependency, <span class=\"string\">&quot;dependency must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 Spring Boot 中，可以使用 @Autowired 注解来标记构造器，表明这是一个需要依赖注入的构造器。如果类中有多个构造器，那么需要显式地使用 @Autowired 注解来标注哪个构造器是注入构造器。</p>\n<h4 id=\"属性注入\"><a class=\"markdownIt-Anchor\" href=\"#属性注入\">#</a> 属性注入</h4>\n<p>属性注入是通过对象的 setter 方法来注入依赖项。这是最常用的一种方式，因为它允许在对象创建后注入依赖项，增加了灵活性。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SomeService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> SomeDependency dependency;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setDependency</span><span class=\"params\">(SomeDependency dependency)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dependency = Objects.requireNonNull(dependency, <span class=\"string\">&quot;dependency must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"字段注入\"><a class=\"markdownIt-Anchor\" href=\"#字段注入\">#</a> 字段注入</h4>\n<p>字段注入是通过直接在类成员变量上使用 @Autowired 注解来注入依赖项。这种方式简洁，但是不如构造器注入或属性注入那样清晰地表达依赖关系。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SomeService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SomeDependency dependency;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"一些使用上的规约\"><a class=\"markdownIt-Anchor\" href=\"#一些使用上的规约\">#</a> 一些使用上的规约</h4>\n<p>尽管 Spring 支持上述所有依赖注入方式，但 Spring 团队推荐使用构造器注入，特别是对于必填依赖项。构造器注入有助于确保依赖项在对象创建时已经就位，并且有助于提高对象的不可变性。此外，构造器注入使得依赖关系更加明确，便于阅读和理解代码。<br>\n对于可选依赖项，可以使用属性注入或字段注入。然而，无论选择哪种方式，都应该遵循一些最佳实践：</p>\n<ul>\n<li>避免使用字段注入：除非你有非常明确的理由使用字段注入，否则应尽量避免使用。字段注入可能会导致依赖关系不明确，难以维护。</li>\n<li>使用构造器注入：对于必填依赖项，应该优先使用构造器注入。</li>\n<li>使用断言确保依赖项不为空：在构造器或 setter 方法中使用 Objects.requireNonNull () 或类似方法来确保依赖项不是空的。</li>\n<li>考虑使用 @Required 注解：虽然 Spring 现在主要使用 @Autowired，但在某些情况下，@Required 注解仍然有用，它可以用来标记 setter 方法，表示该方法必须被 Spring 的自动装配机制调用。</li>\n</ul>\n<p>这些依赖注入方式的选择取决于具体的应用场景和个人偏好。构造器注入通常被认为是更安全、更清晰的选择，而字段注入虽然简单，但在某些情况下可能会导致代码难以理解和维护。</p>\n<h2 id=\"spring-bean\"><a class=\"markdownIt-Anchor\" href=\"#spring-bean\">#</a> Spring Bean</h2>\n<h3 id=\"1-spring-bean-有哪些作用域\"><a class=\"markdownIt-Anchor\" href=\"#1-spring-bean-有哪些作用域\">#</a> 1、Spring Bean 有哪些作用域？</h3>\n<p>Spring 提供以下五种 Bean 的作用域：</p>\n<ul>\n<li>Singleton：单例模式，默认的作用域。在整个 Spring IoC 容器中，一个 Bean 定义对应一个实例。</li>\n<li>Prototype：原型模式。每次从容器中请求该 Bean 时都会创建一个新的实例。</li>\n<li>Request：对于每一个 HTTP 请求，都会创建一个新的 Bean 实例。这个作用域仅在 Web 环境中可用。</li>\n<li>Session：在一个 HTTP Session 中，一个 Bean 定义对应一个实例。这个作用域同样仅在 Web 环境中可用。</li>\n<li>Global-session：在一个全局的 HTTP Session 中，一个 Bean 定义对应一个实例。这个作用域主要用于 Portlet 环境。</li>\n</ul>\n<p>值的注意的是：使用 Prototype 作用域时需要慎重的思考，因为频繁创建和销毁 Bean 会带来很大的性能开销。</p>\n<h4 id=\"spring-bean-作用域配置方式\"><a class=\"markdownIt-Anchor\" href=\"#spring-bean-作用域配置方式\">#</a> Spring Bean 作用域配置方式</h4>\n<p>Spring 提供了三种配置 Bean 作用域的方式：</p>\n<ul>\n<li>\n<p>XML 配置</p>\n<p>使用基于 XML 的配置文件时，可以通过<bean>标签的 scope 属性来指定 Bean 的作用域。</p>\n<p>例如，配置一个原型模式的 Bean：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;exampleBean&quot;</span>class=<span class=\"string\">&quot;com.example.ExampleBean&quot;</span>scope=<span class=\"string\">&quot;prototype&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>Java 配置类配置</p>\n<p>使用 Java 配置类（通过 @Configuration 和 @Bean 注解）时，可以在 Bean 定义的方法上使用 @Scope 注解来指定作用域。</p>\n<p>例如，定义一个原型模式的 Bean：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ExampleBean <span class=\"title function_\">exampleBean</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExampleBean</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ExampleSingletonBean <span class=\"title function_\">exampleSingletonBean</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExampleSingletonBean</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>Java 注解配置</p>\n<p>使用注解的方式配置 Bean 的作用域也很常见，特别是在组件扫描（Component Scanning）的情况下。可以直接在类或者方法级别使用 @Scope 注解。</p>\n<p>例如将一个 Service 组件设置为原型模式：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExampleBean</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"2-spring-的单例是否线程安全\"><a class=\"markdownIt-Anchor\" href=\"#2-spring-的单例是否线程安全\">#</a> 2、Spring 的单例是否线程安全？</h3>\n<p>Spring 框架中的 Bean 默认是单例模式（Singleton），这意味着在整个应用上下文中只会存在一个 Bean 实例。</p>\n<p>对于无状态的服务层 Bean 来说，Spring 的单例模式本身是线程安全的，因为它们不保存任何实例变量的状态，所有操作都是基于输入参数进行计算。</p>\n<p>但是，如果单例 Bean 有实例变量，并且这些变量在多个线程间共享并且被修改，则可能会出现线程安全问题。</p>\n<p>如何保证线程安全</p>\n<ul>\n<li>避免使用可变对象：尽量使用不可变对象或者确保对象在初始化之后不再改变其状态。</li>\n<li>同步访问：如果必须维护一些可变状态，可以通过同步方法或同步代码块来保证同一时间只有一个线程可以访问和修改这些状态。</li>\n<li>使用并发工具类：利用 Java 并发库中的工具类如 ConcurrentHashMap 等来管理共享资源。</li>\n<li>将 Bean 设计为原型模式：如果每个请求确实都需要独立的数据结构或状态，可以将 Bean 的作用域设置为<br>\n prototype，这样每次请求都会创建一个新的 Bean 实例，这样可能导致性能降低，但可以避免线程安全问题。</li>\n<li>使用 ThreadLocal：对于某些特定场景，可以使用 ThreadLocal 来实现线程之间的隔离，确保每个线程都有自己的独立副本。</li>\n</ul>\n<h3 id=\"3-spring-bean-的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#3-spring-bean-的生命周期\">#</a> 3、Spring Bean 的生命周期？</h3>\n<p><img data-src=\"0cb7664ed7f4ec62270c528f298e03a3.png\" alt=\"Spring Bean 生命周期\"></p>\n<p>Bean 在 Spring 容器中从创建到销毁经历了若干阶段，每一阶段都可以进行个性化定制。</p>\n<ol>\n<li>\n<p>Spring 对 Bean 进行实例化；</p>\n</li>\n<li>\n<p>Spring 将配置和 Bean 的引用注入到对应的属性中；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 BeanNameAware 接口，Spring 将 Bean 的 ID 传递给 setBeanName () 方法；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 BeanFactoryAware 接口，Spring 将调用 setBeanFactory () 方法将 BeanFactory 容器实例传入；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 ApplicationContextAware 接口，Spring 将调用 setApplicationContext () 方法将 Bean 所在的应用上下文的引用传入进来；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 postProcessBeforeInitialization () 方法；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 InitializingBean 接口，Spring 将调用它们的 afterPropertiesSet () 方法。类似地，如果 Bean 使用 initmethod<br>\n 声明了初始化方法，该方法也会被调用；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 postProcessAfterInitialization () 方法；</p>\n</li>\n<li>\n<p>此时，Bean 已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 DisposableBean 接口，Spring 将调用它的 destroy () 接口方法。同样，如果使用 destroymethod<br>\n 声明了销毁方法，该方法也会被调用。</p>\n</li>\n</ol>\n<h2 id=\"spring-aop\"><a class=\"markdownIt-Anchor\" href=\"#spring-aop\">#</a> Spring AOP</h2>\n<h3 id=\"1-什么是-aop-以及作用\"><a class=\"markdownIt-Anchor\" href=\"#1-什么是-aop-以及作用\">#</a> 1、什么是 AOP 以及作用？</h3>\n<p>AOP（Aspect Oriented Programming）是面向切面编程，是 OOP 的一个补充，它允许我们通过引入新的模块，来分离业务逻辑与非业务逻辑，从而实现代码复用。</p>\n<p>传统的 OOP 开发中代码逻辑是至上而下的过程中会长生一些横切性问题（大量与业务无关的重复代码），这些横切问题会散落在代码的各个地方且难以维护。AOP<br>\n 的编程思想就是把业务逻辑和横切的问题进行分离，从而达到解耦的目的，使代码的重用性和开发效率高（目的是重用代码，把公共的代码抽取出来）。</p>\n<p>即 AOP 的作用是对业务逻辑的各个部分进行隔离，降低业务逻辑的耦合性，提高程序的可重用型和开发效率。</p>\n<h3 id=\"2-有哪些应用场景\"><a class=\"markdownIt-Anchor\" href=\"#2-有哪些应用场景\">#</a> 2、有哪些应用场景？</h3>\n<ul>\n<li>事务管理：在多个服务或方法调用中需要统一管理事务的开始、提交或回滚。Spring AOP 可以通过声明式事务管理（例如使用<br>\n @Transactional 注解）来简化事务的控制逻辑。</li>\n<li>日志记录：对系统中的关键方法或接口的日志记录，包括方法调用前后的日志打印，以及异常捕获时的日志记录。这可以通过定义一个切面，在方法执行前后插入日志记录的逻辑来实现。</li>\n<li>权限验证：在调用某些敏感操作之前，需要进行权限验证。通过 AOP 可以在方法调用前进行权限检查，从而确保只有授权用户才能访问特定功能。</li>\n<li>性能监控：监控应用程序中方法的执行时间和资源消耗情况，这对于性能瓶颈分析非常有用。可以定义一个切面来记录方法执行的开始时间和结束时间，并计算执行时间。</li>\n<li>缓存操作：对数据访问操作的结果进行缓存，以减少数据库访问次数，提高响应速度。使用 AOP<br>\n 可以在方法执行前检查缓存，如果缓存中有数据则直接返回，否则执行方法并将结果存入缓存。</li>\n<li>输入输出参数校验：在方法执行前对传入的参数进行校验，确保参数的有效性；在方法执行后对返回值进行校验，确保返回值的正确性。</li>\n<li>资源锁定：在多线程环境中，为了防止资源竞争，可以使用 AOP 来添加锁定逻辑，确保资源的一致性和完整性。</li>\n<li>自定义注解：定义自定义注解，并通过 AOP 处理这些注解，实现特定的行为，如日志记录、性能统计等。</li>\n</ul>\n<h3 id=\"3-切面-切点-连接点-通知以及四者的关系\"><a class=\"markdownIt-Anchor\" href=\"#3-切面-切点-连接点-通知以及四者的关系\">#</a> 3、切面、切点、连接点、通知以及四者的关系？</h3>\n<p>在 Spring AOP 中，切面（Aspect）、切点（Pointcut）、连接点（Joinpoint）和通知（Advice）是核心概念，它们共同协作来实现面向切面编程的功能。下面是这些概念之间的关系：</p>\n<h4 id=\"1连接点-joinpoint\"><a class=\"markdownIt-Anchor\" href=\"#1连接点-joinpoint\">#</a> 1）连接点 (Joinpoint)</h4>\n<h5 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h5>\n<p>连接点是指程序执行过程中的某个特定点，比如方法执行、字段访问等。</p>\n<h5 id=\"示例\"><a class=\"markdownIt-Anchor\" href=\"#示例\">#</a> 示例</h5>\n<p>在代码中，连接点的具体表现形式通常是方法的调用。当你定义了一个方法，并且这个方法被 Spring AOP 所管理，那么这个方法的执行就是一个连接点。例如：</p>\n<pre><code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SomeService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 业务逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>在这个例子中，doSomething () 方法的执行就是一个连接点。</p>\n<p>不是所有的连接点都可以被切面所使用，只有那些被切点表达式匹配上的连接点才是 AOP 能够织入的连接点。</p>\n<h4 id=\"2切点-pointcut\"><a class=\"markdownIt-Anchor\" href=\"#2切点-pointcut\">#</a> 2）切点 (Pointcut)</h4>\n<h5 id=\"概念-2\"><a class=\"markdownIt-Anchor\" href=\"#概念-2\">#</a> 概念</h5>\n<p>切点（Pointcut）是 AOP 中的一个重要概念，它定义了哪些连接点（Joinpoint）会被切面（Aspect）所关注，确定哪些方法或类应该被切面所拦截。<br>\n一个切点可以匹配多个连接点，而一个连接点也可以被多个切点所匹配。</p>\n<p>在 Spring AOP 中，切点的表现形式通常包括以下几个方面：</p>\n<ul>\n<li>方法执行切点：最常用的形式，用于指定特定的方法执行。</li>\n<li>类执行切点：用于指定特定类的所有方法执行。</li>\n<li>异常切点：用于指定方法抛出特定异常时的切点。</li>\n<li>构造函数切点：用于指定构造函数的执行。</li>\n<li>字段访问切点：用于指定字段的访问或修改。</li>\n</ul>\n<p>Spring AOP 支持使用 AspectJ 的切点表达式语法来定义切点。基本语法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execution(modifier-pattern?ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)<span class=\"keyword\">throws</span>-pattern?)</span><br></pre></td></tr></table></figure>\n<p>其中：</p>\n<ul>\n<li>modifiers-pattern：修饰符模式（可选）。</li>\n<li>ret-type-pattern：返回类型模式。</li>\n<li>declaring-type-pattern：声明类型模式（可选）。</li>\n<li>name-pattern：方法名称模式。</li>\n<li>param-pattern：参数模式。</li>\n<li>throws-pattern：抛出异常模式（可选）。</li>\n</ul>\n<h5 id=\"示例-2\"><a class=\"markdownIt-Anchor\" href=\"#示例-2\">#</a> 示例</h5>\n<p>假设我们有一个 UserService 类，包含一个 login 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">login</span><span class=\"params\">(String username, String password)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 登录逻辑</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以通过注解表达式来定义切点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;execution(* com.example.service.UserService.login(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logBefore</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Logging before login&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">userServiceMethods</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;userServiceMethods()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logBeforeAllUserServiceMethods</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Logging before all UserService methods&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中：</p>\n<ul>\n<li><code>execution(* com.example.service.UserService.login(..))</code> ：表示拦截 UserService 类中的 login 方法。</li>\n<li><code>execution(* com.example.service.UserService.*(..))</code> ：表示拦截 UserService 类中的所有方法。</li>\n</ul>\n<h4 id=\"通知-advice\"><a class=\"markdownIt-Anchor\" href=\"#通知-advice\">#</a> 通知 (Advice)</h4>\n<h5 id=\"概念-3\"><a class=\"markdownIt-Anchor\" href=\"#概念-3\">#</a> 概念</h5>\n<p>通知（Advice）是 Spring AOP<br>\n 中的一个核心概念，它定义了在切点（Pointcut）匹配的连接点（Joinpoint）上执行的动作。通知可以分为多种类型，每种类型在不同的时机执行不同的逻辑。下面详细介绍通知的类型及其具体表现形式。</p>\n<p>Spring AOP 支持以下几种主要的通知类型：</p>\n<ol>\n<li>前置通知（Before Advice）：在方法执行前执行（关键字: Before）。</li>\n<li>后置通知（After Returning Advice）：仅当方法正常返回时执行（关键字: AfterReturning）。</li>\n<li>最终通知（After Advice）：无论方法是否抛出异常，都会在方法执行后执行（关键字: After）。</li>\n<li>异常通知（After Throwing Advice）：仅当方法抛出异常时执行（关键字: AfterThrowing）。</li>\n<li>环绕通知（Around Advice）：环绕通知，在方法执行前后都可执行，并且可以决定是否继续执行方法（关键字: Around）。</li>\n</ol>\n<p>不同类型的 AOP 通知适用于不同的场景：</p>\n<ol>\n<li>前置通知：适用于日志记录、权限验证、资源准备等。</li>\n<li>后置通知：适用于日志记录、资源释放、结果处理等。</li>\n<li>最终通知：适用于资源释放、日志记录等。</li>\n<li>异常通知：适用于异常记录、错误处理、资源释放等。</li>\n<li>环绕通知：适用于性能监控、事务管理、权限验证、资源控制等。</li>\n</ol>\n<h5 id=\"示例-3\"><a class=\"markdownIt-Anchor\" href=\"#示例-3\">#</a> 示例</h5>\n<ol>\n<li>\n<p>前置通知（Before Advice）</p>\n<p>前置通知是在方法执行前执行的通知。它可以用来进行一些准备工作，如日志记录、权限验证等。<br>\n示例代码：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logBefore</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Executing: &quot;</span> + method.getName());</span><br><span class=\"line\">        Object[] args = joinPoint.getArgs();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object arg : args) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Argument: &quot;</span> + arg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，logBefore 方法是一个前置通知，它会在 UserService 类中的所有方法执行前被调用。</p>\n</li>\n<li>\n<p>后置通知（After Returning Advice）</p>\n<p>后置通知是在方法正常返回后执行的通知。它可以用来进行一些清理工作，如关闭资源、记录日志等。<br>\n示例代码：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning(pointcut = &quot;execution(* com.example.service.UserService.*(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logAfterReturning</span><span class=\"params\">(JoinPoint joinPoint, Object result)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; returned: &quot;</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，logAfterReturning 方法是一个后置通知，它会在 UserService 类中的所有方法正常返回后被调用，并接收方法的返回值。</p>\n</li>\n<li>\n<p>最终通知（After Advice）</p>\n<p>最终通知是在方法执行后（无论方法是否正常返回或抛出异常）都会执行的通知。它可以用来进行一些必要的清理工作，如关闭资源等。<br>\n示例代码：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@After(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logFinally</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; has been executed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，logFinally 方法是一个最终通知，它会在 UserService 类中的所有方法执行后被调用。</p>\n</li>\n<li>\n<p>异常通知（After Throwing Advice）</p>\n<p>异常通知是在方法抛出异常后执行的通知。它可以用来记录异常信息、发送报警等。<br>\n示例代码：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterThrowing(pointcut = &quot;execution(* com.example.service.UserService.*(..))&quot;, throwing = &quot;ex&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logAfterThrowing</span><span class=\"params\">(JoinPoint joinPoint, Exception ex)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; threw exception: &quot;</span> + ex.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，logAfterThrowing 方法是一个异常通知，它会在 UserService 类中的所有方法抛出异常后被调用，并接收异常对象。</p>\n</li>\n<li>\n<p>环绕通知（Around Advice）</p>\n<p>环绕通知是在方法执行前后都可执行的通知。它可以完全控制方法的执行流程，包括是否继续执行方法、如何执行等。<br>\n示例代码：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">logAround</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before executing: &quot;</span> + method.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> joinPoint.proceed(); <span class=\"comment\">// 继续执行方法</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;After executing: &quot;</span> + method.getName());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; threw exception: &quot;</span> + e.getMessage());</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，logAround 方法是一个环绕通知，它会在 UserService 类中的所有方法执行前后都被调用，并且可以控制方法的执行流程。</p>\n</li>\n</ol>\n<h4 id=\"切面-aspect\"><a class=\"markdownIt-Anchor\" href=\"#切面-aspect\">#</a> 切面 (Aspect)</h4>\n<h5 id=\"概念-4\"><a class=\"markdownIt-Anchor\" href=\"#概念-4\">#</a> 概念</h5>\n<p>切面（Aspect）是 Spring AOP 中的核心概念之一，它将横切关注点（Cross-cutting<br>\nConcern）模块化为独立的组件。切面包含了多个通知（Advice）和切点（Pointcut），并通过这些通知和切点来实现特定的功能。下面详细介绍切面的概念、组成以及具体的应用场景。</p>\n<p>切面通常由以下几个部分组成：</p>\n<ul>\n<li>切点（Pointcut）：定义了哪些连接点（Joinpoint）会被切面所关注。</li>\n<li>通知（Advice）：定义了在切点匹配的连接点上执行的动作。</li>\n<li>引入（Introduction）：允许向现有类添加新的方法或属性。</li>\n<li>织入（Weaving）：将切面与应用程序的其他部分结合起来的过程。</li>\n</ul>\n<h5 id=\"示例-4\"><a class=\"markdownIt-Anchor\" href=\"#示例-4\">#</a> 示例</h5>\n<p>在 Spring AOP 中，切面通常通过 @Aspect 注解来定义，并且可以包含多个切点和通知。<br>\n示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 前置通知</span></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logBefore</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Executing: &quot;</span> + method.getName());</span><br><span class=\"line\">        Object[] args = joinPoint.getArgs();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object arg : args) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Argument: &quot;</span> + arg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 后置通知</span></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning(pointcut = &quot;execution(* com.example.service.UserService.*(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logAfterReturning</span><span class=\"params\">(JoinPoint joinPoint, Object result)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; returned: &quot;</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 最终通知</span></span><br><span class=\"line\">    <span class=\"meta\">@After(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logFinally</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; has been executed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 异常通知</span></span><br><span class=\"line\">    <span class=\"meta\">@AfterThrowing(pointcut = &quot;execution(* com.example.service.UserService.*(..))&quot;, throwing = &quot;ex&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logAfterThrowing</span><span class=\"params\">(JoinPoint joinPoint, Exception ex)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; threw exception: &quot;</span> + ex.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 环绕通知</span></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">logAround</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before executing: &quot;</span> + method.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> joinPoint.proceed(); <span class=\"comment\">// 继续执行方法</span></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">endTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;After executing: &quot;</span> + method.getName() + <span class=\"string\">&quot; (Time: &quot;</span> + (endTime - startTime) + <span class=\"string\">&quot;ms)&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; threw exception: &quot;</span> + e.getMessage());</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-aop-的实现原理\"><a class=\"markdownIt-Anchor\" href=\"#4-aop-的实现原理\">#</a> 4、AOP 的实现原理？</h3>\n<p>AOP 是基于代理实现的，Spring 提供了 JDK 动态代理和 CGlib 两种方式来生成代理对象。</p>\n<p>Spring AOP 会根据目标对象是否实现了接口来决定使用哪种代理策略：<br>\n如果目标对象实现了接口，则使用 JDK 动态代理。<br>\n如果目标对象没有实现任何接口，则使用 CGLIB 代理。<br>\n这种策略使得 Spring AOP 能够灵活地适应不同的情况，并且保证了代理对象能够正确地执行增强逻辑。</p>\n<p>以下介绍两种不同的代理策略原理。</p>\n<h4 id=\"jdk-动态代理\"><a class=\"markdownIt-Anchor\" href=\"#jdk-动态代理\">#</a> JDK 动态代理</h4>\n<p>JDK 动态代理是基于 Java 语言反射机制实现的。它要求被代理的对象必须实现一个或多个接口。Spring AOP 会利用这个特性，当目标对象实现了接口时，就会使用<br>\n JDK 动态代理来创建代理对象。</p>\n<p>工作原理：</p>\n<ul>\n<li>当一个对象实现了某个接口时，Spring 会通过 java.lang.reflect.Proxy 类来创建一个代理对象。</li>\n<li>这个代理对象实现了相同的接口，并且其内部持有对原始对象的引用。</li>\n<li>代理对象通过 InvocationHandler 接口来处理方法调用，这样可以在方法调用前后添加额外的行为。</li>\n</ul>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设有一个接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Doing something...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建代理对象</span></span><br><span class=\"line\">    <span class=\"type\">Service</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceImpl</span>();</span><br><span class=\"line\">    <span class=\"type\">Service</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (Service) Proxy.newProxyInstance(</span><br><span class=\"line\">            Service.class.getClassLoader(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[]&#123;Service.class&#125;,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;Before method call&quot;</span>);</span><br><span class=\"line\">                    <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(service, args);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;After method call&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">proxy.doSomething();</span><br></pre></td></tr></table></figure>\n<h4 id=\"cglib\"><a class=\"markdownIt-Anchor\" href=\"#cglib\">#</a> CGlib</h4>\n<p>CGLIB（Code Generation Library）是一个高性能的字节码生成库，它可以在运行时动态生成一个目标类的子类。这意味着即使目标对象没有实现任何接口，也可以通过<br>\n CGLIB 来创建代理对象。<br>\n工作原理：</p>\n<ul>\n<li>CGLIB 通过继承目标类来创建一个新的子类对象。</li>\n<li>在这个子类中，对父类的方法进行增强，也就是在方法调用前后添加额外的行为。</li>\n<li>这种方式不需要目标类实现任何接口，因此更加灵活。</li>\n</ul>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设有一个未实现接口的类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Doing something...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建代理对象</span></span><br><span class=\"line\">    <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\">enhancer.setSuperclass(Service.class);</span><br><span class=\"line\">        enhancer.setCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">MethodInterceptor</span>()&#123;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object obj,Method method,Object[]args,MethodProxy proxy)</span><span class=\"keyword\">throws</span> Throwable&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before method call&quot;</span>);</span><br><span class=\"line\">        Object result=proxy.invokeSuper(obj,args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After method call&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Service service=(Service)enhancer.create();</span><br><span class=\"line\">        service.doSomething();</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "后端",
                "java",
                "spring"
            ]
        }
    ]
}