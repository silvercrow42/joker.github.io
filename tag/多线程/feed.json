{
    "version": "https://jsonfeed.org/version/1",
    "title": "Joker • All posts by \"多线程\" tag",
    "description": "",
    "home_page_url": "https://silvercrow42.github.io/joker.github.io",
    "items": [
        {
            "id": "https://silvercrow42.github.io/joker.github.io/2024/11/01/%E3%80%90java%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/",
            "url": "https://silvercrow42.github.io/joker.github.io/2024/11/01/%E3%80%90java%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/",
            "title": "【java】多线程详解",
            "date_published": "2024-11-01T07:56:08.000Z",
            "content_html": "<h2 id=\"并发基础\"><a class=\"markdownIt-Anchor\" href=\"#并发基础\">#</a> 并发基础</h2>\n<h3 id=\"什么是并发\"><a class=\"markdownIt-Anchor\" href=\"#什么是并发\">#</a> 什么是并发</h3>\n<p>并发是指多个任务在同一时间段内交错执行的能力。虽然这些任务可能不是真正的同时执行，但它们在时间上被快速交替调度，从而给人一种同时进行的错觉。并发可以显著提高程序的效率和响应性。以下是并发的几个关键点：</p>\n<ul>\n<li>任务切换：操作系统通过快速切换任务来实现并发，每个任务在一段时间内获得 CPU 时间片。</li>\n<li>资源共享：并发任务通常共享某些资源，如内存、文件句柄等，因此需要适当的同步机制来避免冲突。</li>\n<li>提高资源利用率：通过并发，可以更充分地利用系统资源，尤其是多核处理器。</li>\n</ul>\n<h3 id=\"并发的使用场景\"><a class=\"markdownIt-Anchor\" href=\"#并发的使用场景\">#</a> 并发的使用场景</h3>\n<ol>\n<li>Web 服务器\n<ul>\n<li>处理多个请求：Web 服务器需要同时处理来自多个客户端的请求。通过并发，服务器可以创建多个线程或进程来处理这些请求，提高响应速度和吞吐量。</li>\n<li>异步 IO 操作：处理网络请求和文件读写等 IO 操作时，使用异步 IO 可以避免阻塞主线程，提高整体性能。</li>\n</ul>\n</li>\n<li>数据库系统\n<ul>\n<li>并行查询：数据库系统可以并行执行多个查询，特别是在处理大数据集时，可以显著提高查询效率。</li>\n<li>事务管理：并发控制机制（如锁和事务隔离级别）确保多个事务可以安全地并行执行，避免数据不一致。</li>\n</ul>\n</li>\n<li>图形用户界面（GUI）应用程序\n<ul>\n<li>响应用户输入：主线程负责处理用户输入和更新界面，后台线程处理耗时任务（如数据加载、计算等），保持界面的响应性。</li>\n<li>动画和渲染：并行处理动画和渲染任务，提高视觉效果的流畅度。</li>\n</ul>\n</li>\n<li>大数据分析\n<ul>\n<li>并行数据处理：使用 MapReduce 等并行计算框架，将大数据集分成多个部分，由多个节点并行处理，加快数据处理速度。</li>\n<li>分布式存储：并行读取和写入分布式存储系统中的数据，提高数据访问效率。</li>\n</ul>\n</li>\n<li>游戏开发\n<ul>\n<li>物理模拟：并行处理复杂的物理模拟计算，提高游戏的真实感和性能。</li>\n<li>AI 计算：并行处理游戏中的 AI 逻辑，使 NPC（非玩家角色）的行为更加智能和多样化。</li>\n</ul>\n</li>\n<li>文件和数据处理\n<ul>\n<li>并行文件处理：并行读取和处理多个文件，加快数据处理速度。</li>\n<li>批处理任务：并行执行批处理任务，如日志分析、数据转换等。</li>\n</ul>\n</li>\n<li>网络爬虫\n<ul>\n<li>并行抓取：同时从多个网站抓取数据，提高抓取速度。</li>\n<li>数据处理：并行处理抓取到的数据，加快数据清洗和分析过程。</li>\n</ul>\n</li>\n<li>机器学习和深度学习\n<ul>\n<li>模型训练：并行训练模型，特别是在使用 GPU 加速时，可以显著缩短训练时间。</li>\n<li>数据预处理：并行处理大量训练数据，提高数据准备效率。</li>\n</ul>\n</li>\n<li>实时系统\n<ul>\n<li>实时数据处理：并行处理实时数据流，如传感器数据、股票市场数据等，确保低延迟和高吞吐量。</li>\n<li>任务调度：并行调度和执行多个实时任务，确保系统的响应性和可靠性。</li>\n</ul>\n</li>\n<li>云计算和虚拟化\n<ul>\n<li>资源分配：并行管理和分配计算资源，提高资源利用率。</li>\n<li>虚拟机管理：并行处理虚拟机的创建、启动和停止等操作，提高管理效率。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"高并发情况下可能出现的问题\"><a class=\"markdownIt-Anchor\" href=\"#高并发情况下可能出现的问题\">#</a> 高并发情况下可能出现的问题</h3>\n<p>在并发场景下，可能会面临多种问题，这些问题如果不妥善处理，会影响系统的稳定性和性能。以下是一些常见的并发问题及其简要说明：</p>\n<ol>\n<li>死锁（Deadlock）\n<ul>\n<li>定义：多个线程或进程互相等待对方持有的资源，导致所有线程或进程都无法继续执行。</li>\n<li>原因：资源分配不当、循环等待、缺乏超时机制等。</li>\n<li>示例：线程 A 持有资源 X 并请求资源 Y，而线程 B 持有资源 Y 并请求资源 X。</li>\n</ul>\n</li>\n<li>竞态条件（Race Condition）\n<ul>\n<li>定义：多个线程或进程以不可预测的顺序访问和修改共享资源，导致不一致的状态。</li>\n<li>原因：缺乏适当的同步机制、线程间通信不正确等。</li>\n<li>示例：多个线程同时读取和修改同一个变量，导致最终结果不确定。</li>\n</ul>\n</li>\n<li>上下文切换开销（Context Switching Overhead）\n<ul>\n<li>定义：操作系统在不同线程或进程之间切换时，需要保存和恢复当前线程的上下文，这会消耗时间和资源。</li>\n<li>原因：频繁的上下文切换。</li>\n<li>示例：在高并发环境下，频繁的线程切换会导致 CPU 利用率下降。</li>\n</ul>\n</li>\n<li>资源竞争（Resource Contention）\n<ul>\n<li>定义：多个线程或进程竞争有限的资源，导致性能下降或资源浪费。</li>\n<li>原因：资源不足、同步机制不当等。</li>\n<li>示例：多个线程同时访问同一个文件或数据库连接池。</li>\n</ul>\n</li>\n<li>饥饿（Starvation）\n<ul>\n<li>定义：某个线程或进程由于长时间无法获得所需的资源而无法继续执行。</li>\n<li>原因：优先级调度不当、资源分配不公平等。</li>\n<li>示例：低优先级线程长时间无法获得 CPU 时间。</li>\n</ul>\n</li>\n<li>活锁（Livelock）\n<ul>\n<li>定义：多个线程或进程不断重复相同的操作，试图避免冲突，但最终无法取得进展。</li>\n<li>原因：缺乏有效的冲突解决机制。</li>\n<li>示例：两个线程在尝试获取同一个资源时，不断退让，导致两者都无法成功获取资源。</li>\n</ul>\n</li>\n<li>内存泄漏（Memory Leak）\n<ul>\n<li>定义：程序在运行过程中未能释放不再使用的内存，导致内存占用逐渐增加。</li>\n<li>原因：未正确管理内存分配和释放、对象引用未解除等。</li>\n<li>示例：线程创建的对象未被及时回收，导致内存占用不断增加。</li>\n</ul>\n</li>\n<li>不一致状态（Inconsistent State）\n<ul>\n<li>定义：由于并发操作导致数据状态不一致，影响程序的正确性。</li>\n<li>原因：缺乏原子操作、同步机制不当等。</li>\n<li>示例：多个线程同时修改同一个数据结构，导致数据结构损坏。</li>\n</ul>\n</li>\n<li>性能瓶颈（Performance Bottleneck）\n<ul>\n<li>定义：系统在高并发情况下，由于某个组件的性能限制，导致整体性能下降。</li>\n<li>原因：单点故障、资源限制、设计不合理等。</li>\n<li>示例：数据库连接池大小限制导致请求排队，影响整体性能。</li>\n</ul>\n</li>\n</ol>\n<p>解决方法</p>\n<ul>\n<li>同步机制：使用锁（如互斥锁、信号量）、条件变量等同步机制来协调线程之间的访问。</li>\n<li>原子操作：使用原子操作来确保操作的不可分割性。</li>\n<li>线程池：使用线程池来管理线程，减少上下文切换开销。</li>\n<li>资源管理：合理分配和管理资源，避免资源竞争和饥饿。</li>\n<li>超时机制：设置超时机制，防止死锁和活锁。</li>\n<li>内存管理：及时释放不再使用的内存，避免内存泄漏。</li>\n<li>性能优化：识别和优化性能瓶颈，提高系统整体性能。</li>\n</ul>\n<h3 id=\"happen-before-原则\"><a class=\"markdownIt-Anchor\" href=\"#happen-before-原则\">#</a> Happen-before 原则</h3>\n<p>Happen-before 原则是 Java 内存模型（Java Memory Model, JMM）中的一个重要概念，用于保证多线程环境下的内存可见性和操作顺序。Happen-before<br>\n 原则定义了两个操作之间的顺序关系，确保一个操作的结果对另一个操作是可见的。</p>\n<p>如果一个操作 A happen-before 另一个操作 B，那么 A 的结果对 B 是可见的，且 A 的动作在 B 之前完成。</p>\n<p>Happen-before 原则包括以下几个具体规则：</p>\n<ul>\n<li>程序顺序规则（Program Order Rule）\n<ul>\n<li>在一个线程中，按照程序代码的顺序，前面的操作 happen-before 后面的操作。</li>\n<li>示例：在同一个线程中，x = 1; y = x + 1;，x = 1 happen-before y = x + 1。</li>\n</ul>\n</li>\n<li>监视器锁规则（Monitor Lock Rule）\n<ul>\n<li>对同一个锁的解锁操作 happen-before 后面对该锁的加锁操作。</li>\n<li>示例：线程 A 解锁一个对象的监视器，然后线程 B 加锁同一个对象的监视器，A 的解锁操作 happen-before B 的加锁操作。</li>\n</ul>\n</li>\n<li>volatile 变量规则（Volatile Variable Rule）\n<ul>\n<li>对一个 volatile 变量的写操作 happen-before 后面对该变量的读操作。</li>\n<li>示例：线程 A 写入一个 volatile 变量 x，然后线程 B 读取同一个 volatile 变量 x，A 的写操作 happen-before B 的读操作。</li>\n</ul>\n</li>\n<li>线程启动规则（Thread Start Rule）\n<ul>\n<li>线程的启动操作 happen-before 线程中的任何操作。</li>\n<li>示例：线程 A 启动线程 B，A 的启动操作 happen-before B 中的任何操作。</li>\n</ul>\n</li>\n<li>线程终止规则（Thread Termination Rule）\n<ul>\n<li>线程中的任何操作 happen-before 线程的终止检测。</li>\n<li>示例：线程 A 终止，线程 B 检测到 A 已经终止，A 中的任何操作 happen-before B 检测到 A 的终止。</li>\n</ul>\n</li>\n<li>中断规则（Interrupt Rule）\n<ul>\n<li>对线程的中断操作 happen-before 被中断线程检测到中断。</li>\n<li>示例：线程 A 中断线程 B，A 的中断操作 happen-before B 检测到中断。</li>\n</ul>\n</li>\n<li>传递性（Transitivity）\n<ul>\n<li>如果 A happen-before B，且 B happen-before C，则 A happen-before C。</li>\n<li>示例：A happen-before B，B happen-before C，因此 A happen-before C。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"java-中的线程\"><a class=\"markdownIt-Anchor\" href=\"#java-中的线程\">#</a> Java 中的线程</h2>\n<h3 id=\"线程的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#线程的生命周期\">#</a> 线程的生命周期</h3>\n<p>Java 线程有六种状态，这些状态反映了线程在其生命周期中的不同阶段。</p>\n<ol>\n<li>\n<p>新建（New）：线程被创建但尚未启动。</p>\n<p>前置条件：</p>\n<ul>\n<li>当调用 Thread 对象的 start 方法时，线程从新建状态切换到就绪状态。</li>\n</ul>\n</li>\n<li>\n<p>就绪（Runnable）线程已经准备好运行，等待 CPU 分配时间片。</p>\n<p>前置条件：</p>\n<ul>\n<li>从新建状态调用 start 方法后进入就绪状态。</li>\n<li>从阻塞、等待或定时等待状态返回后进入就绪状态。</li>\n<li>从运行状态因时间片用完或更高优先级线程抢占 CPU 而进入就绪状态。</li>\n</ul>\n</li>\n<li>\n<p>运行（Running）：Java 线程中将就绪（ready）和运行中（running）两种状态笼统的称为 “运行”，以下为两种状态的区分情况：</p>\n<ul>\n<li>\n<p>就绪（Ready）：线程已经准备好运行，等待 CPU 分配时间片。</p>\n<p>前置条件：</p>\n<ul>\n<li>从新建状态调用 start 方法后进入就绪状态。</li>\n<li>从阻塞、等待或定时等待状态返回后进入就绪状态。</li>\n<li>从运行状态因时间片用完或更高优先级线程抢占 CPU 而进入就绪状态。</li>\n</ul>\n</li>\n<li>\n<p>运行（Running）：线程正在 CPU 上执行。</p>\n<p>前置条件：</p>\n<ul>\n<li>从就绪状态获得 CPU 时间片后进入运行状态。</li>\n<li>从运行状态因时间片用完或更高优先级线程抢占 CPU 而进入就绪状态。</li>\n<li>从运行状态因调用 wait、join、sleep 等方法进入等待或定时等待状态。</li>\n<li>从运行状态因调用 Object 的 wait 方法进入等待状态。</li>\n<li>从运行状态因调用 Thread 的 join 方法进入等待状态。</li>\n<li>从运行状态因调用 Thread 的 sleep 方法进入定时等待状态。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>阻塞（Blocked）：线程被阻塞，等待获取监视器锁。</p>\n<p>前置条件：</p>\n<ul>\n<li>从运行状态因尝试获取已被其他线程持有的锁而进入阻塞状态。</li>\n<li>从阻塞状态因获得锁后进入就绪状态。</li>\n</ul>\n</li>\n<li>\n<p>等待（Waiting）：线程无限期等待其他线程执行特定操作。</p>\n<p>前置条件：</p>\n<ul>\n<li>从运行状态因调用 Object 的 wait 方法进入等待状态。</li>\n<li>从运行状态因调用 Thread 的 join 方法进入等待状态。</li>\n<li>从运行状态因调用 LockSupport 的 park 方法进入等待状态。</li>\n<li>从等待状态因调用 Object 的 notify 或 notifyAll 方法进入就绪状态。</li>\n<li>从等待状态因调用 Thread 的 interrupt 方法进入就绪状态。</li>\n</ul>\n</li>\n<li>\n<p>定时等待（Timed Waiting）：线程在指定时间内等待其他线程执行特定操作。</p>\n<p>前置条件：</p>\n<ul>\n<li>从运行状态因调用 Thread 的 sleep 方法进入定时等待状态。</li>\n<li>从运行状态因调用 Object 的 wait 方法并指定超时时间进入定时等待状态。</li>\n<li>从运行状态因调用 Thread 的 join 方法并指定超时时间进入定时等待状态。</li>\n<li>从运行状态因调用 LockSupport 的 parkNanos 或 parkUntil 方法进入定时等待状态。</li>\n<li>从定时等待状态因超时或调用 Thread 的 interrupt 方法进入就绪状态。</li>\n</ul>\n</li>\n<li>\n<p>终止（Terminated）：线程已经退出，不再活动。</p>\n<p>前置条件：</p>\n<ul>\n<li>从运行状态因 run 方法执行完毕或抛出未捕获的异常而进入终止状态。</li>\n<li>从等待或定时等待状态因调用 Thread 的 interrupt 方法并抛出 InterruptedException 而进入终止状态。</li>\n</ul>\n</li>\n</ol>\n",
            "tags": [
                "后端",
                "java",
                "多线程"
            ]
        }
    ]
}