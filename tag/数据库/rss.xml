<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Joker • Posts by &#34;数据库&#34; tag</title>
        <link>https://silvercrow42.github.io/joker.github.io</link>
        <description></description>
        <language>zh-CN,en,default</language>
        <pubDate>Wed, 09 Oct 2024 09:58:28 +0800</pubDate>
        <lastBuildDate>Wed, 09 Oct 2024 09:58:28 +0800</lastBuildDate>
        <category>后端</category>
        <category>操作系统</category>
        <category>Linux</category>
        <category>数据库</category>
        <category>关系型数据库</category>
        <category>Mysql</category>
        <category>MQ</category>
        <category>RocketMQ</category>
        <category>java</category>
        <category>spring</category>
        <category>Zookeeper</category>
        <category>Redis</category>
        <category>Redisson</category>
        <category>分布式锁</category>
        <category>NoSQL</category>
        <category>缓存</category>
        <item>
            <guid isPermalink="true">https://silvercrow42.github.io/joker.github.io/2024/10/09/%E3%80%90Mysql%E3%80%91Mysql%E8%AF%A6%E8%A7%A3/</guid>
            <title>【Mysql】Mysql详解</title>
            <link>https://silvercrow42.github.io/joker.github.io/2024/10/09/%E3%80%90Mysql%E3%80%91Mysql%E8%AF%A6%E8%A7%A3/</link>
            <category>后端</category>
            <category>数据库</category>
            <category>关系型数据库</category>
            <category>Mysql</category>
            <pubDate>Wed, 09 Oct 2024 09:58:28 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;什么是mysql&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#什么是mysql&#34;&gt;#&lt;/a&gt; 什么是 Mysql&lt;/h2&gt;
&lt;p&gt;MySQL 是一个广泛使用的开源关系型数据库管理系统（RDBMS），由 MySQL AB 公司开发，后来被 Sun Microsystems 收购，最终成为 Oracle&lt;br&gt;
 公司的一部分。MySQL 被广泛应用于 Web 应用、企业应用和个人项目中。以下是关于 MySQL 的一些详细介绍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高性能：MySQL 提供了高效的查询处理机制，能够处理大量的并发请求。&lt;/li&gt;
&lt;li&gt;易于使用：安装简单，配置容易，支持多种操作系统（如 Windows、Linux 和 macOS）。&lt;/li&gt;
&lt;li&gt;安全性：提供了丰富的安全特性，包括用户认证、权限管理、数据加密等。&lt;/li&gt;
&lt;li&gt;扩展性：支持多种存储引擎（如 InnoDB、MyISAM 等），可以根据不同的应用场景选择合适的存储引擎。&lt;/li&gt;
&lt;li&gt;开源免费：作为开源软件，MySQL 可以免费使用，适用于各种规模的应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库结构&lt;br&gt;
 MySQL 使用标准的关系模型，包括表、视图、索引等基本组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表：存储数据的基本单位，由行和列组成。&lt;/li&gt;
&lt;li&gt;视图：虚拟表，基于一个或多个表的查询结果。&lt;/li&gt;
&lt;li&gt;索引：用于加快数据检索速度的特殊数据结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储引擎&lt;br&gt;
 MySQL 支持多种存储引擎，其中最常用的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB：支持事务处理、外键约束和行级锁定。&lt;/li&gt;
&lt;li&gt;MyISAM：不支持事务处理，但性能较高，适合读取密集型应用。&lt;/li&gt;
&lt;li&gt;Memory：将数据存储在内存中，提供极高的读写速度，但不适合持久化存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mysql的数据类型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mysql的数据类型&#34;&gt;#&lt;/a&gt; Mysql 的数据类型&lt;/h2&gt;
&lt;h3 id=&#34;数值类型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#数值类型&#34;&gt;#&lt;/a&gt; 数值类型&lt;/h3&gt;
&lt;p&gt;MySQL 支持所有标准 SQL 数值数据类型。&lt;/p&gt;
&lt;p&gt;这些类型包括严格数值数据类型 (INTEGER、SMALLINT、DECIMAL 和 NUMERIC)，以及近似数值数据类型 (FLOAT、REAL 和 DOUBLE PRECISION)。&lt;/p&gt;
&lt;p&gt;关键字 INT 是 INTEGER 的同义词，关键字 DEC 是 DECIMAL 的同义词。&lt;/p&gt;
&lt;p&gt;BIT 数据类型保存位字段值，并且支持 MyISAM、MEMORY、InnoDB 和 BDB 表。&lt;/p&gt;
&lt;p&gt;作为 SQL 标准的扩展，MySQL 也支持整数类型 TINYINT、MEDIUMINT 和 BIGINT。下面的表显示了需要的每个整数类型的存储和范围。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;大小 (bytes)&lt;/th&gt;
&lt;th&gt;范围（有符号）&lt;/th&gt;
&lt;th&gt;范围（无符号）&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;TINYINT&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;(-128，127)&lt;/td&gt;
&lt;td&gt;(0，255)&lt;/td&gt;
&lt;td&gt;小整数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SMALLINT&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;(-32 768，32 767)&lt;/td&gt;
&lt;td&gt;(0，65 535)&lt;/td&gt;
&lt;td&gt;大整数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEDIUMINT&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;(-8 388 608，8 388 607)&lt;/td&gt;
&lt;td&gt;(0，16 777 215)&lt;/td&gt;
&lt;td&gt;大整数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT 或 INTEGER&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;(-2 147 483 648，2 147 483 647)&lt;/td&gt;
&lt;td&gt;(0，4 294 967 295)&lt;/td&gt;
&lt;td&gt;大整数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BIGINT&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)&lt;/td&gt;
&lt;td&gt;(0，18 446 744 073 709 551 615)&lt;/td&gt;
&lt;td&gt;极大整数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FLOAT&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)&lt;/td&gt;
&lt;td&gt;0，(1.175 494 351 E-38，3.402 823 466 E+38)&lt;/td&gt;
&lt;td&gt;单精度浮点数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DOUBLE&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)&lt;/td&gt;
&lt;td&gt;0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)&lt;/td&gt;
&lt;td&gt;双精度浮点数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DECIMAL&lt;/td&gt;
&lt;td&gt;对 DECIMAL (M,D) ，如果 M&amp;gt;D，为 M+2 否则为 D+2&lt;/td&gt;
&lt;td&gt;依赖于 M 和 D 的值&lt;/td&gt;
&lt;td&gt;依赖于 M 和 D 的值&lt;/td&gt;
&lt;td&gt;小数值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;日期和时间类型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#日期和时间类型&#34;&gt;#&lt;/a&gt; 日期和时间类型&lt;/h3&gt;
&lt;p&gt;表示时间值的日期和时间类型为 DATETIME、DATE、TIMESTAMP、TIME 和 YEAR。&lt;/p&gt;
&lt;p&gt;每个时间类型有一个有效值范围和一个 &amp;quot;零&amp;quot; 值，当指定不合法的 MySQL 不能表示的值时使用 &amp;quot;零&amp;quot; 值。&lt;/p&gt;
&lt;p&gt;TIMESTAMP 类型有专有的自动更新特性，将在后面描述。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;大小 (bytes)&lt;/th&gt;
&lt;th&gt;范围&lt;/th&gt;
&lt;th&gt;格式&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DATE&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1000-01-01/9999-12-31&lt;/td&gt;
&lt;td&gt;YYYY-MM-DD&lt;/td&gt;
&lt;td&gt;日期值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIME&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;‘-838:59:59’/‘838:59:59’&lt;/td&gt;
&lt;td&gt;HH:MM:SS&lt;/td&gt;
&lt;td&gt;时间值或持续时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;YEAR&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1901/2155&lt;/td&gt;
&lt;td&gt;YYYY&lt;/td&gt;
&lt;td&gt;年份值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DATETIME&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’&lt;/td&gt;
&lt;td&gt;YYYY-MM-DD hh:mm:ss&lt;/td&gt;
&lt;td&gt;混合日期和时间值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIMESTAMP&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC 结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038 年 1 月 19 日 凌晨 03:14:07&lt;/td&gt;
&lt;td&gt;YYYY-MM-DD hh:mm:ss&lt;/td&gt;
&lt;td&gt;混合日期和时间值，时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;字符串类型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#字符串类型&#34;&gt;#&lt;/a&gt; 字符串类型&lt;/h3&gt;
&lt;p&gt;字符串类型指 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;大小 (bytes)&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CHAR&lt;/td&gt;
&lt;td&gt;0-255&lt;/td&gt;
&lt;td&gt;定长字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VARCHAR&lt;/td&gt;
&lt;td&gt;0-65535&lt;/td&gt;
&lt;td&gt;变长字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TINYBLOB&lt;/td&gt;
&lt;td&gt;0-255&lt;/td&gt;
&lt;td&gt;不超过 255 个字符的二进制字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TINYTEXT&lt;/td&gt;
&lt;td&gt;0-255&lt;/td&gt;
&lt;td&gt;短文本字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BLOB&lt;/td&gt;
&lt;td&gt;0-65 535&lt;/td&gt;
&lt;td&gt;二进制形式的长文本数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TEXT&lt;/td&gt;
&lt;td&gt;0-65 535&lt;/td&gt;
&lt;td&gt;长文本数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEDIUMBLOB&lt;/td&gt;
&lt;td&gt;0-16 777 215&lt;/td&gt;
&lt;td&gt;二进制形式的中等长度文本数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEDIUMTEXT&lt;/td&gt;
&lt;td&gt;0-16 777 215&lt;/td&gt;
&lt;td&gt;中等长度文本数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LONGBLOB&lt;/td&gt;
&lt;td&gt;0-4 294 967 295&lt;/td&gt;
&lt;td&gt;二进制形式的极大文本数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LONGTEXT&lt;/td&gt;
&lt;td&gt;0-4 294 967 295&lt;/td&gt;
&lt;td&gt;极大文本数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注意：char (n) 和 varchar (n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR (30) 就可以存储 30 个字符。&lt;/p&gt;
&lt;p&gt;CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。&lt;/p&gt;
&lt;p&gt;BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。&lt;/p&gt;
&lt;p&gt;BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。&lt;/p&gt;
&lt;p&gt;有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。&lt;/p&gt;
&lt;h3 id=&#34;枚举与集合类型enumeration-and-set-types&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#枚举与集合类型enumeration-and-set-types&#34;&gt;#&lt;/a&gt; 枚举与集合类型（Enumeration and Set Types）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ENUM: 枚举类型，用于存储单一值，可以选择一个预定义的集合。&lt;/li&gt;
&lt;li&gt;SET: 集合类型，用于存储多个值，可以选择多个预定义的集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;空间数据类型spatial-data-types&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#空间数据类型spatial-data-types&#34;&gt;#&lt;/a&gt; 空间数据类型（Spatial Data Types）&lt;/h3&gt;
&lt;p&gt;GEOMETRY, POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION:&lt;br&gt;
 用于存储空间数据（地理信息、几何图形等）。&lt;/p&gt;
&lt;h2 id=&#34;索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#索引&#34;&gt;#&lt;/a&gt; 索引&lt;/h2&gt;
&lt;p&gt;MySQL 中的索引是一种数据结构，它可以帮助数据库系统更快地检索数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从物理结构上可以分为聚集索引和非聚集索引两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;聚簇索引指索引的键值的逻辑顺序与表中相应行的物理顺序一致，即每张表只能有一个聚簇索引，也就是我们常说的主键索引；
&lt;ul&gt;
&lt;li&gt;默认情况下，InnoDB 表的主键就是聚簇索引。&lt;/li&gt;
&lt;li&gt;如果没有显式定义主键，则 InnoDB 会自动创建一个隐藏的主键作为聚簇索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非聚簇索引的逻辑顺序则与数据行的物理顺序不一致。
&lt;ul&gt;
&lt;li&gt;非聚簇索引（也称为二级索引）只存储索引键值和指向实际数据行的指针。&lt;/li&gt;
&lt;li&gt;当通过非聚簇索引查找数据时，首先找到索引条目，然后通过指针访问实际的数据行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从应用上可以划分为一下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通索引：MySQL 中的基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了提高查询效率。通过 ALTER&lt;br&gt;
TABLE&lt;br&gt;
table_name ADD INDEX index_name (column) 创建；&lt;/li&gt;
&lt;li&gt;唯一索引：索引列中的值必须是唯一的，但是允许为空值。通过 ALTER TABLE table_name ADD UNIQUE index_name (column) 创建；&lt;/li&gt;
&lt;li&gt;主键索引：特殊的唯一索引，也成聚簇索引，不允许有空值，并由数据库帮我们自动创建；&lt;/li&gt;
&lt;li&gt;组合索引：组合表中多个字段创建的索引，遵守最左前缀匹配规则；&lt;/li&gt;
&lt;li&gt;全文索引：只有在 MyISAM 引擎上才能使用，同时只支持 CHAR、VARCHAR、TEXT 类型字段上使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hash-索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#hash-索引&#34;&gt;#&lt;/a&gt; Hash 索引&lt;/h3&gt;
&lt;p&gt;在 MySQL 中，哈希索引（Hash Index）是一种特殊的索引类型，主要用于快速查找数据。哈希索引利用哈希算法将索引键值映射到一个固定大小的哈希表中，从而实现快速定位数据。&lt;/p&gt;
&lt;p&gt;哈希索引的基本实现原理如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;哈希算法：
&lt;ul&gt;
&lt;li&gt;哈希算法将索引键值转换为一个固定长度的哈希值。&lt;/li&gt;
&lt;li&gt;这个哈希值被用作索引表中的索引项。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;哈希表：
&lt;ul&gt;
&lt;li&gt;哈希表是一个数组，每个数组元素对应一个哈希值。&lt;/li&gt;
&lt;li&gt;查找时，通过计算键值的哈希值可以直接定位到对应的数组元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;MySQL 中各引擎的的哈希索引实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;InnoDB 存储引擎&lt;br&gt;
在 InnoDB 存储引擎中，哈希索引主要用于内部结构，例如辅助索引和临时表。InnoDB 并不支持用户级别的哈希索引。&lt;/li&gt;
&lt;li&gt;MyISAM 存储引擎&lt;br&gt;
 MyISAM 存储引擎支持用户级别的哈希索引，主要用于全表扫描和快速查找。&lt;/li&gt;
&lt;li&gt;MEMORY 存储引擎&lt;br&gt;
 MEMORY 存储引擎（以前称为 HEAP 存储引擎）支持哈希索引，主要用于临时表和内存中的数据存储。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;哈希索引的优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速查找：
&lt;ul&gt;
&lt;li&gt;哈希索引可以实现常数时间复杂度 O (1) 的查找，非常快。&lt;/li&gt;
&lt;li&gt;特别适用于简单的等值查询（例如 WHERE name = ‘Alice’）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存效率：
&lt;ul&gt;
&lt;li&gt;哈希索引通常用于内存中的数据存储，适合临时表和小数据量的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;哈希索引的缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不支持范围查询：哈希索引不支持范围查询（例如 WHERE name BETWEEN ‘A’ AND ‘Z’）。&lt;/li&gt;
&lt;li&gt;不支持排序：哈希索引无法用于排序操作，因为哈希值之间没有顺序关系。&lt;/li&gt;
&lt;li&gt;哈希冲突：哈希冲突可能导致性能下降，特别是在高并发场景下。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;btree索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#btree索引&#34;&gt;#&lt;/a&gt; B+Tree 索引&lt;/h3&gt;
&lt;p&gt;在 MySQL 中，B+Tree 索引是一种常用的索引类型，它被广泛地用于各种存储引擎，如 MyISAM、InnoDB 和 Memory。B+Tree&lt;br&gt;
 索引提供了高效的范围查询、前缀查询和排序功能。&lt;br&gt;
B+Tree 索引是在 B-Tree 基础上，通过引入指针来优化存储和检索数据。在介绍 B+Tree 索引之前，先介绍下 B-Tree 索引。&lt;/p&gt;
&lt;h4 id=&#34;b-tree索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#b-tree索引&#34;&gt;#&lt;/a&gt; B-Tree 索引&lt;/h4&gt;
&lt;p&gt;B-Tree 结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B-Tree（平衡二叉查找树）是一种自平衡的树形数据结构。&lt;/li&gt;
&lt;li&gt;每个节点最多包含 M 个子节点，其中 M 是一个固定的参数，称为阶数。&lt;/li&gt;
&lt;li&gt;每个节点包含 M-1 个键值和相应的指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;img data-src=&#34;/joker.github.io/2024/10/09/%E3%80%90Mysql%E3%80%91Mysql%E8%AF%A6%E8%A7%A3/v2-9a8025fcd8ffdb921a6a124713fa0f7f_r.png&#34; class=&#34;&#34; title=&#34;v2-9a8025fcd8ffdb921a6a124713fa0f7f_r.png&#34;&gt;
&lt;p&gt;节点结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根节点：树的顶部节点。&lt;/li&gt;
&lt;li&gt;内部节点：包含多个键值和指针，用于指向子节点。&lt;/li&gt;
&lt;li&gt;叶子节点：包含实际的数据行或数据行的指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;键值顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B-Tree 中的键值是按顺序存储的，每个节点内的键值也是有序的。&lt;/li&gt;
&lt;li&gt;所有的叶子节点都位于同一层，并且通过双向链表连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;B-Tree 索引的特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高效查询：
&lt;ul&gt;
&lt;li&gt;B-Tree 索引支持范围查询、前缀查询和等值查询。&lt;/li&gt;
&lt;li&gt;查询时可以通过键值快速定位到相应的叶子节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自平衡：
&lt;ul&gt;
&lt;li&gt;B-Tree 在插入和删除操作时能够保持自平衡，确保树的高度较小，从而提高查询效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;支持范围查询：
&lt;ul&gt;
&lt;li&gt;通过遍历叶子节点实现范围查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;支持前缀查询：
&lt;ul&gt;
&lt;li&gt;通过遍历叶子节点实现前缀查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;btree-索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#btree-索引&#34;&gt;#&lt;/a&gt; B+Tree 索引&lt;/h4&gt;
&lt;p&gt;B+Tree 结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B+Tree 是一种改进的 B-Tree，特别适用于文件系统和数据库索引。&lt;/li&gt;
&lt;li&gt;每个节点最多包含 M 个子节点，其中 M 是一个固定的参数，称为阶数。&lt;/li&gt;
&lt;li&gt;所有数据行都存储在叶子节点中。&lt;/li&gt;
&lt;/ul&gt;
&lt;img data-src=&#34;/joker.github.io/2024/10/09/%E3%80%90Mysql%E3%80%91Mysql%E8%AF%A6%E8%A7%A3/v2-9a8025fcd8ffdb921a6a124713fa0f7f_r.png&#34; class=&#34;&#34; title=&#34;v2-9a8025fcd8ffdb921a6a124713fa0f7f_r.png&#34;&gt;
&lt;p&gt;节点结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根节点：树的顶部节点。&lt;/li&gt;
&lt;li&gt;内部节点：仅包含键值和指针，用于指向子节点。&lt;/li&gt;
&lt;li&gt;叶子节点：包含实际的数据行，并通过双向链表连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;键值顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B+Tree 中的键值是按顺序存储的，所有叶子节点位于同一层，并通过双向链表连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;B+Tree 索引的特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高效查询：
&lt;ul&gt;
&lt;li&gt;支持等值查询、范围查询和前缀查询。&lt;/li&gt;
&lt;li&gt;查询时可以通过键值快速定位到相应的叶子节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自平衡：
&lt;ul&gt;
&lt;li&gt;在插入和删除操作时能够保持自平衡，确保树的高度较小，从而提高查询效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;支持范围查询：
&lt;ul&gt;
&lt;li&gt;通过遍历叶子节点实现范围查询，所有叶子节点通过双向链表连接，便于遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;支持前缀查询：
&lt;ul&gt;
&lt;li&gt;通过遍历叶子节点实现前缀查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;支持排序：
&lt;ul&gt;
&lt;li&gt;所有数据行都存储在叶子节点中，通过双向链表连接，便于排序和遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;btree索引和b-tree索引的区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#btree索引和b-tree索引的区别&#34;&gt;#&lt;/a&gt; B+Tree 索引和 B-Tree 索引的区别&lt;/h4&gt;
&lt;p&gt;数据存储位置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B-Tree：数据可以存储在内部节点和叶子节点中。&lt;/li&gt;
&lt;li&gt;B+Tree：所有数据只存储在叶子节点中，内部节点只包含键值和指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查询性能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B-Tree：查询可能需要访问多个层级的节点，直到找到叶子节点。&lt;/li&gt;
&lt;li&gt;B+Tree：查询总是需要访问到叶子节点，但叶子节点通过双向链表连接，便于遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;范围查询：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;B-Tree：范围查询需要遍历多个层级的节点，直到找到所有符合条件的叶子节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B+Tree：范围查询只需要遍历叶子节点即可，因为所有叶子节点通过双向链表连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据冗余：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B-Tree：数据存储在内部节点和叶子节点中，可能存在数据冗余。&lt;/li&gt;
&lt;li&gt;B+Tree：数据只存储在叶子节点中，避免了数据冗余。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;磁盘访问优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B-Tree：每次查询可能需要多次磁盘访问。&lt;/li&gt;
&lt;li&gt;B+Tree：查询总是需要访问到叶子节点，但叶子节点通过双向链表连接，减少了磁盘访问次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;为什么要使用btree索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#为什么要使用btree索引&#34;&gt;#&lt;/a&gt; 为什么要使用 B+Tree 索引？&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据存储在叶子节点&lt;/p&gt;
&lt;p&gt;在 B+Tree 中，所有数据行都存储在叶子节点中，而内部节点只包含键值和指针。这种结构有以下几个优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少磁盘 I/O 次数：在磁盘访问中，每次读取或写入一个块都需要一次 I/O 操作。由于所有数据都存储在叶子节点中，查询时只需要访问叶子节点，减少了磁盘&lt;br&gt;
 I/O 次数。&lt;/li&gt;
&lt;li&gt;数据一致性：所有数据存储在叶子节点中，避免了数据冗余，确保数据的一致性和完整性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高效的范围查询&lt;/p&gt;
&lt;p&gt;B+Tree 的叶子节点通过双向链表连接，这使得范围查询更加高效：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;范围查询：当执行范围查询（如 WHERE id BETWEEN 10 AND 20）时，只需要遍历叶子节点即可。由于叶子节点通过双向链表连接，可以快速遍历整个范围。&lt;/li&gt;
&lt;li&gt;排序查询：当执行排序查询（如 ORDER BY id ASC）时，同样可以通过遍历叶子节点来实现排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自平衡性&lt;/p&gt;
&lt;p&gt;B+Tree 具有自平衡性，能够在插入和删除操作时保持树的高度较小，从而提高查询效率：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自平衡：在插入或删除操作时，B+Tree 会自动调整节点，确保树的高度保持较小，从而提高查询效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更好的磁盘访问优化&lt;/p&gt;
&lt;p&gt;B+Tree 在磁盘访问方面具有更好的优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少磁盘 I/O：由于所有数据都存储在叶子节点中，查询时只需要访问叶子节点，减少了磁盘 I/O 次数。&lt;/li&gt;
&lt;li&gt;高效的数据块利用：B+Tree 的节点可以容纳更多的键值和指针，提高了数据块的利用率，减少了磁盘空间浪费。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持联合索引&lt;/p&gt;
&lt;p&gt;B+Tree 支持联合索引（复合索引），可以同时使用多个字段进行索引：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;联合索引：例如，可以创建一个联合索引 (col1, col2)，在查询时可以使用这两个字段进行快速定位。&lt;/li&gt;
&lt;li&gt;多列排序：联合索引还可以用于多列排序，提高排序查询的效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更好的并发控制&lt;/p&gt;
&lt;p&gt;B+Tree 在并发控制方面也表现出色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;锁定机制：在并发操作中，B+Tree 可以通过锁定机制来保证数据的一致性和完整性。&lt;/li&gt;
&lt;li&gt;事务处理：B+Tree 在事务处理中能够更好地支持并发操作，提高事务处理的效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更好的扩展性&lt;/p&gt;
&lt;p&gt;B+Tree 在扩展性方面具有优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;易于扩展：由于所有数据都存储在叶子节点中，B+Tree 在扩展时更容易进行数据分布和分区。&lt;/li&gt;
&lt;li&gt;分布式系统：在分布式数据库系统中，B+Tree 更容易实现数据的水平分割和分布。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存和缓存友好&lt;/p&gt;
&lt;p&gt;B+Tree 的结构更适合内存和缓存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存利用：B+Tree 的内部节点只包含键值和指针，占用较少的内存空间，适合内存缓存。&lt;/li&gt;
&lt;li&gt;缓存命中率：由于所有数据都在叶子节点中，缓存命中率更高，减少了从磁盘读取数据的次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;btree-索引的自平衡&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#btree-索引的自平衡&#34;&gt;#&lt;/a&gt; B+Tree 索引的自平衡&lt;/h4&gt;
&lt;p&gt;B+Tree 的自平衡主要通过以下几种方式实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;节点分裂&lt;/p&gt;
&lt;p&gt;当向 B+Tree 中插入一个新的键值时，如果当前节点已满，则需要将该节点分裂成两个节点。节点分裂的具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定分裂点：
&lt;ul&gt;
&lt;li&gt;如果当前节点已满（即包含 M-1 个键值），则需要将其分裂成两个节点。&lt;/li&gt;
&lt;li&gt;将中间的键值作为新的中间节点的键值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;创建新节点：
&lt;ul&gt;
&lt;li&gt;创建一个新的节点，将原节点的一部分键值移动到新节点中。&lt;/li&gt;
&lt;li&gt;新节点包含大约一半的键值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;更新父节点：
&lt;ul&gt;
&lt;li&gt;在父节点中插入一个新的键值，指向新创建的节点。&lt;/li&gt;
&lt;li&gt;如果父节点已满，则继续向上分裂。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;p&gt;假设 B+Tree 的阶数为 M=3，每个节点最多包含 2 个键值。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始状态： &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;[&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;插入键值 4：
&lt;ol&gt;
&lt;li&gt;当前节点已满，需要分裂。&lt;/li&gt;
&lt;li&gt;将中间的键值 2 提升到父节点，创建两个新节点 [1] 和 [3, 4]。&lt;/li&gt;
&lt;li&gt;更新父节点：&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt; [&lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; / \&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;[&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;] [&lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;4&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;插入键值 5：
&lt;ol&gt;
&lt;li&gt;当前节点已满，需要分裂。&lt;/li&gt;
&lt;li&gt;将中间的键值 4 提升到父节点，创建两个新节点 [3] 和 [5]。&lt;/li&gt;
&lt;li&gt;更新父节点：&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;  [&lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;4&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  / \ / \&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;[&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;] [&lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;] [&lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;节点合并&lt;/p&gt;
&lt;p&gt;当从 B+Tree 中删除一个键值时，如果某个节点的键值数量少于最小键值数量（即小于 M/2），则需要进行节点合并。节点合并的具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定合并条件：
&lt;ul&gt;
&lt;li&gt;如果当前节点的键值数量少于 M/2，则需要与相邻的兄弟节点合并。&lt;/li&gt;
&lt;li&gt;选择一个相邻的兄弟节点，将其中一个键值移动到当前节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;合并节点：
&lt;ul&gt;
&lt;li&gt;将相邻节点的一个键值移动到当前节点，使当前节点的键值数量达到 M/2。&lt;/li&gt;
&lt;li&gt;更新父节点中的键值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;更新父节点：
&lt;ul&gt;
&lt;li&gt;如果父节点的键值数量少于 M/2，则继续向上合并。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;p&gt;假设 B+Tree 的阶数为 M=3，每个节点最多包含 2 个键值。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始状态：&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;  [&lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;4&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  / \ / \&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;[&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;] [&lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;] [&lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;删除键值 4：
&lt;ol&gt;
&lt;li&gt;删除键值 4 后，节点 [3] 的键值数量少于 M/2，需要与相邻节点合并。&lt;/li&gt;
&lt;li&gt;将 [2] 和 [3] 合并，更新父节点：&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;  [&lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  / \&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;[&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;] [&lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;什么情况下无法使用索引&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#什么情况下无法使用索引&#34;&gt;#&lt;/a&gt; 什么情况下无法使用索引&lt;/h3&gt;
&lt;p&gt;在 MySQL 中，索引可以显著提高查询性能，但并不是所有的查询都能有效地利用索引。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 LIKE 操作符时
&lt;ul&gt;
&lt;li&gt;情况描述：当 LIKE 操作符的模式以通配符（如 %）开头时，索引通常无法被有效利用。例如，SELECT * FROM table WHERE column&lt;br&gt;
LIKE ‘%abc%’。&lt;/li&gt;
&lt;li&gt;原因：索引通常是按照键值顺序存储的，而以通配符开头的模式会导致 MySQL 无法直接定位到特定的位置，因此需要进行全表扫描。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用函数或表达式
&lt;ul&gt;
&lt;li&gt;情况描述：当查询条件中包含函数或表达式时，索引通常无法被利用。例如，SELECT * FROM table WHERE UPPER (column) = ‘ABC’ 或&lt;br&gt;
 SELECT * FROM table WHERE column + 1 = 5。&lt;/li&gt;
&lt;li&gt;原因：函数或表达式改变了索引键值的形式，导致索引无法直接匹配。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 OR 连接多个条件
&lt;ul&gt;
&lt;li&gt;情况描述：当查询条件中包含多个 OR 逻辑时，索引可能无法被有效利用。例如，SELECT * FROM table WHERE column1 = ‘A’ OR&lt;br&gt;
column2 = ‘B’。&lt;/li&gt;
&lt;li&gt;原因：多个 OR 条件可能导致 MySQL 需要扫描多个索引或进行全表扫描。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 NOT IN 或 NOT EXISTS
&lt;ul&gt;
&lt;li&gt;情况描述：当查询条件中包含 NOT IN 或 NOT EXISTS 时，索引可能无法被有效利用。例如，SELECT * FROM table WHERE column NOT&lt;br&gt;
IN (‘A’, ‘B’, ‘C’) 或 SELECT * FROM table WHERE NOT EXISTS (SELECT 1&lt;br&gt;
FROM other_table WHERE other_table.id = &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3RhYmxlLmlk&#34;&gt;table.id&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;原因：NOT IN 和 NOT EXISTS 可能导致 MySQL 需要进行多次查找或全表扫描。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 IS NULL 或 IS NOT NULL
&lt;ul&gt;
&lt;li&gt;情况描述：当查询条件中包含 IS NULL 或 IS NOT NULL 时，索引可能无法被有效利用。例如，SELECT * FROM table WHERE column&lt;br&gt;
IS NULL 或 SELECT * FROM table WHERE column IS NOT NULL。&lt;/li&gt;
&lt;li&gt;原因：索引通常不包含 NULL 值，因此在这种情况下索引无法直接定位到特定的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 IN 语句且参数较多
&lt;ul&gt;
&lt;li&gt;情况描述：当查询条件中包含 IN 语句且参数较多时，索引可能无法被有效利用。例如，SELECT * FROM table WHERE column IN (’&lt;br&gt;
A’, ‘B’, ‘C’, …, ‘Z’)。&lt;/li&gt;
&lt;li&gt;原因：大量的 IN 参数可能导致 MySQL 需要进行多次查找或全表扫描。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 ORDER BY 或 GROUP BY 未覆盖索引
&lt;ul&gt;
&lt;li&gt;情况描述：当查询条件中包含 ORDER BY 或 GROUP BY 但未覆盖索引时，索引可能无法被有效利用。例如，SELECT * FROM table&lt;br&gt;
ORDER BY column1, column2。&lt;/li&gt;
&lt;li&gt;原因：如果索引没有包含所有排序或分组的列，MySQL 可能需要额外的排序操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 LIMIT 但未指定排序
&lt;ul&gt;
&lt;li&gt;情况描述：当查询条件中包含 LIMIT 但未指定排序时，索引可能无法被有效利用。例如，SELECT * FROM table LIMIT 10。&lt;/li&gt;
&lt;li&gt;原因：如果没有指定排序，MySQL 可能需要全表扫描来获取前几条记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 JOIN 但未指定合适的索引
&lt;ul&gt;
&lt;li&gt;情况描述：当查询条件中包含 JOIN 但未指定合适的索引时，索引可能无法被有效利用。例如，SELECT * FROM table1 JOIN table2&lt;br&gt;
ON &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3RhYmxlMS5pZA==&#34;&gt;table1.id&lt;/span&gt; = &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3RhYmxlMi5pZA==&#34;&gt;table2.id&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;原因：如果没有合适的索引，MySQL 可能需要进行全表扫描或多次查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 BETWEEN 但未覆盖索引
&lt;ul&gt;
&lt;li&gt;情况描述：当查询条件中包含 BETWEEN 但未覆盖索引时，索引可能无法被有效利用。例如，SELECT * FROM table WHERE column&lt;br&gt;
BETWEEN ‘A’ AND ‘Z’。&lt;/li&gt;
&lt;li&gt;原因：如果索引没有包含所有查询条件的列，MySQL 可能需要额外的查找操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;最左匹配原则&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#最左匹配原则&#34;&gt;#&lt;/a&gt; 最左匹配原则&lt;/h3&gt;
&lt;p&gt;最左匹配原则是指在复合索引中，查询条件必须从索引的最左边开始匹配，才能有效地利用索引。具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复合索引：由多个列组成的索引。&lt;/li&gt;
&lt;li&gt;最左匹配：查询条件必须从索引的第一个列开始，依次向右匹配。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例说明&lt;/p&gt;
&lt;p&gt;假设有一个复合索引 (col1, col2, col3)，那么查询条件必须从 col1 开始，然后依次向右匹配 col2 和 col3。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有效的查询条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SELECT * FROM table WHERE col1 = ‘value1’&lt;/li&gt;
&lt;li&gt;SELECT * FROM table WHERE col1 = ‘value1’ AND col2 = ‘value2’&lt;/li&gt;
&lt;li&gt;SELECT * FROM table WHERE col2 = ‘value2’ AND col1 = ‘value1’&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些查询条件都能够有效地利用索引 (col1, col2, col3)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无效的查询条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SELECT * FROM table WHERE col2 = ‘value2’&lt;/li&gt;
&lt;li&gt;SELECT * FROM table WHERE col2 = ‘value2’ AND col3 = ‘value3’&lt;/li&gt;
&lt;li&gt;SELECT * FROM table WHERE col3 = ‘value3’&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些查询条件无法有效地利用索引 (col1, col2, col3)，因为它们没有从索引的最左边开始匹配。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最左匹配原则的例外情况&lt;/p&gt;
&lt;p&gt;尽管最左匹配原则是一个基本规则，但在某些情况下，MySQL 仍可以部分地利用索引：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 OR 但条件相同&lt;br&gt;
有效示例： &lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;table&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; col1 &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;value1&amp;#x27;&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;OR&lt;/span&gt; col1 &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;value2&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
这种查询条件虽然使用了 OR，但条件相同，可以从索引的最左边开始匹配，可以有效地利用索引 (col1, col2, col3)。&lt;/li&gt;
&lt;li&gt;使用 IN 语句&lt;br&gt;
有效示例： &lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;table&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; col1 &lt;span class=&#34;keyword&#34;&gt;IN&lt;/span&gt; (&lt;span class=&#34;string&#34;&gt;&amp;#x27;value1&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;value2&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
这种查询条件虽然使用了 IN 语句，但可以从索引的最左边开始匹配，可以有效地利用索引 (col1, col2, col3)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最左匹配原则的优化建议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合理设计索引：根据查询需求设计合理的复合索引，确保查询条件能够从索引的最左边开始匹配。&lt;/li&gt;
&lt;li&gt;避免使用函数或表达式：查询条件中尽量避免使用函数或表达式，因为它们可能会导致索引失效。&lt;/li&gt;
&lt;li&gt;使用 EXPLAIN 查看执行计划：使用 EXPLAIN 命令查看查询的执行计划，检查是否有效地利用了索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;事务&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#事务&#34;&gt;#&lt;/a&gt; 事务&lt;/h2&gt;
&lt;p&gt;事务可以理解为一组相关操作的集合，这些操作作为一个整体执行。事务的主要目的是确保数据的一致性和完整性，即使在出现故障的情况下也能保证数据的正确性。&lt;/p&gt;
&lt;p&gt;事务通常具备四个主要特性，称为 ACID 特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性（Atomicity）：事务中的所有操作要么全部成功，要么全部失败。如果事务中的任何一部分失败，则整个事务都会回滚，恢复到事务开始之前的状态。&lt;/li&gt;
&lt;li&gt;一致性（Consistency）：事务执行后，数据库必须处于一致性的状态。这意味着事务执行前后，数据库的状态必须满足预定的约束和业务规则。&lt;/li&gt;
&lt;li&gt;隔离性（Isolation）：事务之间相互独立，一个事务的操作不会影响其他事务的结果。每个事务看起来像是在单独的系统中执行一样。&lt;/li&gt;
&lt;li&gt;持久性（Durability）：一旦事务提交（commit），其结果就会永久保存在数据库中，即使系统发生故障也不会丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务通常包括以下基本操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开始事务（BEGIN TRANSACTION）：开始一个新的事务，标记事务的起点。&lt;/li&gt;
&lt;li&gt;提交事务（COMMIT）：提交事务，将事务中的所有更改永久保存到数据库中。&lt;/li&gt;
&lt;li&gt;回滚事务（ROLLBACK）：回滚事务，撤销事务中的所有更改，恢复到事务开始之前的状态。&lt;/li&gt;
&lt;li&gt;保存点（SAVEPOINT）：在事务中设置一个保存点，可以在后续操作中回滚到这个保存点。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;并发事务&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#并发事务&#34;&gt;#&lt;/a&gt; 并发事务&lt;/h3&gt;
&lt;p&gt;并发事务是指多个事务同时对同一个数据进行操作，可能导致数据不一致的情况。&lt;br&gt;
以下是一些常见的并发事务问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;脏读：一个事务读取到另一个事务尚未提交的数据。 事务 A 读取事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不可重复读：一个事务中两次读取的数据的内容不一致。 事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务&lt;br&gt;
 A 多次读取同一数据时，结果 不一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;幻读：一个事务中两次读取的数据量不一致。 系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B&lt;br&gt;
 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。 解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。&lt;/p&gt;
&lt;p&gt;如何解决并发事务问题？&lt;/p&gt;
&lt;p&gt;MySQL 事务的隔离级别定义了事务之间相互隔离的程度，不同的隔离级别有不同的效果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交（Read Uncommitted）：
&lt;ul&gt;
&lt;li&gt;最低的隔离级别，允许事务读取未提交的数据。&lt;/li&gt;
&lt;li&gt;容易产生脏读、不可重复读和幻读。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读已提交（Read Committed）：
&lt;ul&gt;
&lt;li&gt;允许事务读取已提交的数据。&lt;/li&gt;
&lt;li&gt;防止脏读，但仍然可能出现不可重复读和幻读。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可重复读（Repeatable Read）：
&lt;ul&gt;
&lt;li&gt;事务在整个执行期间读取的数据始终不变。&lt;/li&gt;
&lt;li&gt;防止脏读和不可重复读，但仍然可能出现幻读。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;序列化（Serializable）：
&lt;ul&gt;
&lt;li&gt;最高的隔离级别，完全隔离事务，防止所有并发问题。&lt;/li&gt;
&lt;li&gt;可能导致性能下降，但确保了最高的数据一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同的隔离级别对性能和数据准确性的影响均不相同，需要根据具体的业务场景来做出取舍。顺带一提，在 MySQL&lt;br&gt;
 中，默认的事务隔离级别是可重复读（Repeatable Read）。&lt;/p&gt;
&lt;h2 id=&#34;锁&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#锁&#34;&gt;#&lt;/a&gt; 锁&lt;/h2&gt;
&lt;p&gt;MySQL 中的锁机制是数据库管理系统中非常重要的一部分，用于确保并发操作的一致性和数据的完整性。锁机制可以防止多个事务同时修改同一份数据，从而避免数据冲突和不一致的问题。&lt;/p&gt;
&lt;h3 id=&#34;mysql-中的锁类型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mysql-中的锁类型&#34;&gt;#&lt;/a&gt; MySQL 中的锁类型&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;表级锁（Table-Level Locks）&lt;/p&gt;
&lt;p&gt;表级锁是最粗粒度的锁，对整个表进行锁定。这种锁简单且易于实现，但在高并发环境下性能较差。&lt;/p&gt;
&lt;p&gt;类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读锁（READ LOCK）：
&lt;ul&gt;
&lt;li&gt;只允许读取数据，不允许写入数据。&lt;/li&gt;
&lt;li&gt;多个读锁可以同时存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;写锁（WRITE LOCK）：
&lt;ul&gt;
&lt;li&gt;独占锁，不允许读取和写入数据。&lt;/li&gt;
&lt;li&gt;只有一个写锁可以存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;备份和恢复：在备份或恢复数据时，可以使用表级锁确保数据的一致性。&lt;/li&gt;
&lt;li&gt;低并发环境：在并发较低的环境中，可以使用表级锁简化锁管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行级锁（Row-Level Locks）&lt;/p&gt;
&lt;p&gt;行级锁是对表中的单个行进行锁定，粒度较细，适用于高并发环境。&lt;/p&gt;
&lt;p&gt;存储引擎支持&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB：支持行级锁，广泛应用于高并发环境。&lt;/li&gt;
&lt;li&gt;MyISAM：不支持行级锁，只支持表级锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享锁（Shared Lock，S 锁）：
&lt;ul&gt;
&lt;li&gt;多个事务可以同时读取同一行数据。&lt;/li&gt;
&lt;li&gt;读取操作可以并行执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;排他锁（Exclusive Lock，X 锁）：
&lt;ul&gt;
&lt;li&gt;排他锁独占，不允许其他事务读取或写入同一行数据。&lt;/li&gt;
&lt;li&gt;写入操作独占执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发读写：在高并发环境中，行级锁可以允许多个事务同时读取数据，提高并发性能。&lt;/li&gt;
&lt;li&gt;事务处理：在事务处理中，行级锁可以确保数据的一致性和完整性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;页面级锁（Page-Level Locks）&lt;/p&gt;
&lt;p&gt;页面级锁是对表中的一页数据进行锁定，粒度介于表级锁和行级锁之间。&lt;/p&gt;
&lt;p&gt;存储引擎支持&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BDB（Berkeley DB）：支持页面级锁。&lt;/li&gt;
&lt;li&gt;InnoDB：支持页面级锁，但在实际应用中更常用的是行级锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中等并发环境：在中等并发环境中，页面级锁可以提高并发性能，减少锁的竞争。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;意向锁（Intention Locks）&lt;/p&gt;
&lt;p&gt;意向锁是一种辅助锁，用于指示事务打算对数据进行的操作类型。&lt;/p&gt;
&lt;p&gt;类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意向共享锁（Intention Shared Lock，IS 锁）：
&lt;ul&gt;
&lt;li&gt;表示事务打算获取某一行的共享锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;意向排他锁（Intention Exclusive Lock，IX 锁）：
&lt;ul&gt;
&lt;li&gt;表示事务打算获取某一行的排他锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务管理：在事务管理中，意向锁帮助数据库管理系统预测事务的操作类型，提前准备相应的锁资源。&lt;br&gt;
.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mysql-中的锁机制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mysql-中的锁机制&#34;&gt;#&lt;/a&gt; MySQL 中的锁机制&lt;/h3&gt;
&lt;p&gt;InnoDB 存储引擎广泛应用于 MySQL 中，其支持多种锁机制。&lt;br&gt;
锁与事务隔离级别的关系如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交（Read Uncommitted）：不使用任何锁。&lt;/li&gt;
&lt;li&gt;读已提交（Read Committed）：使用行级锁，读取时不加锁。&lt;/li&gt;
&lt;li&gt;可重复读（Repeatable Read）：使用行级锁，读取时加锁。&lt;/li&gt;
&lt;li&gt;序列化（Serializable）：使用行级锁，读取时加锁，确保最高隔离级别。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;间隙锁（Gap Locks）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义：间隙锁锁定行之间的 “间隙”，防止插入新的行。&lt;/li&gt;
&lt;li&gt;应用场景：在可重复读隔离级别下，InnoDB 使用间隙锁防止插入新的行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mvcc&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mvcc&#34;&gt;#&lt;/a&gt; MVCC&lt;/h3&gt;
&lt;p&gt;Mysql 的多版本并发控制（Multiversion Concurrency Control，简称 MVCC）主要用于实现读取操作与写入操作之间的并发执行。&lt;br&gt;
尤其是在 InnoDB 存储引擎中，它通过维护数据的多个版本来支持高并发读写操作。以下是关于 MVCV 的一些关键点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非锁定读取：在大多数情况下，MVCC 允许读取操作不加锁地进行，这意味着读取操作不会阻塞写入操作，反之亦然。这极大地提高了数据库的并发性能。&lt;/li&gt;
&lt;li&gt;快照读与当前读：
&lt;ul&gt;
&lt;li&gt;快照读（Snapshot Read）：默认情况下，读取操作获取的是事务开始时刻的数据版本，而不是最新的数据版本。这种方式避免了读取过程中可能发生的脏读、不可重复读等问题。&lt;/li&gt;
&lt;li&gt;当前读（Current Read）：当使用某些特定类型的查询（如带有 FOR UPDATE 或 LOCK IN SHARE MODE 提示的查询）时，会读取到最新的数据版本，并且可能会导致等待写锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;版本号机制：为了实现多版本并发控制，每个记录都有两个隐藏的字段：DB_TRX_ID 和 DB_ROLL_PTR。DB_TRX_ID 记录了最后修改这条记录的事务 ID，而 DB_ROLL_PTR 则指向了该记录的回滚段，其中保存着旧版本的数据。&lt;/li&gt;
&lt;li&gt;可见性规则：事务如何看到数据取决于一些简单的规则，这些规则基于事务的开始时间以及行上的版本标识来决定。具体来说，只有满足以下条件之一的行对当前事务才是可见的：
&lt;ul&gt;
&lt;li&gt;行的创建事务 ID 小于当前事务 ID（即行是在当前事务开始之前创建的）。&lt;/li&gt;
&lt;li&gt;行的创建事务 ID 等于当前事务 ID 并且行已被标记为已删除。&lt;/li&gt;
&lt;li&gt;行的删除事务 ID 大于当前事务 ID（即行是在当前事务开始之后被删除的）。&lt;/li&gt;
&lt;li&gt;行尚未被标记为已删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事务隔离级别：MVCC 的行为还受到事务隔离级别的影响。不同的隔离级别决定了事务之间如何交互以及如何处理数据版本。例如，在可重复读（Repeatable&lt;br&gt;
read）隔离级别下，InnoDB 会对读取的数据创建一个快照，并在整个事务期间都使用这个快照。&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/</guid>
            <title>【Redis】Redis详解</title>
            <link>https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/</link>
            <category>后端</category>
            <category>数据库</category>
            <category>Redis</category>
            <category>NoSQL</category>
            <category>缓存</category>
            <pubDate>Fri, 13 Sep 2024 13:52:28 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;概念&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#概念&#34;&gt;#&lt;/a&gt; 概念&lt;/h1&gt;
&lt;h2 id=&#34;redis-是什么&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis-是什么&#34;&gt;#&lt;/a&gt; Redis 是什么&lt;/h2&gt;
&lt;p&gt;Redis（Remote Dictionary Server）是一个开源的键值存储系统，以其高性能和低延迟著称。它最初由 Salvatore&lt;br&gt;
Sanfilippo 编写，并于 2009 年首次发布。Redis 不仅可以作为数据库使用，还可以作为缓存和消息代理。Redis 支持多种数据结构，如字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted&lt;br&gt;
sets）等，这使得它非常适合用于多种应用场景&lt;/p&gt;
&lt;h2 id=&#34;redis-的特点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis-的特点&#34;&gt;#&lt;/a&gt; Redis 的特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;内存存储：Redis 将所有数据都存储在内存中，这使得它能够提供非常高的读写速度，通常能够达到数十万次每秒的读写操作（QPS）。&lt;/li&gt;
&lt;li&gt;持久化：尽管 Redis 主要是一个内存数据库，但它也提供了数据持久化的机制，包括 RDB（Redis Database Backup）快照和 AOF（Append Only&lt;br&gt;
File）日志两种方式。&lt;/li&gt;
&lt;li&gt;数据结构丰富：除了基本的键值对存储之外，Redis 还支持多种复杂的数据结构，如列表、集合、有序集合等，这使得它非常适合用于构建复杂的数据模型。&lt;/li&gt;
&lt;li&gt;网络透明：Redis 使用 TCP 协议，客户端可以通过网络访问 Redis 服务器，支持跨平台部署。&lt;/li&gt;
&lt;li&gt;主从复制：Redis 支持主从复制机制，可以轻松地设置数据备份和读写分离。&lt;/li&gt;
&lt;li&gt;Lua 脚本：Redis 支持在服务器端执行 Lua 脚本，允许用户将复杂的操作封装成一个原子性的操作。&lt;/li&gt;
&lt;li&gt;事务：Redis 支持事务，允许用户将一系列操作打包成一个单独的命令序列执行。&lt;/li&gt;
&lt;li&gt;发布 / 订阅模式：Redis 支持发布 / 订阅模式，可以用于构建消息队列或事件驱动的应用程序。&lt;/li&gt;
&lt;li&gt;集群：Redis 3.0 之后版本支持官方的集群模式，可以实现数据的水平扩展。&lt;/li&gt;
&lt;li&gt;多线程：Redis 6.0 版本引入了多线程模型，用于异步处理 I/O 和其他耗时操作，进一步提升了性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis-的应用场景&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis-的应用场景&#34;&gt;#&lt;/a&gt; Redis 的应用场景&lt;/h2&gt;
&lt;p&gt;由于其高性能和灵活性，Redis 被广泛应用于多种场景中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存：由于 Redis 的高速读写能力，它经常被用作 Web 应用的缓存层，以减轻后端数据库的压力。&lt;/li&gt;
&lt;li&gt;会话存储：Redis 可以用来存储用户的会话信息，支持快速的读取和更新操作。&lt;/li&gt;
&lt;li&gt;排行榜：Redis 的有序集合非常适合用来构建排行榜，可以高效地进行排序和范围查询。&lt;/li&gt;
&lt;li&gt;消息队列：通过发布 / 订阅模式，Redis 可以作为一个轻量级的消息队列系统。&lt;/li&gt;
&lt;li&gt;实时数据分析：Redis 的数据结构非常适合用于处理实时数据流，如实时统计、监控等。&lt;/li&gt;
&lt;li&gt;分布式锁：Redis 可以用来实现简单的分布式锁机制，协调多个节点上的并发操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis-的数据结构&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis-的数据结构&#34;&gt;#&lt;/a&gt; Redis 的数据结构&lt;/h2&gt;
&lt;h3 id=&#34;底层数据结构&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#底层数据结构&#34;&gt;#&lt;/a&gt; 底层数据结构&lt;/h3&gt;
&lt;h4 id=&#34;redisobject&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redisobject&#34;&gt;#&lt;/a&gt; redisObject&lt;/h4&gt;
&lt;p&gt;定义：redisObject（通常缩写为 robj）是 Redis 中用来表示数据库键值对的一个核心数据结构。每一个键值对在 Redis 内部都会被转化为一个 redisObject 实例进行管理。这个结构体不仅包含了键或值本身的数据，还提供了额外的信息来帮助 Redis 更好地管理和操作这些对象。&lt;/p&gt;
&lt;p&gt;用途：redisObject 是 Redis 中键值对存储的数据结构，它封装了键和值，并提供了额外的元数据，如引用计数、过期时间等。其主要作用在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型和编码：它使得 Redis 能够灵活地存储不同类型的数据，并且可以根据数据的特点选择最合适的编码方式来存储，从而优化内存使用和访问速度。&lt;/li&gt;
&lt;li&gt;内存管理：通过引用计数，redisObject 支持对象的共享和自动内存回收，减少了不必要的内存分配和释放操作。&lt;/li&gt;
&lt;li&gt;LRU 缓存淘汰：通过记录对象的最后访问时间，Redis 可以实现基于 LRU 算法的对象淘汰，从而在内存资源有限的情况下，优先保留最近使用的对象。&lt;/li&gt;
&lt;li&gt;共享对象：对于一些常用的简单对象（如数字 0 和 1，以及空字符串），Redis 会创建一次并复用，这减少了创建和销毁对象的开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;底层实现：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;redisObject&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;unsigned&lt;/span&gt; type:&lt;span class=&#34;number&#34;&gt;4&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;unsigned&lt;/span&gt; encoding:&lt;span class=&#34;number&#34;&gt;4&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;unsigned&lt;/span&gt; lru:REDIS_LRU_BITS; &lt;span class=&#34;comment&#34;&gt;/* LRU time (relative to server.lruclock) */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; refcount;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; *ptr;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; robj;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;redisObject 的基本结构通常包含以下字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;type: 一个 4 位的无符号整数，用来标识对象的类型。Redis 支持多种数据类型，如字符串（string）、列表（list）、集合（set）、哈希（hash）、有序集合（sorted&lt;br&gt;
set）等，每种类型都有一个对应的标识符。&lt;/li&gt;
&lt;li&gt;encoding: 另一个 4 位的无符号整数，表示对象的编码方式。不同的数据类型有不同的内部编码方式，例如字符串可以是普通的字符串，也可以是压缩后的字符串（embstr），列表可以是链表（list）或者快速列表（quicklist）等。&lt;/li&gt;
&lt;li&gt;lru: 一个时间戳，记录了对象最后一次被访问的时间（相对于服务器的 lruclock）。这个字段用于实现 Redis 的 LRU（Least Recently&lt;br&gt;
Used）缓存淘汰策略。&lt;/li&gt;
&lt;li&gt;refcount: 引用计数器，用来追踪有多少地方引用了这个对象。当一个对象不再被任何地方引用时，其引用计数器减至零，Redis 可以回收该对象占用的内存。&lt;/li&gt;
&lt;li&gt;ptr: 一个指向实际数据的指针。这个指针指向的具体内容依赖于对象的类型和编码方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;动态字符串sds&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#动态字符串sds&#34;&gt;#&lt;/a&gt; 动态字符串（SDS）&lt;/h4&gt;
&lt;p&gt;定义：SDS（Simple Dynamic String）是一种动态字符串，它使用一个结构体来保存字符串的指针、长度和未使用的空间。&lt;/p&gt;
&lt;p&gt;底层实现：使用简单动态字符串（SDS）来存储数据，SDS 是为了克服 C 字符串的一些不足而设计的。&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;sdshdr&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;//记录buf数组中已使用字节的数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;//等于 SDS 保存字符串的长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; len;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;//记录 buf 数组中未使用字节的数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;free&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;//字节数组，用于保存字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用 SDS 保存字符串 “Redis” 具体图示如下：&lt;/p&gt;
&lt;img data-src=&#34;/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1120165-20180528075607627-218845583.png&#34; class=&#34;&#34; title=&#34;1120165-20180528075607627-218845583.png&#34;&gt;
&lt;p&gt;图片来源：《Redis 设计与实现》&lt;/p&gt;
&lt;p&gt;我们看上面对于 SDS 数据类型的定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;len 保存了 SDS 保存字符串的长度&lt;/li&gt;
&lt;li&gt;buf [] 数组用来保存字符串的每个元素&lt;/li&gt;
&lt;li&gt;free j 记录了 buf 数组中未使用的字节数量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的定义相对于 C 语言对于字符串的定义，有什么好处？&lt;/p&gt;
&lt;img data-src=&#34;/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1120165-20180527234349672-568401853.png&#34; class=&#34;&#34; title=&#34;1120165-20180528075607627-218845583.png&#34;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;常数复杂度获取字符串长度：由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O (1)。而对于 C&lt;br&gt;
 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O (n)。通过 strlen key 命令可以获取 key 的字符串长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;杜绝缓冲区溢出：我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于&lt;br&gt;
 SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求。如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;减少修改字符串的内存重新分配次数:&lt;br&gt;
C 语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。&lt;/p&gt;
&lt;p&gt;而对于 SDS，由于 len 属性和 free 属性的存在，对于修改字符串 SDS 实现了空间预分配和惰性空间释放两种策略：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。&lt;/li&gt;
&lt;li&gt;惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free&lt;br&gt;
 属性将这些字节的数量记录下来，等待后续使用。（当然 SDS 也提供了相应的 API，当我们有需要时，也可以手动释放这些未使用的空间。）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二进制安全&lt;/p&gt;
&lt;p&gt;因为 C 字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此 C 字符串无法正确存取；而所有&lt;br&gt;
 SDS 的 API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len&lt;br&gt;
 属性表示的长度来判断字符串是否结束。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;兼容部分 C 字符串函数&lt;/p&gt;
&lt;p&gt;虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库 &amp;lt;string.h&amp;gt; 中的一部分函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）来使用。&lt;/p&gt;
&lt;h4 id=&#34;压缩列表zip-list&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#压缩列表zip-list&#34;&gt;#&lt;/a&gt; 压缩列表（Zip List）&lt;/h4&gt;
&lt;p&gt;定义：Ziplist 是一种特殊的内存紧凑型数据结构，用于存储多个相邻的元素。它主要用于实现 Redis 中的列表（List）和哈希（Hash）数据类型，当这些数据类型的数据量较小且元素较短时，使用 ziplist 可以节省内存空间。&lt;/p&gt;
&lt;p&gt;底层实现：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; header; &lt;span class=&#34;comment&#34;&gt;// 标记ziplist的开始，通常是一个固定的字节（例如 0x01）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;uint32_t&lt;/span&gt; length; &lt;span class=&#34;comment&#34;&gt;// 整个ziplist的长度，包括所有条目和前缀信息。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// Entries&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// Each entry has a length prefix and content&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// The number of entries is determined by the length field&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// Example entry structure:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// Length prefix (1 or 5 bytes)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// Content (variable length)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// End marker&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; end; &lt;span class=&#34;comment&#34;&gt;// 标记ziplist的结束，通常是一个固定的字节（例如 0xff）。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; &lt;span class=&#34;type&#34;&gt;ziplist_t&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实现细节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前缀：每个元素的前缀包含了元素的长度信息，以及元素的类型信息。&lt;/li&gt;
&lt;li&gt;长度编码：ziplist 使用可变长度编码来存储元素的长度，这样可以更高效地利用内存。&lt;/li&gt;
&lt;li&gt;内存紧凑：由于 ziplist 将所有元素存储在一个连续的内存区域中，因此它可以有效地减少内存碎片。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连续存储：ziplist 将多个元素存储在一个连续的内存块中。&lt;/li&gt;
&lt;li&gt;元素和长度信息：每个元素的前面都会有一个前缀，这个前缀包含了元素的长度信息。&lt;/li&gt;
&lt;li&gt;支持多种类型：ziplist 可以存储整数或字符串，整数直接存储在前缀中，字符串则存储在前缀之后。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;双向链表linkedlist&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#双向链表linkedlist&#34;&gt;#&lt;/a&gt; 双向链表（linkedlist）&lt;/h4&gt;
&lt;p&gt;定义：在 Redis 中，linkedlist（通常指的是 Redis 内部实现的双向链表）是 Redis 用来存储 list 键值对的一种底层数据结构。它允许 Redis 从列表的两端高效地添加和移除元素，&lt;/p&gt;
&lt;p&gt;底层实现：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 定义一个双向链表节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt;  &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;listNode&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       &lt;span class=&#34;comment&#34;&gt;//前置节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;listNode&lt;/span&gt; *&lt;span class=&#34;title&#34;&gt;prev&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       &lt;span class=&#34;comment&#34;&gt;//后置节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;listNode&lt;/span&gt; *&lt;span class=&#34;title&#34;&gt;next&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       &lt;span class=&#34;comment&#34;&gt;//节点的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; *value;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;listNode&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 定义一个双向链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;list&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;comment&#34;&gt;//表头节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     listNode *head;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;comment&#34;&gt;//表尾节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     listNode *tail;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;comment&#34;&gt;//链表所包含的节点数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;long&lt;/span&gt; len;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;comment&#34;&gt;//节点值复制函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; (*&lt;span class=&#34;built_in&#34;&gt;free&lt;/span&gt;) (&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; *ptr);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;comment&#34;&gt;//节点值释放函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; (*&lt;span class=&#34;built_in&#34;&gt;free&lt;/span&gt;) (&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; *ptr);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;comment&#34;&gt;//节点值对比函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; (*match) (&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; *ptr,&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; *key);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;span class=&#34;built_in&#34;&gt;list&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;数据结构如下图&lt;/p&gt;
&lt;img data-src=&#34;/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1120165-20180528074403440-111834793.png&#34; class=&#34;&#34; title=&#34;1120165-20180528074403440-111834793.png&#34;&gt;
&lt;p&gt;Redis 的 linkedlist 是由一系列 listNode 节点构成的双向链表。&lt;/p&gt;
&lt;p&gt;每个 listNode 包含三个主要部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prev：指向列表中前一个节点的指针。&lt;/li&gt;
&lt;li&gt;next：指向列表中后一个节点的指针。&lt;/li&gt;
&lt;li&gt;value：存储实际数据的字段，这个字段实际上是指向 redisObject 的指针，redisObject 包含了实际的数据和元数据（如类型、编码等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个 list 包含三个主要部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;head：指向链表的第一个节点。&lt;/li&gt;
&lt;li&gt;tail：指向链表的最后一个节点。&lt;/li&gt;
&lt;li&gt;len：链表的长度，即链表中节点的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双向链接：每个节点都包含前驱和后继指针，这使得可以从链表的任一端开始遍历整个链表。&lt;/li&gt;
&lt;li&gt;无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL, 对链表的访问都是以 NULL 结束。&lt;/li&gt;
&lt;li&gt;带链表长度计数器：通过 len 属性获取链表长度的时间复杂度为 O (1)。&lt;/li&gt;
&lt;li&gt;多态：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值。&lt;/li&gt;
&lt;li&gt;动态增长：随着元素的增加，链表可以动态增长。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;哈希表hashtable&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#哈希表hashtable&#34;&gt;#&lt;/a&gt; 哈希表（Hashtable）&lt;/h4&gt;
&lt;p&gt;定义：hashtable（哈希表）是一种用于存储键值对的数据结构，它在 Redis 内部用于实现哈希（hash）类型。哈希表允许快速地插入、查找和删除键值对，并且提供了良好的性能。&lt;/p&gt;
&lt;p&gt;底层实现：Redis 中的哈希表实现主要包括两个核心组件：一个数组和一个链表。数组中的每个槽（slot）都可以存储一个链表，链表中的每个节点代表一个键值对。这种设计允许哈希表处理哈希冲突，即多个键映射到同一个数组索引的情况。&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;dict&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    dictEntry **table; &lt;span class=&#34;comment&#34;&gt;// 哈希桶数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;long&lt;/span&gt; size; &lt;span class=&#34;comment&#34;&gt;// 哈希桶数组大小&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;long&lt;/span&gt; used; &lt;span class=&#34;comment&#34;&gt;// 已使用的哈希桶数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    dictResizeFunc *resize; &lt;span class=&#34;comment&#34;&gt;// 重置哈希表大小的函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; (*rehashidx); &lt;span class=&#34;comment&#34;&gt;// 当前正在进行的哈希表重置索引&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;long&lt;/span&gt; states; &lt;span class=&#34;comment&#34;&gt;// 哈希表状态标志&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; dict;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Redis 中的哈希表结构定义通常包括以下几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;table：一个数组，数组的每个元素都是一个链表。&lt;/li&gt;
&lt;li&gt;size：数组的大小。&lt;/li&gt;
&lt;li&gt;used：已使用的槽的数量，即存储键值对的链表数量。&lt;/li&gt;
&lt;li&gt;resize_policy：在某些 Redis 版本中，可能还包括用于控制何时进行重新哈希（resizing）的策略。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;哈希表 table 中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;dictEntry&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; *key; &lt;span class=&#34;comment&#34;&gt;// 键&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;union&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; *val; &lt;span class=&#34;comment&#34;&gt;// 值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;uint64_t&lt;/span&gt; ival; &lt;span class=&#34;comment&#34;&gt;// 整数值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125; v;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;dictEntry&lt;/span&gt; *&lt;span class=&#34;title&#34;&gt;next&lt;/span&gt;;&lt;/span&gt; &lt;span class=&#34;comment&#34;&gt;// 指向下一个同散列值的dictEntry&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; dictEntry;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;每个键值对存储在一个 dictEntry 结构体中，该结构体包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;key：键的指针，指向 redisObject。&lt;/li&gt;
&lt;li&gt;val：值的指针，同样指向 redisObject。&lt;/li&gt;
&lt;li&gt;next：指向链表中下一个节点的指针，用于处理哈希冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;哈希冲突的优化&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#哈希冲突的优化&#34;&gt;#&lt;/a&gt; 哈希冲突的优化&lt;/h5&gt;
&lt;p&gt;我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过 next 这个指针可以将多个哈希值相同的键值对连接在一起，用来解决哈希冲突。&lt;/p&gt;
&lt;img data-src=&#34;/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1120165-20180528080655703-1600710948.png&#34; class=&#34;&#34; title=&#34;1120165-20180528080655703-1600710948.png&#34;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;哈希算法：Redis 计算哈希值和索引值方法如下：&lt;/p&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;#&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;、使用字典设置的哈希函数，计算键 key 的哈希值&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;hash = dict-&amp;gt;type-&amp;gt;hashFunction(key);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;#&lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;index = hash &amp;amp; dict-&amp;gt;ht[x].sizemask;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决哈希冲突：这个问题上面我们介绍了，方法是链地址法。通过字典里面的 *next 指针指向下一个具有相同索引值的哈希表节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;扩容和收缩：当哈希表保存的键值对太多或者太少时，就要通过 rerehash (重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果执行扩展操作，会基于原哈希表创建一个大小等于 ht [0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。&lt;br&gt;
相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。&lt;/li&gt;
&lt;li&gt;重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。&lt;/li&gt;
&lt;li&gt;所有键值对都迁徙完毕后，释放原哈希表的内存空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;触发扩容的条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于 1。&lt;/li&gt;
&lt;li&gt;服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于 5。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;渐近式 rehash&lt;/p&gt;
&lt;p&gt;什么叫渐进式 rehash？ 也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在 Redis 中的键值对只有几个几十个，那么&lt;br&gt;
 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行&lt;br&gt;
 rehash，势必会造成 Redis 一段时间内不能进行别的操作。所以 Redis 采用渐进式&lt;br&gt;
 rehash, 这样在进行渐进式 rehash 期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行&lt;br&gt;
增加操作，一定是在新的哈希表上进行的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;整数集合intset&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#整数集合intset&#34;&gt;#&lt;/a&gt; 整数集合（intset）&lt;/h4&gt;
&lt;p&gt;定义：一种特殊的数据结构，主要用于存储整数类型的集合，并且这些整数集合不允许有重复的元素。&lt;/p&gt;
&lt;p&gt;底层实现：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;intset&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;comment&#34;&gt;//编码方式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;uint32_t&lt;/span&gt; encoding;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;comment&#34;&gt;//集合包含的元素数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;uint32_t&lt;/span&gt; length;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;comment&#34;&gt;//保存元素的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;int8_t&lt;/span&gt; contents[];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;intset;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;intset 的数据结构定义通常包括以下几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;length：表示集合中元素的数量。&lt;/li&gt;
&lt;li&gt;encoding：表示集合中元素的类型，可以是 int16_t、int32_t 或 int64_t，具体取决于集合中最大的整数值所需的位数。&lt;/li&gt;
&lt;li&gt;contents：一个动态数组，用于存储实际的整数值。每个整数根据 encoding 字段指定的类型占用相应的字节数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;动态升级&lt;/p&gt;
&lt;p&gt;当尝试向 intset 中添加一个超出当前整数类型范围的整数时，Redis 会执行一个称为 “编码升级” 的过程。这个过程会将 intset 中的所有元素转换为更大类型的整数，以适应新加入的元素。例如，如果 intset 当前使用的是 int32_t 类型，而尝试插入一个 int64_t 类型的值，则所有现有的 int32_t 值会被转换成 int64_t 类型。&lt;/p&gt;
&lt;h4 id=&#34;跳表skip-list&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#跳表skip-list&#34;&gt;#&lt;/a&gt; 跳表（Skip List）&lt;/h4&gt;
&lt;p&gt;定义：Skiplist 是一种线性数据结构，它提供了比传统平衡树更快的查找性能，同时实现相对简单。Redis 使用 skiplist 来实现有序集合（Sorted&lt;br&gt;
Set）。&lt;/p&gt;
&lt;p&gt;底层实现：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;zskiplist&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;zskiplistNode&lt;/span&gt; *&lt;span class=&#34;title&#34;&gt;header&lt;/span&gt;;&lt;/span&gt; &lt;span class=&#34;comment&#34;&gt;// 跳表头部&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;zskiplistNode&lt;/span&gt; *&lt;span class=&#34;title&#34;&gt;tail&lt;/span&gt;;&lt;/span&gt; &lt;span class=&#34;comment&#34;&gt;// 跳表尾部&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; length; &lt;span class=&#34;comment&#34;&gt;// 跳表长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; level; &lt;span class=&#34;comment&#34;&gt;// 跳表层级&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; zskiplist;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;zskiplistNode&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;double&lt;/span&gt; score; &lt;span class=&#34;comment&#34;&gt;// 成员的分数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; *obj; &lt;span class=&#34;comment&#34;&gt;// 成员对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;zskiplistNode&lt;/span&gt; *&lt;span class=&#34;title&#34;&gt;backward&lt;/span&gt;;&lt;/span&gt; &lt;span class=&#34;comment&#34;&gt;// 指向前一个节点的指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;zskiplistLevel&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;zskiplistNode&lt;/span&gt; *&lt;span class=&#34;title&#34;&gt;forward&lt;/span&gt;;&lt;/span&gt; &lt;span class=&#34;comment&#34;&gt;// 指向后一个节点的指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; span; &lt;span class=&#34;comment&#34;&gt;// 跨越的节点数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125; level[]; &lt;span class=&#34;comment&#34;&gt;// 层级数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; zskiplistNode;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实现细节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点结构：skiplist 中的每个节点包含一个元素、一个分数（用于排序）、一个指向前一个节点的指针以及一个或多个指向下一层节点的指针。&lt;/li&gt;
&lt;li&gt;层级：每个节点可以有多个层级，每个层级对应一个指针，指向下一个具有相同高度的节点。&lt;/li&gt;
&lt;li&gt;查找：查找时，从最高层开始，沿着指针前进直到找到目标元素或到达最低层。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多级索引：skiplist 通过构建多级索引来加速查找，每一级索引都是前一级索引的一个子集。&lt;/li&gt;
&lt;li&gt;随机高度：新插入的元素的高度是随机确定的，通常使用随机化算法来决定新节点的高度。&lt;/li&gt;
&lt;li&gt;高效插入和删除：由于 skiplist 的多级索引结构，插入和删除操作也相当高效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据结构的使用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#数据结构的使用&#34;&gt;#&lt;/a&gt; 数据结构的使用&lt;/h3&gt;
&lt;h4 id=&#34;字符串string&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#字符串string&#34;&gt;#&lt;/a&gt; 字符串（String）&lt;/h4&gt;
&lt;p&gt;用途：存储字符串数据，如文本、数字、日期等。&lt;/p&gt;
&lt;p&gt;实现：根据不同的情况下字符串对象的 encoding 有三种，分别是：int、raw、embstr。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果一个字符串对象保存的是整数值，并且这个整数值可以用 long 类型标识，那么字符串对象会讲整数值保存在 ptr 属性中，并将&lt;br&gt;
 encoding 设置为 int。比如 set number 10086 命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果字符串对象保存的是一个字符串值，并且这个字符串的长度大于 44 字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为&lt;br&gt;
 raw。在这种情况下，ptr 字段指向一个 SDS（Simple Dynamic String）结构。S 在这种情况下，ptr 字段指向一个 SDS（Simple Dynamic&lt;br&gt;
String）结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果字符串对象保存的是一个字符串值，并且这个字符串的长度小于等于 44 字节，那么字符串对象将使用 embstr&lt;br&gt;
 编码的方式来保存这个字符串。embstr 同样基于 SDS，是一种将 RedisObject 对象头和 SDS 对象连续存在一起，使用 malloc&lt;br&gt;
 方法一次分配内存的存储形式。 这种编码方式的一些优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次。&lt;/li&gt;
&lt;li&gt;释放 embstr 编码的字符串对象只需要调用一次内存释放函数，而释放 raw 编码的字符串对象需要调用两次内存释放函数。&lt;/li&gt;
&lt;li&gt;因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起 raw&lt;br&gt;
 编码的字符串对象能够更好地利用缓存带来的优势。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为什么分界线是 44 字节？&lt;/p&gt;
&lt;p&gt;Redis 的 embstr 编码的实现中，字符串对象头和字符串对象本身是连续的，因此需要一个字节来保存字符串的长度。&lt;br&gt;
embstr 最小占用空间为 19（16+3），而 64-19-1（结尾的 \0）=44，所以 embstr 只能容纳 44 字节。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计数器：例如网站的访问计数，可以使用 INCR 或 INCRBY 命令来递增计数器。&lt;/li&gt;
&lt;li&gt;会话存储：存储用户的登录状态或其他临时信息。&lt;/li&gt;
&lt;li&gt;消息队列：使用 LPUSH 和 BRPOP 命令实现简单的消息队列。&lt;/li&gt;
&lt;li&gt;缓存：存储经常访问的数据，减少数据库的访问压力。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;列表list&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#列表list&#34;&gt;#&lt;/a&gt; 列表（List）&lt;/h4&gt;
&lt;p&gt;用途：用于存储有序的元素列表，如队列、栈等。&lt;/p&gt;
&lt;p&gt;实现：列表对象的 encoding 有 ziplist 和 linkedlist 两种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当列表的长度小于 512，并且所有元素的长度都小于 64 字节时，使用压缩列表 (ziplist) 存储&lt;/li&gt;
&lt;li&gt;当列表的长度大于等于 512，或者有元素长度大于 64 字节时，使用链表 (linkedlist) 存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息队列：使用 LPUSH 和 BRPOP 命令实现先进先出（FIFO）的消息队列。&lt;/li&gt;
&lt;li&gt;历史记录：保存用户的浏览历史或购买记录，可以使用 RPUSH 和 LPOP 命令。&lt;/li&gt;
&lt;li&gt;排行榜：使用列表存储排名信息，通过 LREM 命令可以移除特定成员。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;哈希hash&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#哈希hash&#34;&gt;#&lt;/a&gt; 哈希（Hash）&lt;/h4&gt;
&lt;p&gt;用途：存储键值对，其中键是唯一的，值可以重复。&lt;/p&gt;
&lt;p&gt;实现：哈希对象的 encoding 有 ziplist 和 hashtable 两种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当哈希对象保存的键值对数量小于 512，并且所有键值对的长度都小于 64 字节时，使用压缩列表存储；&lt;/li&gt;
&lt;li&gt;当哈希对象保存的键值对数量大于等于 512，或者有键值对长度大于 64 字节时，使用 hashtable 存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象存储：存储复杂对象，如用户信息，每个字段对应用户的一个属性。&lt;/li&gt;
&lt;li&gt;购物车：每个用户有一个购物车，购物车中的商品信息可以用哈希表来存储。&lt;/li&gt;
&lt;li&gt;会话管理：存储用户的会话信息，每个会话 ID 对应一个哈希表。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;集合set&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#集合set&#34;&gt;#&lt;/a&gt; 集合（Set）&lt;/h4&gt;
&lt;p&gt;用途：存储不重复的元素集合，如集合、去重列表等。&lt;/p&gt;
&lt;p&gt;实现：集合对象的 encoding 有 intset 和 hashtable 两种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当集合中元素数量小于 512，并且所有元素的长度都小于 64 字节时，使用 intset 存储；&lt;/li&gt;
&lt;li&gt;当集合中元素数量大于等于 512，或者有元素长度大于 64 字节时，使用 hashtable 存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;去重：例如在一个活动中，确保每个用户只能参与一次。&lt;/li&gt;
&lt;li&gt;标签系统：每个项目可以有多个标签，使用集合来存储项目的标签。&lt;/li&gt;
&lt;li&gt;好友关系：存储用户的好友列表，可以快速判断两个用户是否互为好友。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;有序集合sorted-set&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#有序集合sorted-set&#34;&gt;#&lt;/a&gt; 有序集合（Sorted Set）&lt;/h4&gt;
&lt;p&gt;用途：存储有序的元素集合，其中元素是唯一的，并且可以按照一定的顺序排列。&lt;/p&gt;
&lt;p&gt;实现：有序集合对象的 encoding 有 ziplist 和 skiplist 两种。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当有序集合中的元素数量小于 512，并且所有元素的长度都小于 64 字节时，使用压缩列表 (ziplist) 存储；&lt;/li&gt;
&lt;li&gt;当有序集合中的元素数量大于等于 512，或者有元素长度大于 64 字节时，使用跳表 (skiplist) 存储。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排行榜：根据分数排序的排行榜，如游戏得分、用户贡献度等。&lt;/li&gt;
&lt;li&gt;优先级队列：每个元素都有一个优先级，可以按优先级取出元素。&lt;/li&gt;
&lt;li&gt;时间轴：按时间戳排序的消息或帖子显示，如微博、Facebook 的时间线。&lt;/li&gt;
&lt;li&gt;地理信息：存储地理位置信息，并使用 GEO 命令查询附近的地点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;其他数据结构&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#其他数据结构&#34;&gt;#&lt;/a&gt; 其他数据结构&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Bitmaps：二进制位数组，适合用于存储大量稀疏数据，如用户访问记录、权限控制等。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;统计分析：例如统计某一天有多少独立用户访问了网站，可以使用一个位图来表示每个用户是否访问过。&lt;/li&gt;
&lt;li&gt;权限管理：每个用户可以有多个权限位，使用位图来表示用户的权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HyperLogLog：用于近似计算不重复元素的数量，非常适合处理大规模数据集。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;近似计数：用于估算大量数据中的不重复元素数量，例如统计网站的独立访客数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Streams：类似于消息队列，用于处理异步消息传递，可以实现类似 Kafka 的功能。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件日志：记录系统中的事件，如用户行为日志，可以使用 XADD 添加事件，XREAD 读取事件。&lt;/li&gt;
&lt;li&gt;异步处理：作为消息队列的一部分，将事件发布到流中，然后由消费者异步处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Geo：用于存储地理位置信息，并提供基于地理位置的查询功能。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位置服务：存储地理位置信息，并支持基于地理位置的搜索，如查找附近的餐厅或酒店。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;redis-综合应用示例&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis-综合应用示例&#34;&gt;#&lt;/a&gt; Redis 综合应用示例&lt;/h4&gt;
&lt;p&gt;假设我们要构建一个社交网络应用，可以使用 Redis 来实现以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户信息存储：使用 Hash 类型存储每个用户的个人信息，如用户名、头像、生日等。&lt;/li&gt;
&lt;li&gt;好友关系：使用 Set 类型存储每个用户的好友列表。&lt;/li&gt;
&lt;li&gt;动态时间线：使用 Sorted Set 类型存储用户的动态，根据发布时间排序。&lt;/li&gt;
&lt;li&gt;消息通知：使用 List 类型作为消息队列，存储用户收到的通知消息。&lt;/li&gt;
&lt;li&gt;在线状态：使用 BitMap 类型记录每天用户的在线状态。&lt;/li&gt;
&lt;li&gt;热门话题：使用 HyperLogLog 类型来估计参与某个话题讨论的独立用户数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis-的持久化&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis-的持久化&#34;&gt;#&lt;/a&gt; Redis 的持久化&lt;/h2&gt;
&lt;p&gt;redis 是一个内存数据库，数据保存在内存中，但是我们都知道内存的数据变化是很快的，也容易发生丢失。幸好 Redis 还为我们提供了持久化的机制，分别是 RDB (&lt;br&gt;
Redis DataBase) 和 AOF (Append Only File)。&lt;/p&gt;
&lt;h3 id=&#34;rdb机制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#rdb机制&#34;&gt;#&lt;/a&gt; RDB 机制&lt;/h3&gt;
&lt;p&gt;RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为 dump.rdb。&lt;/p&gt;
&lt;p&gt;Redis 提供了三种机制：save、bgsave、自动化来触发 RDB 持久化过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;save 触发方式&lt;/p&gt;
&lt;p&gt;该命令会阻塞当前 Redis 服务器，执行 save 命令期间，Redis 不能处理其他命令，直到 RDB 过程完成为止。具体流程如下：&lt;/p&gt;
&lt;img data-src=&#34;/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg&#34; class=&#34;&#34; title=&#34;e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg&#34;&gt;
&lt;p&gt;执行完成时候如果存在老的 RDB 文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bgsave 触发方式&lt;/p&gt;
&lt;p&gt;执行该命令时，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：&lt;/p&gt;
&lt;img data-src=&#34;/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg&#34; class=&#34;&#34; title=&#34;023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg&#34;&gt;
&lt;p&gt;具体操作是 Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短。基本上&lt;br&gt;
 Redis 内部所有的 RDB 操作都是采用 bgsave 命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自动触发&lt;/p&gt;
&lt;p&gt;自动触发是由我们的配置文件来完成的。在 redis.conf 配置文件中，里面有如下配置，我们可以去设置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;save：这里是用来配置触发 Redis 的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如 “save m&lt;br&gt;
n”。表示 m 秒内数据集存在 n 次修改时，自动触发 bgsave。&lt;/li&gt;
&lt;li&gt;stop-writes-on-bgsave-error：默认值为 yes。&lt;br&gt;
当启用了 RDB 且最后一次后台保存数据失败，Redis 是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果 Redis 重启了，那么又可以重新开始接收数据了&lt;/li&gt;
&lt;li&gt;rdbcompression；默认值是 yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。&lt;/li&gt;
&lt;li&gt;rdbchecksum：默认值是 yes。在存储快照后，我们还可以让 redis 使用 CRC64 算法来进行数据校验，但是这样做会增加大约 10% 的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。&lt;/li&gt;
&lt;li&gt;dbfilename：设置快照的文件名，默认是 dump.rdb&lt;/li&gt;
&lt;li&gt;dir：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以修改这些配置来实现我们想要的效果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为第三种方式是配置的，所以我们对前两种进行一个对比：&lt;/p&gt;
&lt;img data-src=&#34;/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1c950a7b02087bf43b4490d50ac25f2a11dfcf7e.jpeg&#34; class=&#34;&#34; title=&#34;1c950a7b02087bf43b4490d50ac25f2a11dfcf7e.jpeg&#34;&gt;
&lt;p&gt;RDB 的优势和劣势&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优势&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RDB 文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。&lt;/li&gt;
&lt;li&gt;生成 RDB 文件的时候，redis 主进程会 fork () 一个子进程来处理所有保存工作，主进程不需要进行任何磁盘 IO 操作。&lt;/li&gt;
&lt;li&gt;RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;劣势&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RDB 快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。&lt;br&gt;
当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;aof机制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#aof机制&#34;&gt;#&lt;/a&gt; AOF 机制&lt;/h3&gt;
&lt;p&gt;全量备份总是耗时的，Redis 提供一种更加高效的方式 AOF，工作机制很简单，Redis 会将每一个收到的写命令都通过 write 函数追加到文件中。通俗的理解就是日志记录。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;持久化原理&lt;/p&gt;
&lt;p&gt;他的原理看下面这张图：&lt;/p&gt;
&lt;img data-src=&#34;/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/32fa828ba61ea8d3c2502e396b1b3848251f58b0.jpeg&#34; class=&#34;&#34; title=&#34;32fa828ba61ea8d3c2502e396b1b3848251f58b0.jpeg&#34;&gt;
&lt;p&gt;每当有一个写命令过来时，就直接保存在我们的 AOF 文件中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件重写原理&lt;/p&gt;
&lt;p&gt;AOF 的方式也同时带来了另一个问题：持久化文件会变的越来越大。为了解决这个问题，redis 提供了 bgrewriteaof 命令用来压缩 aof 的持久化文件。这条命令会将内存中的数据以命令的方式保存到临时文件中，同时会 fork 出一条新进程来将文件重写。&lt;/p&gt;
&lt;img data-src=&#34;/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/09fa513d269759ee28454d2c4cea4b106c22dfd3.jpeg&#34; class=&#34;&#34; title=&#34;09fa513d269759ee28454d2c4cea4b106c22dfd3.jpeg&#34;&gt;
&lt;p&gt;重写 aof 文件的操作，并没有读取旧的 aof 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 aof 文件，这点和快照有点类似。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;AOF 也有三种触发机制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每修改同步 always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好&lt;/li&gt;
&lt;li&gt;每秒同步 everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失&lt;/li&gt;
&lt;li&gt;不同 no：从不同步&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三种触发机制的对比如下图&lt;/p&gt;
&lt;img data-src=&#34;/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/b17eca8065380cd7df69859ba056a5325982816c.jpeg&#34; class=&#34;&#34; title=&#34;b17eca8065380cd7df69859ba056a5325982816c.jpeg&#34;&gt;
&lt;p&gt;AOF 的优势和劣势&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优势
&lt;ul&gt;
&lt;li&gt;AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次 fsync 操作，最多丢失 1 秒钟的数据。&lt;/li&gt;
&lt;li&gt;AOF 日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。&lt;/li&gt;
&lt;li&gt;AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。&lt;/li&gt;
&lt;li&gt;AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。&lt;br&gt;
比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大&lt;/li&gt;
&lt;li&gt;AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;持久化机制的选择&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#持久化机制的选择&#34;&gt;#&lt;/a&gt; 持久化机制的选择&lt;/h3&gt;
&lt;p&gt;通常情况下我们是二者结合使用的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;RDB&lt;/th&gt;
&lt;th&gt;AOF&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;启动优先级&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;体积&lt;/td&gt;
&lt;td&gt;小&lt;/td&gt;
&lt;td&gt;大&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;恢复速度&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据安全性&lt;/td&gt;
&lt;td&gt;丢数据&lt;/td&gt;
&lt;td&gt;取决于刷盘策略&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;轻重&lt;/td&gt;
&lt;td&gt;重&lt;/td&gt;
&lt;td&gt;轻&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;RDB 使用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据恢复要求不高：如果应用程序可以接受在两次快照之间数据丢失的风险，那么 RDB 是一个很好的选择。&lt;/li&gt;
&lt;li&gt;需要快速恢复大量数据：由于 RDB 文件是一个完整的数据库快照，因此在需要快速恢复大量数据时，RDB 提供了更快的恢复速度。&lt;/li&gt;
&lt;li&gt;定期备份：RDB 适用于需要定期进行完整备份的场景，比如每天一次的全量备份。&lt;/li&gt;
&lt;li&gt;数据归档：RDB 文件可以轻松地传输到远程服务器或存储设备上，用于长期的数据归档或灾难恢复。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AOF 使用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据安全性要求高：如果应用程序不能容忍任何数据丢失，那么 AOF 是更好的选择，因为它可以保证数据的完整性。&lt;/li&gt;
&lt;li&gt;频繁写入操作：对于写密集型的应用场景，AOF 可以更好地保证数据的一致性。&lt;/li&gt;
&lt;li&gt;数据重放：AOF 文件可以用来重放数据，这对于调试和审计非常有用。&lt;/li&gt;
&lt;li&gt;自动修复：Redis 可以定期对 AOF 文件进行重写，以压缩文件大小并移除冗余命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis-的内存调度&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis-的内存调度&#34;&gt;#&lt;/a&gt; Redis 的内存调度&lt;/h2&gt;
&lt;h3 id=&#34;redis-的过期策略&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis-的过期策略&#34;&gt;#&lt;/a&gt; Redis 的过期策略&lt;/h3&gt;
&lt;h4 id=&#34;设置过期时间&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#设置过期时间&#34;&gt;#&lt;/a&gt; 设置过期时间&lt;/h4&gt;
&lt;p&gt;Redis 对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置 key 的有效时间。Expires 字典保存了所有键的过期时间，Expires 也被称为过期字段。&lt;/p&gt;
&lt;p&gt;一般主要包括 5 种处理过期方式，其中 expire 都是以秒为单位，pexpire 都是以毫秒为单位的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EXPIRE key seconds&lt;/code&gt; ：将 key 的生存时间设置为 ttl 秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PEXPIRE key milliseconds&lt;/code&gt; ：将 key 的生成时间设置为 ttl 毫秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXPIREAT key timestamp&lt;/code&gt; ：将 key 的过期时间设置为 timestamp 所代表的的秒数的时间戳&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PEXPIREAT key milliseconds-timestamp&lt;/code&gt; ：将 key 的过期时间设置为 timestamp 所代表的的毫秒数的时间戳&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setex(String key, int seconds, String value)&lt;/code&gt; ：字符串独有的方式，为指定的 key 设置值及其过期时间。如果 key 已经存在，&lt;br&gt;
SETEX 命令将会替换旧的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;timestamp 为 unix 时间戳（例如：timestamp=1499788800 表示将在 2017.07.12 过期）&lt;/li&gt;
&lt;li&gt;1、2 两种方式是设置一个过期的时间段，就是咱们处理验证码最常用的策略，设置三分钟或五分钟后失效，把分钟数转换成秒或毫秒存储到 Redis 中。&lt;/li&gt;
&lt;li&gt;3、4 两种方式是指定一个过期的时间 ，比如优惠券的过期时间是某年某月某日，只是单位不一样。&lt;/li&gt;
&lt;li&gt;如果没有设置时间，那缓存就是永不过期&lt;/li&gt;
&lt;li&gt;如果设置了过期时间，之后又想让缓存永不过期，使用 persist key&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;过期策略&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#过期策略&#34;&gt;#&lt;/a&gt; 过期策略&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定时过期（Active Expiration）&lt;/p&gt;
&lt;p&gt;含义：当一个键设置了过期时间时，Redis 会在键的过期时间到达时立即清除这个键。&lt;/p&gt;
&lt;p&gt;优点：这种方法可以保证内存被尽快释放，过期的键不会占用内存太久。&lt;/p&gt;
&lt;p&gt;缺点：定时过期需要为每个设置了过期时间的键创建一个定时器，这会占用大量的 CPU 资源来处理过期的数据，从而影响 Redis 的响应时间和吞吐量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;被动过期（Lazy Expiration）&lt;/p&gt;
&lt;p&gt;含义：当访问一个键时，Redis 会检查这个键是否已经过期。如果过期，Redis 会删除这个键并返回相应的错误信息给客户端。&lt;/p&gt;
&lt;p&gt;优点：这种方法对 CPU 资源友好，因为它只在访问键时才会检查过期情况。&lt;/p&gt;
&lt;p&gt;缺点：如果过期的键没有被及时访问，那么它将继续占用内存，直到被访问或通过其他方式清理掉为止。&lt;/p&gt;
&lt;p&gt;流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在进行 get 或 setnx 等操作时，先检查 key 是否过期，&lt;/li&gt;
&lt;li&gt;若过期，删除 key，然后执行相应操作；&lt;/li&gt;
&lt;li&gt;若没过期，直接执行相应操作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定期过期（Periodic Reaping）&lt;/p&gt;
&lt;p&gt;含义：Redis 会周期性地检查过期的键，并删除一部分过期的键。这种策略试图在内存消耗和 CPU 使用之间找到一个平衡点，可以通过&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置 redis.conf 的 hz 选项，默认为 10 （即 1 秒执行 10 次，100ms 一次，值越大说明刷新频率越快，对 Redis 性能损耗也越大）&lt;/li&gt;
&lt;li&gt;配置 redis.conf 的 maxmemory 最大值，当已用内存超过 maxmemory 限定时，就会触发主动清理策略。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优点：通过周期性地检查和删除过期键，可以有效地减少内存浪费，同时通过限制删除操作的执行时长和频率来减少对 CPU 时间的影响。&lt;/p&gt;
&lt;p&gt;缺点：难以确定删除操作执行的时长和频率。如果删除操作执行得太频繁或执行的时间太长，定期删除策略就会退化成定时删除，导致占用太多的 CPU 执行时间。如果删除操作执行得太少或执行时间太短，定期删除策略又会类似于被动过期，导致内存浪费。&lt;/p&gt;
&lt;p&gt;流程：其核心是对指定个数个库的每一个库随机删除小于等于指定个数个过期 key：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;遍历每个数据库（就是 redis.conf 中配置的 “database” 数量，默认为 16）；
&lt;ol&gt;
&lt;li&gt;检查当前库中的指定个数个 key （默认是每个库检查 20 个，相当于该循环执行 20 次）：
&lt;ol&gt;
&lt;li&gt;如果当前库中没有一个 key 设置了过期时间，直接执行下一个库的遍历；&lt;/li&gt;
&lt;li&gt;随机获取一个设置了过期时间的 key，检查是否过期，如果过期则删除；&lt;/li&gt;
&lt;li&gt;判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综合策略&lt;/p&gt;
&lt;p&gt;在实际应用中，Redis 通常会结合使用上述三种策略来管理过期键。例如，Redis 可能会使用定期过期作为主要的过期策略，同时辅以被动过期来处理未被定期过期策略捕获的过期键。此外，对于一些关键操作，Redis 可能会采用定时过期来确保某些重要键在过期后能够立即被释放。&lt;/p&gt;
&lt;h4 id=&#34;持久化中的过期&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#持久化中的过期&#34;&gt;#&lt;/a&gt; 持久化中的过期&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RDB 对过期 key 的处理&lt;/p&gt;
&lt;p&gt;过期 key 对 RDB 没有任何影响&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从内存数据库持久化数据到 RDB 文件
&lt;ul&gt;
&lt;li&gt;持久化 key 之前，会检查是否过期，过期的 key 不进入 RDB 文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从 RDB 文件恢复数据到内存数据库
&lt;ul&gt;
&lt;li&gt;数据载入数据库之前，会对 key 先进行过期检查，如果过期，不导入数据库（主库情况）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AOF 对过期 key 的处理&lt;br&gt;
过期 key 对 AOF 没有任何影响&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从内存数据库持久化数据到 AOF 文件：
&lt;ul&gt;
&lt;li&gt;当 key 过期后，还没有被删除，此时进行执行持久化操作（该 key 是不会进入 aof 文件的，因为没有发生修改命令）&lt;/li&gt;
&lt;li&gt;当 key 过期后，在发生删除操作时，程序会向 aof 文件追加一条 del 命令（在将来的以 aof 文件恢复数据的时候该过期的键就会被删掉）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AOF 重写
&lt;ul&gt;
&lt;li&gt;重写时，会先判断 key 是否过期，已过期的 key 不会重写到 aof 文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pipeline&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#pipeline&#34;&gt;#&lt;/a&gt; Pipeline&lt;/h2&gt;
&lt;p&gt;Redis 的 Pipeline 功能允许客户端将多个命令打包成一个请求发送给 Redis 服务器，而不是逐个发送命令。这样做可以显著减少客户端与服务器之间的网络往返次数，从而提高&lt;br&gt;
 Redis 的性能和效率。下面详细介绍 Redis Pipeline 的工作原理、使用场景以及如何使用。&lt;/p&gt;
&lt;p&gt;Pipeline 的工作原理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打包命令：客户端将多个 Redis 命令打包成一个请求，这个请求包含了所有命令的数据。&lt;/li&gt;
&lt;li&gt;发送请求：客户端一次性将打包好的请求发送给 Redis 服务器。&lt;/li&gt;
&lt;li&gt;执行命令：Redis 服务器接收到请求后，依次执行其中的所有命令。&lt;/li&gt;
&lt;li&gt;返回结果：Redis 服务器将各个命令的结果保存起来，并在所有命令执行完毕后，一次性将所有结果返回给客户端。&lt;/li&gt;
&lt;li&gt;处理结果：客户端接收到所有命令的结果后，按顺序处理这些结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Pipeline 的优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少网络延迟：通过减少客户端与服务器之间的网络往返次数，Pipeline 可以显著降低网络延迟，提高整体性能。&lt;/li&gt;
&lt;li&gt;提高吞吐量：由于减少了网络交互次数，客户端可以更快地处理更多的命令。&lt;/li&gt;
&lt;li&gt;事务性操作：虽然 Pipeline 不保证命令执行的原子性，但是它可以模拟事务的行为，即可以将一组命令作为一个整体发送和接收结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;批量操作：当你需要执行一系列相关联的命令时，使用 Pipeline 可以提高效率。&lt;/li&gt;
&lt;li&gt;性能优化：在需要频繁与 Redis 进行交互的应用场景中，使用 Pipeline 可以减少网络开销，提升性能。&lt;/li&gt;
&lt;li&gt;模拟事务：虽然 Redis 的 Pipeline 不保证命令的原子性，但是在不需要严格事务性的场景下，可以使用 Pipeline 来模拟事务行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何使用 Pipeline&lt;br&gt;
 在不同的 Redis 客户端库中，使用 Pipeline 的方式略有不同。以下是在几种常见语言中使用 Pipeline 的示例：&lt;/p&gt;
&lt;p&gt;JavaScript (Node.js)&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; redis = &lt;span class=&#34;built_in&#34;&gt;require&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;redis&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; client = redis.&lt;span class=&#34;title function_&#34;&gt;createClient&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;client.&lt;span class=&#34;title function_&#34;&gt;pipeline&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .&lt;span class=&#34;title function_&#34;&gt;set&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;foo&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;bar&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;foo&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .&lt;span class=&#34;title function_&#34;&gt;exec&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;err, replies&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (err) &lt;span class=&#34;keyword&#34;&gt;throw&lt;/span&gt; err;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(replies); &lt;span class=&#34;comment&#34;&gt;// replies is an array of responses&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Python (redis-py)&lt;/p&gt;
&lt;figure class=&#34;highlight python&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;const redis = require(&lt;span class=&#34;string&#34;&gt;&amp;quot;redis&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;const client = redis.createClient();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;client.pipeline()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  .&lt;span class=&#34;built_in&#34;&gt;set&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;foo&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;bar&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  .get(&lt;span class=&#34;string&#34;&gt;&amp;#x27;foo&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  .&lt;span class=&#34;built_in&#34;&gt;exec&lt;/span&gt;((err, replies) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (err) throw err;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    console.log(replies); // replies &lt;span class=&#34;keyword&#34;&gt;is&lt;/span&gt; an array of responses&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;java (jedis)&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; redis.clients.jedis.Jedis;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Jedis jedis=&lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Jedis&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;localhost&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        Pipeline pipelined=jedis.pipelined();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        pipelined.set(&lt;span class=&#34;string&#34;&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;,&lt;span class=&#34;string&#34;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        pipelined.get(&lt;span class=&#34;string&#34;&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        List&amp;lt;Object&amp;gt; results=pipelined.syncAndReturnAll();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(results);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;span class=&#34;keyword&#34;&gt;finally&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        jedis.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意事项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令数量：虽然 Pipeline 可以显著提高性能，但如果打包的命令数量过多，可能会导致单个请求的体积过大，增加客户端的等待时间，并可能导致网络阻塞。&lt;/li&gt;
&lt;li&gt;命令执行顺序：Pipeline 中的命令是按照发送顺序执行的，因此需要确保命令间的依赖关系不会导致错误。&lt;/li&gt;
&lt;li&gt;错误处理：如果 Pipeline 中的某条命令执行失败，整个 Pipeline 的结果都会受到影响。因此，在处理 Pipeline&lt;br&gt;
 的结果时，需要注意检查每个命令的执行状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原生批命令 (mset, mget) 与 Pipeline 对比&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原生批命令是原子性，pipeline 是非原子性&lt;/li&gt;
&lt;li&gt;原生批命令一命令多个 key, 但 pipeline 支持多命令（存在事务），非原子性&lt;/li&gt;
&lt;li&gt;原生批命令是服务端实现，而 pipeline 需要服务端与客户端共同完成&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis-事务&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis-事务&#34;&gt;#&lt;/a&gt; Redis 事务&lt;/h2&gt;
&lt;p&gt;Redis 事务是 Redis 中的一个重要特性，它允许客户端在一个事务中执行多个命令，并确保这些命令要么全部执行成功，要么全部执行失败。在事务中，客户端可以提交或回滚整个事务，而不需要关心事务中的命令是否成功执行。尽管&lt;br&gt;
 Redis 事务并不提供传统意义上的 ACID 事务特性（原子性、一致性、隔离性、持久性），但它确实提供了一些基本的功能，使得开发者可以更方便地处理一系列相关的命令。&lt;/p&gt;
&lt;p&gt;Redis 事务的主要功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令队列：客户端可以将多个命令放入一个队列中，然后通过 EXEC 命令一次性发送给 Redis 服务器执行。&lt;/li&gt;
&lt;li&gt;监视（WATCH）：客户端可以监视一个或多个键，如果在执行 EXEC 命令之前这些键被其他客户端修改，则事务会被取消。&lt;/li&gt;
&lt;li&gt;取消（DISCARD）：如果在事务执行之前发现某些条件不满足，客户端可以选择取消事务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redis 事务的实现分为几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务开始：客户端通过 MULTI 命令开始一个事务。&lt;/li&gt;
&lt;li&gt;命令入队：在 MULTI 命令之后，客户端可以发送任意数量的命令，这些命令将被放入事务队列中，但不会立即执行。&lt;/li&gt;
&lt;li&gt;事务执行：通过 EXEC 命令，客户端可以执行事务队列中的所有命令。如果在此之前使用了 WATCH 命令监视的键被修改，则事务会被取消。&lt;/li&gt;
&lt;li&gt;取消事务：如果在执行 EXEC 命令之前，客户端想要取消事务，可以使用 DISCARD 命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redis 中事务的特性有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性：一旦事务开始执行，Redis 会保证事务中的所有命令要么全部执行成功，要么都不执行。然而，如果命令在执行过程中出现错误（如类型错误），Redis&lt;br&gt;
 会继续执行后续命令。&lt;/li&gt;
&lt;li&gt;一致性：Redis 事务在一定程度上保证了一致性，特别是通过使用 WATCH 命令监视键的变化，可以防止脏读。&lt;/li&gt;
&lt;li&gt;隔离性：由于 Redis 是单线程的，事务中的命令会按顺序执行，因此不存在并发事务之间的隔离性问题。&lt;/li&gt;
&lt;li&gt;持久性：Redis 的持久化机制（如 RDB 或 AOF）保证了数据的持久性，但这与事务无关。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redis 事务的限制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不支持回滚：如果事务中的某个命令失败，Redis 会继续执行剩余的命令，并不会回滚之前的命令。&lt;/li&gt;
&lt;li&gt;错误处理：如果事务中的命令出现错误，Redis 会记录错误并继续执行后续命令。客户端需要处理这些错误。&lt;/li&gt;
&lt;li&gt;性能考虑：虽然事务可以减少网络往返次数，但如果事务中的命令数量过多，可能会导致单个请求过大，反而影响性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redis 事务的使用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;批量操作：当需要执行一系列相关的命令时，可以使用事务来减少网络往返次数，提高性能。&lt;/li&gt;
&lt;li&gt;乐观锁：通过 WATCH 命令监视键的变化，可以实现乐观锁机制，确保在执行事务之前键没有被其他客户端修改。&lt;/li&gt;
&lt;li&gt;模拟事务：虽然 Redis 事务不提供严格的 ACID 特性，但在不需要强一致性的场景下，可以使用事务来模拟事务行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis-多线程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis-多线程&#34;&gt;#&lt;/a&gt; Redis 多线程&lt;/h2&gt;
&lt;p&gt;Redis 作为一种高性能的键值存储系统，最初是单线程设计的，这意味着 Redis 在处理客户端的请求时，包括获取 (socket 读)&lt;br&gt;
、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的单线程。但如果严格来讲从 Redis 4&lt;br&gt;
 之后并不是单线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 key 的删除等等。&lt;br&gt;
这样的设计保证了数据的一致性和简单性，但也限制了 Redis 在多核 CPU 环境下的性能潜力。从 Redis 6.0 开始，Redis&lt;br&gt;
 引入了多线程的支持，以充分利用现代多核处理器的优势。&lt;/p&gt;
&lt;p&gt;Redis 6 为何引入多线程？&lt;/p&gt;
&lt;p&gt;随着目前行业内越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的&lt;br&gt;
 QPS。常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;要管理的 Redis 服务器太多，维护代价大；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;某些适用于单个 Redis 服务器的命令不适用于数据分区；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据分区无法解决热点读 / 写问题；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据偏斜，重新分配和放大 / 缩小变得更加复杂等等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从 Redis 自身角度来说，因为读写网络的 read/write 系统调用占用了 Redis 执行期间大部分 CPU 时间，瓶颈主要在于网络的 IO 消耗，&lt;br&gt;
 优化主要有两个方向:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用多线程充分利用多核，典型的实现比如 Memcached。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;协议栈优化的这种方式跟 Redis 关系不大，支持多线程是一种最有效最便捷的操作方式。所以总结起来，Redis 支持多线程主要就是两个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以充分利用服务器 CPU 资源，目前主线程只能利用一个核；&lt;/li&gt;
&lt;li&gt;多线程任务可以分摊 Redis 同步 IO 读写负荷。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redis 多线程的工作原理&lt;/p&gt;
&lt;p&gt;在 Redis 6.0 中，多线程主要用于处理客户端的网络 I/O 操作，包括读取客户端请求、解析请求以及将响应写回到客户端。具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多线程 I/O：Redis 在主线程之外创建了若干个 I/O 子线程，这些子线程负责读取客户端的请求数据，并将其传递给主线程进行处理。主线程处理完请求后，子线程再负责将响应写回到客户端。&lt;/li&gt;
&lt;li&gt;命令执行：尽管引入了多线程，Redis 的命令执行仍然是单线程的。这意味着 Redis 仍然保证了数据的一致性，因为所有命令都在同一个线程中顺序执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置多线程&lt;/p&gt;
&lt;p&gt;Redis 6.0 中的多线程支持需要在 redis.conf 文件中进行配置。Redis 6 的多线程默认是禁用的，只使用主线程。可以通过设置&lt;br&gt;
 io-threads-do-reads 参数来启用多线程 I/O 支持，并指定子线程的数量。&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;io-threads 4  # 设置子线程的数量&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;io-threads-do-reads yes  # 启用子线程读取&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;官方建议线程数应小于机器的核数，并且给出了一个简单的指导原则：对于 4 核的机器，建议设置 2 或 3 个线程；对于 8 核的机器，建议设置&lt;br&gt;
 6 个线程。线程数并不是越多越好，一般超过 8 个线程就没有太多的意义了。&lt;/p&gt;
&lt;p&gt;使用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络 I/O 密集型操作：当 Redis 实例面临大量的网络 I/O 负载时，多线程可以帮助减轻主线程的压力，提高系统的整体吞吐量。&lt;/li&gt;
&lt;li&gt;多核 CPU 利用率：在多核处理器环境下，多线程可以让 Redis 更好地利用硬件资源，特别是在处理高并发请求时。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意事项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单线程命令执行：尽管 Redis 引入了多线程支持，但命令的执行仍然是单线程的。这意味着 Redis 依然保证了数据的一致性和事务的安全性。&lt;/li&gt;
&lt;li&gt;适用性：多线程功能最适合在网络 I/O 成为性能瓶颈的情况下使用。如果 Redis 实例的 CPU 占用率已经很高，那么开启多线程可能并不会带来显著的性能提升。&lt;/li&gt;
&lt;li&gt;兼容性：在 Redis 的其他模式（如集群模式）中，多线程功能可能不完全适用，因此在使用时需要谨慎。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis-集群&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis-集群&#34;&gt;#&lt;/a&gt; Redis 集群&lt;/h2&gt;
&lt;h3 id=&#34;redis-主从&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis-主从&#34;&gt;#&lt;/a&gt; Redis 主从&lt;/h3&gt;
&lt;p&gt;和 MySQL 需要主从复制的原因一样，Redis 虽然读取写入的速度都特别快，但是也会产生性能瓶颈，特别是在读压力上，为了分担压力，Redis 支持主从复制。&lt;br&gt;
Redis 的主从结构包括一主一从，一主多从或级联结构，复制类型分为全量同步和增量同步。&lt;br&gt;
下图为级联结构：&lt;/p&gt;
&lt;img data-src=&#34;/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1557639147418-27b8b69d-f0a8-4ec0-a771-99c43783190d.png&#34; class=&#34;&#34; title=&#34;1557639147418-27b8b69d-f0a8-4ec0-a771-99c43783190d.png&#34;&gt;
&lt;h4 id=&#34;全量同步&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#全量同步&#34;&gt;#&lt;/a&gt; 全量同步&lt;/h4&gt;
&lt;p&gt;Redis 全量复制一般发生在 slave 的初始阶段，这时 slave 需要将 master 上的数据都复制一份，具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;slave 连接 master，发送 SYNC 命令；&lt;/li&gt;
&lt;li&gt;master 街道 SYNC 命令后，执行 BGSAVE 命令生产 RDB 文件并使用缓冲区记录此后执行的所有写命令；&lt;/li&gt;
&lt;li&gt;master 的 BGSAVE 执行完成后，向所有的 slave 发送快照文件，并在发送过程中继续记录执行的写命令；&lt;/li&gt;
&lt;li&gt;slave 收到快照后，丢弃所有的旧数据，载入收到的数据；&lt;/li&gt;
&lt;li&gt;master 快照发送完成后就会开始向 slave 发送缓冲区的写命令；&lt;/li&gt;
&lt;li&gt;slave 完成对快照的载入，并开始接受命令请求，执行来自 master 缓冲区的写命令；&lt;/li&gt;
&lt;li&gt;slave 完成上面的数据初始化后就可以开始接受用户的读请求了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大致流程图如下：&lt;/p&gt;
&lt;img data-src=&#34;/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1557639652986-bfbcd0af-6688-4047-83df-8f3bea5d0875.png&#34; class=&#34;&#34; title=&#34;1557639652986-bfbcd0af-6688-4047-83df-8f3bea5d0875.png&#34;&gt;
&lt;h4 id=&#34;增量复制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#增量复制&#34;&gt;#&lt;/a&gt; 增量复制&lt;/h4&gt;
&lt;p&gt;增量复制实际上就是在 slave 初始化完成后开始正常工作时 master 发生写操作同步到 slave 的过程。增量复制的具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主节点记录复制偏移量：&lt;br&gt;
在全量复制完成后，主节点开始记录其发送给从节点的所有写命令，并维护一个复制偏移量（replication&lt;br&gt;
offset），这个偏移量表示了主节点已发送了多少字节的数据给从节点。&lt;/li&gt;
&lt;li&gt;从节点记录复制偏移量：&lt;br&gt;
同时，从节点也会记录接收到的命令及其对应的偏移量。这使得从节点能够知道它已经处理了多少数据。&lt;/li&gt;
&lt;li&gt;主节点维护积压队列：&lt;br&gt;
为了支持增量复制，主节点会维护一个 “积压队列”（backlog）。这是一个固定大小的环形缓冲区，用来存储最近的写入命令。这样即使从节点暂时断开连接，也能在重新连接后获取到断开期间丢失的数据。&lt;/li&gt;
&lt;li&gt;从节点请求增量数据：&lt;br&gt;
当从节点重新连接到主节点时，它会发送一个 PSYNC 命令，附带它最后已知的复制偏移量和主节点的运行 ID（run&lt;br&gt;
ID）。主节点会检查这个信息，并决定是否进行增量复制。&lt;/li&gt;
&lt;li&gt;增量复制：
&lt;ul&gt;
&lt;li&gt;如果主节点发现从节点提供的偏移量在积压队列的有效范围内，则主节点会从该偏移量开始向从节点发送所有后续的写命令，这就是增量复制。&lt;/li&gt;
&lt;li&gt;如果偏移量不在有效范围内，或者从节点提供的运行 ID 与主节点当前的运行 ID 不符（可能是因为主节点重启过），那么主节点会选择进行一次全量复制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从节点应用增量数据：&lt;br&gt;
从节点接收到增量数据后，会将其应用到自己的数据集上，使自己的数据与主节点保持一致。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Redis 主从同步的特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用异步复制；&lt;/li&gt;
&lt;li&gt;可以一主多从；&lt;/li&gt;
&lt;li&gt;主从复制对于 master 来说是非阻塞的，也就是说 slave 在进行主从复制的过程中，master 依然可以处理请求；&lt;/li&gt;
&lt;li&gt;主从复制对于 slave 来说也是非阻塞的，也就是说 slave 在进行主从复制的过程中也可以接受外界的查询请求，只不过这时候返回的数据不一定是正确的。为了避免这种情况发生，可以在 slave 的配置文件中配置，在同步过程中阻止查询；&lt;/li&gt;
&lt;li&gt;每个 slave 可以接受来自其他 slave 的连接；&lt;/li&gt;
&lt;li&gt;主从复制提高了 Redis 服务的扩展性，避免单节点问题，另外也为数据备份冗余提供了一种解决方案；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了降低主 redis 服务器写磁盘压力带来的开销，可以配置让主 redis 不在将数据持久化到磁盘，而是通过连接让一个配置的从 redis 服务器及时的将相关数据持久化到磁盘，不过这样会存在一个问题，就是主 redis 服务器一旦重启，因为主 redis 服务器数据为空，这时候通过主从同步可能导致从 redis 服务器上的数据也被清空；&lt;/p&gt;
&lt;h4 id=&#34;redis主从复制搭建&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis主从复制搭建&#34;&gt;#&lt;/a&gt; Redis 主从复制搭建&lt;/h4&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;51&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;下载软件包&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;wget http://download.redis.io/releases/redis-4.0.10.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;解压软件包，主从都需要做（本次是单机多实例来做主从）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;tar xf redis-4.0.10.tar.gz -C /home/redis/6379/&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;tar xf redis-4.0.10.tar.gz -C /home/redis/6380/&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;编译安装&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;yum install -y gcc gcc++&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;make MALLOC=libc&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;启动Redis（修改了Redis运行方式为守护进程方式）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;/home/redis/6379/redis-4.0.10/src/redis-server /home/redis/6379/redis-4.0.10/redis.conf&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;从库做相同的操作，由于是单机多实例，所以修改从库的port为6380，启动从库&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;/home/redis/6380/redis-4.0.10/src/redis-server /home/redis/6380/redis-4.0.10/redis.conf&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;Redis测试&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;master：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;./src/redis-cli&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;127.0.0.1:6379&amp;gt; set name 111&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;OK&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;127.0.0.1:6379&amp;gt; get name&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;quot;111&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;slave：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;./src/redis-cli -p 6380&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;127.0.0.1:6380&amp;gt; set name slave&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;OK&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;127.0.0.1:6380&amp;gt; get name&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;quot;slave&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;主从搭建&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;1、只需要配置slave，指明master的IP地址和port就可以了，配置完后重启实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;slaveof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;slaveof 127.0.0.1 6379&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;测试：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;master：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;./src/redis-cli&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;127.0.0.1:6379&amp;gt; set password 123456&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;OK&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;127.0.0.1:6379&amp;gt; get password&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;quot;123456&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;slave：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;./src/redis-cli -p 6380&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;127.0.0.1:6380&amp;gt; get password&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;quot;123456&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;在master上设定键值对，在slave上能够准确的查出来，主从配置成功&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;redis-哨兵&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis-哨兵&#34;&gt;#&lt;/a&gt; Redis 哨兵&lt;/h3&gt;
&lt;p&gt;在主从复制实现之后，如果想对 master 进行监控，Redis 提供了一种哨兵机制，哨兵的含义就是监控 Redis 系统的运行状态，并做相应的响应。&lt;/p&gt;
&lt;p&gt;其主要的功能有以下两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;监控所有 Redis 节点是否正常运行；&lt;/li&gt;
&lt;li&gt;master 故障后可以通过投票机制，从 slave 中选举出新的 master，保证集群正常运行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在一个一主多从的集群中，可以启用多个哨兵进行监控以保证集群足够稳健，这种情况下，哨兵不仅监控主从服务，哨兵之间也会相互监控，建议哨兵至少 3 个并且是奇数。&lt;/p&gt;
&lt;p&gt;哨兵主要用于管理多个 Redis 服务器，主要有以下三个任务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;监控：哨兵会不断的检测 master 和 slave 之间是否运行正常；&lt;/li&gt;
&lt;li&gt;提醒：当监控的某个 Redis 出现问题，哨兵可以通过 API 向管理员或其他应用程序发送通知；&lt;/li&gt;
&lt;li&gt;故障迁移：当一个 master 不能正常工作时，哨兵会开始一次自动故障迁移操作，它会将失效 master 的其中一个 slave 提升为 master，并让失效 master 和其他 slave 该为复制新的 master。&lt;br&gt;
当客户端试图连接失效的 master 时，集群也会向客户端返回新的 master 地址，使得集群可以使用新的 master 代替失效的 master。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;redis-哨兵的工作原理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis-哨兵的工作原理&#34;&gt;#&lt;/a&gt; Redis 哨兵的工作原理&lt;/h4&gt;
&lt;p&gt;Redis 哨兵（Sentinel）是一个分布式系统，用于监控 Redis 主节点和从节点的健康状况，并在主节点发生故障时自动进行故障转移。&lt;br&gt;
哨兵系统由一组哨兵进程组成，它们相互协作来完成监控、通知、选举以及故障转移的任务。下面详细介绍哨兵的工作原理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;监控（Monitoring）
&lt;ul&gt;
&lt;li&gt;心跳检测：每个哨兵（Sentinel）会定期向主节点、从节点以及其他哨兵发送心跳消息，以此来监控这些节点的健康状况。&lt;/li&gt;
&lt;li&gt;配置文件：哨兵的配置文件中定义了需要监控的主节点的信息，包括名称、IP 地址和端口号等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选举（Election）
&lt;ul&gt;
&lt;li&gt;选举机制：当某个哨兵发现主节点不可用时，它会向其他哨兵发起询问，以确认主节点是否真的出现了故障。&lt;/li&gt;
&lt;li&gt;投票过程：每个哨兵都有机会投票选出一个领导者（leader），领导者负责执行实际的故障转移操作。&lt;/li&gt;
&lt;li&gt;多数原则：为了防止脑裂现象（Split-brain 指的是系统的一部分节点认为另一部分节点已经失败，而实际上那些被认为失败的节点仍在正常工作。），哨兵系统采用多数原则来决定是否进行故障转移。&lt;br&gt;
只有当超过半数的哨兵同意主节点已经失效时，才会执行故障转移。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;故障转移（Failover）
&lt;ul&gt;
&lt;li&gt;选择从节点：一旦确定主节点失效，领导者哨兵会选择一个合适的从节点来升级为主节点。&lt;/li&gt;
&lt;li&gt;数据同步：被选中的从节点会被提升为主节点，并且其他从节点会重新连接到新的主节点。&lt;/li&gt;
&lt;li&gt;客户端通知：完成故障转移后，哨兵会更新客户端的配置文件，使客户端能够连接到新的主节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;配置更新（Configuration Updates）
&lt;ul&gt;
&lt;li&gt;自动配置更新：哨引不仅会更新客户端的配置文件，还会自动更新从节点的配置，使它们指向新的主节点。&lt;/li&gt;
&lt;li&gt;持续监控：故障转移完成后，哨兵将继续监控新的主节点和从节点的健康状况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;客户端通知
&lt;ul&gt;
&lt;li&gt;通知机制：哨兵会通知客户端新的主节点地址，以便客户端可以继续正常工作。&lt;/li&gt;
&lt;li&gt;透明切换：这一过程对客户端来说应该是透明的，即客户端不需要做任何额外的操作即可继续访问 Redis 服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实现细节如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哨兵通信：哨兵之间通过发布 / 订阅模式进行通信，确保所有哨兵都能及时了解系统状态的变化。&lt;/li&gt;
&lt;li&gt;命令交互：哨兵使用特定的命令（如 SENTINEL 命令）来查询和管理哨兵系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主从服务器的数据要经常进行主从复制，这样会造成性能下降；&lt;/li&gt;
&lt;li&gt;当主服务器宕机后，从服务器切换成主服务器的那段时间，服务是不可用的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;redis哨兵模式搭建&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis哨兵模式搭建&#34;&gt;#&lt;/a&gt; Redis 哨兵模式搭建&lt;/h4&gt;
&lt;p&gt;主从模式搭建看上面的步骤，以下主要是在主从搭建完的基础上搭建哨兵模式。&lt;/p&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;79&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;配置sentinel.conf文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;工作路径，注意路径不要和主重复&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;dir &amp;quot;/tmp/23679&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;哨兵监控的master，主从配置一样，这里只用输入redis主节点的ip/port和法定人数。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;sentinel monitor mymaster 192.168.125.128 6379 1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;master或slave多长时间（默认30秒）不能使用后标记为s_down状态。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;sentinel down-after-milliseconds mymaster 5000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;若sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换），则认为本次failover失败。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;sentinel failover-timeout mymaster 18000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步，有几个slave就设置几个&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;sentinel parallel-syncs mymaster 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;启动哨兵&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;/home/redis/26379/redis-4.0.10/src/redis-server /home/redis/26379/redis-4.0.10/sentinel.conf --sentinel&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;通过哨兵查看集群状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;./src/redis-cli -p 26379&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;127.0.0.1:26379&amp;gt; sentinel master mymaster&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;1) &amp;quot;name&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2) &amp;quot;mymaster&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3) &amp;quot;ip&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4) &amp;quot;172.16.0.169&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5) &amp;quot;port&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6) &amp;quot;6379&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7) &amp;quot;runid&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;127.0.0.1:26379&amp;gt; sentinel slaves mymaster&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;1)  1) &amp;quot;name&amp;quot;                                           # slave 1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    2) &amp;quot;127.0.0.1:6381&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    3) &amp;quot;ip&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    4) &amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    5) &amp;quot;port&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    6) &amp;quot;6381&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    7) &amp;quot;runid&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    8) &amp;quot;0419f313098f6af1b4ccdb189d6beb22edf27a1c&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2)  1) &amp;quot;name&amp;quot;                                            # slave2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    2) &amp;quot;127.0.0.1:6380&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    3) &amp;quot;ip&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    4) &amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    5) &amp;quot;port&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    6) &amp;quot;6380&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    7) &amp;quot;runid&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    8) &amp;quot;5b00b502a93245f7916efd1f564bd40b16aa7b22&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;模拟主down掉&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;观察sentinel的状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;127.0.0.1:26379&amp;gt; sentinel master mymaster&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;1) &amp;quot;name&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2) &amp;quot;mymaster&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3) &amp;quot;ip&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4) &amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5) &amp;quot;port&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6) &amp;quot;6381&amp;quot;                # 已经从6379切换到6381&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7) &amp;quot;runid&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8) &amp;quot;0419f313098f6af1b4ccdb189d6beb22edf27a1c&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;相应的slave也做了切换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;127.0.0.1:26379&amp;gt; sentinel slaves mymaster&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;1)  1) &amp;quot;name&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    2) &amp;quot;127.0.0.1:6379&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    3) &amp;quot;ip&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    4) &amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    5) &amp;quot;port&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    6) &amp;quot;6379&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    7) &amp;quot;runid&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    8) &amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    9) &amp;quot;flags&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   10) &amp;quot;s_down,slave,disconnected&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2)  1) &amp;quot;name&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    2) &amp;quot;127.0.0.1:6380&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    3) &amp;quot;ip&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    4) &amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    5) &amp;quot;port&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    6) &amp;quot;6380&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    7) &amp;quot;runid&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    8) &amp;quot;5b00b502a93245f7916efd1f564bd40b16aa7b22&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;redis集群&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis集群&#34;&gt;#&lt;/a&gt; Redis 集群&lt;/h3&gt;
&lt;p&gt;Redis 在 3.0 版本开始正式引入集群特性。Redis 集群是一个分布式，高容错的内存 K/V 系统，集群可以使用的功能是普通单机 Redis 所使用的功能的一个子集。比如，Redis 集群并不支持处理多个 keys 的命令，因为这需要在不同节点间移动数据，从而达不到像 Redis 那样的性能，在高负载的情况下可能会出现无法预估的错误。&lt;/p&gt;
&lt;p&gt;Redis 集群有以下几个重要的特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Redis 集群的分片特征在于将空间拆分为 16384 个槽位，某一个节点负责其中一些槽位；&lt;/li&gt;
&lt;li&gt;Redis 集群提供一定程度的可用性，可以在某个节点宕机或者不可达的情况继续处理命令；&lt;/li&gt;
&lt;li&gt;Redis 集群不存在中心节点或代理节点，集群的其中一个最重要的设计目标是达到线性可扩展性；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其架构如下：&lt;/p&gt;
&lt;img data-src=&#34;/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1557644289413-437c9a81-dcb1-40bc-8549-2a4867b797c2.png&#34; class=&#34;&#34; title=&#34;1557644289413-437c9a81-dcb1-40bc-8549-2a4867b797c2.png&#34;&gt;
&lt;p&gt;其中每一个圆代表一个节点，任何两个节点是互通的，可以归纳以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有的节点相互连接；&lt;/li&gt;
&lt;li&gt;集群消息通信通过集群总线通信，，集群总线端口大小为客户端服务端口 + 10000，这个 10000 是固定值；&lt;/li&gt;
&lt;li&gt;节点与节点之间通过二进制协议进行通信；&lt;/li&gt;
&lt;li&gt;客户端和集群节点之间通信和通常一样，通过文本协议进行；&lt;/li&gt;
&lt;li&gt;集群节点不会代理查询；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;redis集群的原理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis集群的原理&#34;&gt;#&lt;/a&gt; Redis 集群的原理&lt;/h4&gt;
&lt;p&gt;Redis 集群是一种分布式存储解决方案，旨在通过数据分片和复制来实现高可用性和可扩展性。以下是 Redis 集群的详细运行原理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;哈希槽（Hash Slots）&lt;br&gt;
Redis 集群中有一个长度为 16384 的哈希槽列表，编号为 0 到 16383。这些哈希槽是虚拟的，并不是真实存在的物理实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希计算：当一个键（Key）被存储时，Redis 会计算该键的哈希值，并将哈希值映射到 0 到 16383 之间的某个哈希槽上。&lt;br&gt;
具体映射公式为：slot = CRC16 (key) mod 16384，其中 CRC16 是一个循环冗余校验算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据分片&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;槽分配：集群中的每个 Master 节点负责一部分哈希槽。例如，如果集群中有 3 个 Master 节点，它们可能会分别负责以下槽范围：
&lt;ul&gt;
&lt;li&gt;Master 1: 槽 0-5461&lt;/li&gt;
&lt;li&gt;Master 2: 槽 5462-10923&lt;/li&gt;
&lt;li&gt;Master 3: 槽 10924-16383&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;键的分配：每个键根据其哈希值被分配到相应的槽上，进而确定存储在哪个 Master 节点上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里值得一提的是，在 Redis Cluster 中，只有 Master 才拥有槽的所有权。如果是某个 Master 的 slave，这个 slave 只负责槽的使用，但是没有所有权。&lt;br&gt;
槽与节点结构如下所示：&lt;/p&gt;
&lt;img data-src=&#34;/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1557644627263-0159f2b0-f9ff-46d6-acd3-abc6a22d8e87.png&#34; class=&#34;&#34; title=&#34;1557644627263-0159f2b0-f9ff-46d6-acd3-abc6a22d8e87.png&#34;&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主从复制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主节点（Master）：每个 Master 节点负责处理写操作，并拥有槽的所有权。&lt;/li&gt;
&lt;li&gt;从节点（Slave）：每个 Master 节点可以有多个从节点，从节点负责处理读操作，并作为 Master 节点的备份。&lt;/li&gt;
&lt;li&gt;数据同步：从节点通过复制机制与 Master 节点保持数据一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;故障转移&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动故障转移：当一个 Master 节点失效时，集群会自动选择一个从节点提升为主节点，以保持集群的服务可用性。&lt;/li&gt;
&lt;li&gt;选举机制：集群中的其他节点会通过 Gossip 协议来协商并选举一个新的 Master 节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集群间的通信&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gossip 协议：Redis 集群使用 Gossip 协议来交换节点状态信息。每个节点周期性地与其他节点交换信息，以了解集群中其他节点的状态。&lt;/li&gt;
&lt;li&gt;状态同步：通过 Gossip 协议，节点可以得知集群中的其他节点是否在线、是否有新的节点加入等信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命令路由&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端路由：客户端可以连接到任何一个节点，集群内部会根据键的哈希值来确定该键所在的节点，并将请求路由到正确的节点。&lt;/li&gt;
&lt;li&gt;命令转发：如果客户端请求的键不在当前节点上，那么该节点会将请求转发到正确的节点上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化与配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化脚本：使用 redis-trib.rb 脚本来初始化集群。该脚本会自动分配槽到各个 Master 节点，并配置从节点。&lt;/li&gt;
&lt;li&gt;配置文件：每个节点的配置文件中需要指定集群模式和其他相关参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;投票机制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;投票过程：集群中所有 Master 节点参与投票。如果超过半数的 Master 节点与某个 Master 节点通信超时（cluster-node-timeout），则认为该&lt;br&gt;
 Master 节点已挂掉。&lt;/li&gt;
&lt;li&gt;集群不可用状态：
&lt;ul&gt;
&lt;li&gt;单个 Master 挂掉：如果某个 Master 节点挂掉，并且没有从节点，集群进入 fail 状态。&lt;/li&gt;
&lt;li&gt;多数 Master 挂掉：如果超过半数的 Master 节点挂掉，无论是否有从节点，集群也进入 fail 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;投票机制原理图如下：&lt;/p&gt;
&lt;img data-src=&#34;/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1557645005629-3f876a67-45ec-4285-8821-3ebf42dd4345.png&#34; class=&#34;&#34; title=&#34;1557645005629-3f876a67-45ec-4285-8821-3ebf42dd4345.png&#34;&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;redis集群搭建&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis集群搭建&#34;&gt;#&lt;/a&gt; Redis 集群搭建&lt;/h4&gt;
&lt;p&gt;要求：至少 6 个节点，3 主 3 从。&lt;/p&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;45&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;Redis.conf配置：大致如下&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;port 7000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;cluster-enabled &lt;span class=&#34;built_in&#34;&gt;yes&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;cluster-config-file nodes.conf&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;cluster-node-timeout 5000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;appendonly &lt;span class=&#34;built_in&#34;&gt;yes&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;创建集群&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;redis集群的命令工具redis-trib可以让我们创建集群变得非常简单。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;redis-trib是一个用ruby写的脚本，用于给各节点发指令创建集群、检查集群状态或给集群重新分片等。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;redis-trib在Redis源码的src目录下，需要gem redis来运行redis-trib。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;安装ruby环境&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;yum install rubygems -y&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;1.安装curl&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;sudo yum install curl&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;2. 安装RVM&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;curl -L get.rvm.io | bash -s stable &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;3.&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;source /usr/local/rvm/scripts/rvm&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;4. 查看rvm库中已知的ruby版本&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;rvm list known&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;5. 安装一个ruby版本&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;rvm install 2.3.3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;6. 使用一个ruby版本&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;rvm use 2.3.3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;7. 设置默认版本&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;rvm remove 2.0.0&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;8. 卸载一个已知版本&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ruby --version&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;9. 再安装redis就可以了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;gem install redis&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;启动集群&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;# &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;测试集群&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7000/redis-4.0.10/src/redis-cli -c -p 7000&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;127.0.0.1:7000&amp;gt; set name alex&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta prompt_&#34;&gt;-&amp;gt; &lt;/span&gt;&lt;span class=&#34;language-bash&#34;&gt;Redirected to slot [5798] located at 127.0.0.1:7001&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;OK&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;127.0.0.1:7001&amp;gt; get name&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;quot;alex&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&#34;redis集群迁移&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis集群迁移&#34;&gt;#&lt;/a&gt; Redis 集群迁移&lt;/h4&gt;
&lt;p&gt;Redis 集群迁移是指将现有的 Redis 集群中的数据移动到另一个集群或新的硬件环境中的过程。&lt;br&gt;
这种迁移可能是因为需要扩大容量、更换硬件、迁移至新的数据中心或云平台等原因。迁移过程中需要考虑数据的一致性、服务的连续性以及最小化对现有业务的影响。&lt;br&gt;
迁移方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 RDB 或 AOF 文件进行离线迁移&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RDB 方式：停止集群服务，执行 bgsave 命令生成 RDB 快照文件，然后将 RDB 文件复制到新的集群中，并重启服务。&lt;/li&gt;
&lt;li&gt;AOF 方式：暂停写服务，将 AOF 文件导出到新的 Redis 集群中完成数据迁移。&lt;br&gt;
这种方式简单直接，但会导致服务中断一段时间，并且适用于数据量不大或能接受短暂服务中断的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 Redis-Shake 进行在线迁移&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis-Shake：这是一个开源工具，专为在线迁移设计，可以在不停止服务的情况下迁移数据。&lt;br&gt;
Redis-Shake 支持多种迁移场景，包括 Redis 集群之间的数据迁移。&lt;/li&gt;
&lt;li&gt;实时迁移：在迁移过程中，Redis-Shake 会持续同步源集群和目标集群之间的数据变化，以保证数据的一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种方式可以减少服务中断的时间，适合于数据量大且要求服务连续性的场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用 Sentinel 或其他工具进行故障转移式迁移&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用 Sentinel：如果当前集群启用了 Sentinel，可以先将数据复制到新集群中，然后通过 Sentinel 触发故障转移，将流量逐渐转移到新集群。&lt;/li&gt;
&lt;li&gt;逐步迁移：这种方式可以在不影响现有服务的情况下，逐步将数据和服务转移到新的集群中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种方式适合于已经有 Sentinel 架构的场景，并且可以灵活控制迁移的节奏。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;迁移步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准备阶段
&lt;ol&gt;
&lt;li&gt;评估迁移需求：明确迁移的目的地、迁移的规模、时间窗口等。&lt;/li&gt;
&lt;li&gt;备份现有集群：在迁移前对现有集群进行全量备份，以防迁移失败需要回滚。&lt;/li&gt;
&lt;li&gt;准备新集群：搭建新集群环境，包括硬件准备、软件安装、网络配置等。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;执行阶段
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据同步：根据选择的方法，开始数据同步或迁移。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果使用 Redis-Shake，启动迁移工具并配置源集群和目标集群的信息。&lt;/li&gt;
&lt;li&gt;如果使用 RDB 或 AOF，执行必要的命令生成快照文件，并将其导入到新集群。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验证数据一致性：在迁移完成后，检查新集群的数据完整性，确保没有数据丢失或损坏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换流量：当数据迁移完成并且验证无误后，开始将客户端流量切换到新集群。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;后期阶段
&lt;ol&gt;
&lt;li&gt;监控与优化：迁移完成后，持续监控新集群的性能指标，确保一切正常。&lt;/li&gt;
&lt;li&gt;清理旧集群：如果不再需要旧集群，可以安全地卸载或关闭旧集群的相关资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意事项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;迁移窗口：尽量选择业务低谷时段进行迁移，以减少对业务的影响。&lt;/li&gt;
&lt;li&gt;数据一致性：确保在整个迁移过程中数据的一致性，尤其是在实时迁移过程中。&lt;/li&gt;
&lt;li&gt;测试验证：在正式迁移之前，最好在一个测试环境中模拟迁移过程，确保迁移脚本和工具的正确性。&lt;/li&gt;
&lt;li&gt;回滚计划：准备好回滚计划，以便在迁移过程中出现问题时能够迅速恢复到迁移前的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常见面试问题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#常见面试问题&#34;&gt;#&lt;/a&gt; 常见面试问题&lt;/h2&gt;
&lt;h3 id=&#34;redis-为何这么快&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis-为何这么快&#34;&gt;#&lt;/a&gt; Redis 为何这么快&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;内存存储：Redis 将所有数据存储在内存中，而不是磁盘上。内存的读写速度远超磁盘，这使得 Redis 能够实现极低的延迟和高吞吐量。内存中的数据访问速度几乎是瞬时的，而磁盘则需要等待机械臂移动到正确的位置才能开始读写，这大大降低了速度。&lt;/li&gt;
&lt;li&gt;高效的数据结构：Redis 提供了多种高效的数据结构，如跳跃表（skiplist）用于实现有序集合（Sorted&lt;br&gt;
Set），压缩列表（ziplist）用于节省空间，哈希表（hashtable）用于实现散列（Hash）等。这些数据结构经过优化，能够在内存中高效地存储和检索数据。&lt;/li&gt;
&lt;li&gt;合理的数据编码：Redis 根据数据的不同类型和大小，使用不同的编码格式来存储数据。例如，短字符串可能会使用更为紧凑的编码方式，从而减少内存占用并加快处理速度。&lt;/li&gt;
&lt;li&gt;单线程模型：Redis 采用单线程模型来处理客户端的所有请求。这意味着在任何给定的时间内，只有一个客户端请求正在被执行。虽然这限制了并发处理能力，但也消除了多线程之间上下文切换和锁的竞争，从而减少了不必要的开销。&lt;/li&gt;
&lt;li&gt;非阻塞 I/O：Redis 使用事件驱动模型来处理客户端连接和请求。它使用了类似于 epoll 的 I/O 多路复用技术来监听多个客户端连接上的事件，&lt;br&gt;
当有事件发生时（例如，客户端发送了一个命令），Redis 会立即处理这个事件。这种方式使得 Redis 可以同时处理大量的客户端连接，而不会因为一个客户端的阻塞而影响其他客户端的响应速度。&lt;/li&gt;
&lt;li&gt;异步持久化：为了防止持久化操作影响 Redis 的性能，Redis 提供了异步持久化选项。例如，RDB 快照和 AOF 日志都可以在后台进程执行，不会阻塞主线程处理客户端请求。&lt;/li&gt;
&lt;li&gt;线程分离：Redis 6.0 引入了多线程处理部分 I/O 密集型任务，如 AOF 重写和 RDB 持久化，这样可以进一步提高 Redis 的性能，因为这些任务不再完全阻塞单一线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redis为何使用单线程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis为何使用单线程&#34;&gt;#&lt;/a&gt; Redis 为何使用单线程&lt;/h3&gt;
&lt;p&gt;Redis 选择单线程模型的原因有以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存操作速度快：Redis 的所有数据都存储在内存中，内存的读写速度非常快。因此，对于基于内存的操作而言，CPU 并不是性能瓶颈。如果使用多线程，反而需要解决多线程同步的问题，这可能会增加额外的 CPU 负担。&lt;/li&gt;
&lt;li&gt;数据结构简单：Redis 中的数据结构相对简单，操作也较为迅速，这使得单线程就能够高效地处理大量的客户端请求。&lt;/li&gt;
&lt;li&gt;非阻塞 I/O 模型：Redis 使用了非阻塞的 I/O 模型，即多路复用 I/O 机制（如 epoll、select 等）。&lt;br&gt;
这种机制使得单线程可以同时监听多个客户端连接的请求，并在有请求到达时异步地处理这些请求，从而有效地利用了单线程的能力来处理高并发连接。&lt;/li&gt;
&lt;li&gt;简化设计：单线程模型简化了 Redis 的设计和实现。由于不存在多线程间的竞争和同步问题，Redis 的代码更加简洁易懂，同时也减少了潜在的 bug。&lt;/li&gt;
&lt;li&gt;避免上下文切换开销：多线程模型会导致频繁的上下文切换，这会消耗大量的 CPU 资源。单线程模型避免了这种开销，使得 Redis 可以更加高效地使用 CPU 资源。&lt;/li&gt;
&lt;li&gt;易于实现高一致性：单线程模型下，数据的一致性更容易保证，因为不存在多线程并发修改同一份数据的问题。&lt;/li&gt;
&lt;li&gt;避免锁的竞争：在多线程环境下，为了避免数据冲突，通常需要使用锁机制。而锁的竞争会导致一部分线程处于等待状态，从而降低了系统的整体吞吐量。单线程模型避免了这种锁的竞争。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然而，单线程模型也有其局限性。例如，对于 CPU 密集型的任务，单线程模型可能不是最佳选择，因为这样的任务会阻塞主线程，影响 Redis 处理其他请求的能力。为了解决这个问题，Redis 在后来的版本中引入了多线程来处理 I/O 密集型任务，如 AOF 重写和 RDB 持久化，以此来提升性能。&lt;/p&gt;
&lt;h3 id=&#34;缓存三大问题以及解决方案&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#缓存三大问题以及解决方案&#34;&gt;#&lt;/a&gt; 缓存三大问题以及解决方案？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;缓存击穿：指的是当某个 key 非常热点，在并发访问量大的情况下，如果这个 key 恰好在这个时刻失效了，那么所有请求都会落到数据库上，造成数据库瞬间压力过大。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置热点数据永不过期：对于热点数据，可以将其设置为永不过期，或者设置一个较长的过期时间。
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ol&gt;
&lt;li&gt;减少了因缓存失效导致的数据库压力。&lt;/li&gt;
&lt;li&gt;简单易实施。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ol&gt;
&lt;li&gt;可能会导致缓存中的数据长时间不更新，影响数据的新鲜度。&lt;/li&gt;
&lt;li&gt;如果数据量很大，可能会占用较多的内存资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;适用场景：
&lt;ol&gt;
&lt;li&gt;数据更新频率较低，且数据新鲜度要求不高的场景。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;互斥锁：使用互斥锁（Mutex）机制来控制缓存更新的过程。当缓存失效时，先获取锁，然后检查数据库中是否有数据，如果有则更新缓存，最后释放锁。
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ol&gt;
&lt;li&gt;可以确保在缓存失效时，只有一部分请求会真正落到数据库上，减少了数据库的压力。&lt;/li&gt;
&lt;li&gt;数据更新及时。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ol&gt;
&lt;li&gt;锁的使用会增加系统的复杂性。&lt;/li&gt;
&lt;li&gt;如果并发量极高，可能会出现锁竞争激烈的情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;适用场景：
&lt;ol&gt;
&lt;li&gt;数据更新频繁，且数据新鲜度要求较高的场景。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;懒加载：当缓存失效后，可以先返回旧数据或占位符，然后异步加载最新数据并更新缓存。
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ol&gt;
&lt;li&gt;用户体验较好，不会立即感知到数据陈旧。&lt;/li&gt;
&lt;li&gt;减少了数据库的瞬时压力。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ol&gt;
&lt;li&gt;数据更新可能有延迟。&lt;/li&gt;
&lt;li&gt;实现复杂度较高。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;适用场景：
&lt;ol&gt;
&lt;li&gt;数据更新频率适中，对用户体验有一定要求的场景。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓存穿透：是指查询一个一定不存在的数据，这个数据在缓存中不存在，同时在数据库中也不存在，每次请求都会直接穿透缓存去查询数据库，造成数据库压力巨大。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置空值缓存：当查询到数据库中不存在的数据时，可以将这个查询结果（通常是 null 或特殊标识）缓存起来，设置一定的过期时间。
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ol&gt;
&lt;li&gt;直接解决了缓存穿透问题，减少了对数据库的无效请求。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ol&gt;
&lt;li&gt;如果恶意攻击者利用不存在的 key 频繁请求，可能会导致缓存中存储大量无效数据。&lt;/li&gt;
&lt;li&gt;需要合理设置过期时间，避免长期占用缓存空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;适用场景：
&lt;ol&gt;
&lt;li&gt;适用于存在大量无效查询请求的场景。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;布隆过滤器（Bloom Filter）：使用布隆过滤器来判断数据是否存在，可以有效地拦截那些一定不存在的数据查询。
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ol&gt;
&lt;li&gt;有效拦截不存在的数据查询，减少无效请求。&lt;/li&gt;
&lt;li&gt;占用空间小，查询速度快。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ol&gt;
&lt;li&gt;存在一定的误判率，即可能存在少量的假阳性（False Positive）。&lt;/li&gt;
&lt;li&gt;需要合理设计布隆过滤器的容量和哈希函数数量。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;适用场景：
&lt;ol&gt;
&lt;li&gt;适用于数据量大且对数据精确性有一定容忍度的场景。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;API 层面的验证：在业务逻辑层面增加对输入数据的校验，提前过滤掉非法或无效的查询请求。
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ol&gt;
&lt;li&gt;从源头上过滤掉非法请求，减轻后续处理层的压力。&lt;/li&gt;
&lt;li&gt;提升系统的安全性。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ol&gt;
&lt;li&gt;需要在业务逻辑中增加额外的验证步骤，增加了开发工作量。&lt;/li&gt;
&lt;li&gt;可能需要维护一份合法 key 的列表或规则。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;适用场景：
&lt;ol&gt;
&lt;li&gt;适用于存在非法请求可能性的场景。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓存雪崩：是指当缓存中的数据集中过期，导致大量请求同时穿透缓存去查询数据库，造成数据库压力剧增甚至崩溃。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分散缓存过期时间：避免大量数据同时过期，可以通过随机化设置过期时间来分散数据的过期时间。
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ol&gt;
&lt;li&gt;有效避免了大量数据同时过期的情况，降低了数据库的压力。&lt;/li&gt;
&lt;li&gt;实现简单。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ol&gt;
&lt;li&gt;需要合理设置随机过期时间，以确保数据分布均匀。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;适用场景：
&lt;ol&gt;
&lt;li&gt;适用于数据量较大且有过期时间一致性的风险的场景。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;限流降级：在缓存失效前，通过限流算法来控制请求的流量，一旦超过阈值则进行降级处理，返回默认值或缓存中的旧数据。
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ol&gt;
&lt;li&gt;通过限流机制保护了后端系统，避免了突发流量的影响。&lt;/li&gt;
&lt;li&gt;可以根据实际情况调整限流策略。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ol&gt;
&lt;li&gt;需要设计合理的降级策略，以确保用户体验不受太大影响。&lt;/li&gt;
&lt;li&gt;实现复杂度较高。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;适用场景：
&lt;ol&gt;
&lt;li&gt;适用于流量波动较大的场景。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;备用缓存：准备一个备用缓存系统，当主缓存系统出现故障或过载时，可以切换到备用缓存继续服务。
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ol&gt;
&lt;li&gt;提供了冗余保障，增强了系统的可用性。&lt;/li&gt;
&lt;li&gt;可以平滑地切换到备用系统，减少服务中断时间。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ol&gt;
&lt;li&gt;需要维护两套缓存系统，增加了运维成本。&lt;/li&gt;
&lt;li&gt;切换逻辑需要考虑数据同步问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;适用场景：
&lt;ol&gt;
&lt;li&gt;适用于对系统可用性要求较高的场景。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;异步更新：当缓存失效时，可以先返回旧数据或占位符，然后异步加载最新数据并更新缓存。
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ol&gt;
&lt;li&gt;用户体验较好，不会立即感知到数据陈旧。&lt;/li&gt;
&lt;li&gt;减少了数据库的瞬时压力。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ol&gt;
&lt;li&gt;数据更新可能有延迟。&lt;/li&gt;
&lt;li&gt;实现复杂度较高。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;适用场景：
&lt;ol&gt;
&lt;li&gt;适用于数据更新频率适中，对用户体验有一定要求的场景。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;如何保证数据库和redis缓存一致性&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#如何保证数据库和redis缓存一致性&#34;&gt;#&lt;/a&gt; 如何保证数据库和 Redis 缓存一致性？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;最终一致性（Eventual Consistency）&lt;/p&gt;
&lt;p&gt;在分布式系统中，通常追求的是最终一致性而非强一致性。最终一致性意味着在一段时间后，所有数据副本将收敛到同一个状态。对于缓存和数据库来说，这意味着在数据更新后，缓存最终会反映数据库中的最新状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双写策略&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先更新数据库，再删除缓存（Update Database First, Invalidate Cache）&lt;/p&gt;
&lt;p&gt;原理：当数据发生变化时，首先更新数据库中的数据，然后再删除缓存中的对应条目。当下次请求该数据时，由于缓存中没有该数据，所以会重新从数据库中读取并更新缓存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;简单易实现。&lt;/li&gt;
&lt;li&gt;可以避免数据不一致的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;如果删除缓存失败，则可能导致缓存中的数据比数据库中的数据旧。&lt;/li&gt;
&lt;li&gt;删除缓存操作可能会失败，需要有重试机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;适用场景：
&lt;ul&gt;
&lt;li&gt;更新操作较少，且对数据一致性要求较高的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先删除缓存，再更新数据库（Invalidate Cache First, Update Database）&lt;/p&gt;
&lt;p&gt;原理：当数据发生变化时，先删除缓存中的数据，然后再更新数据库中的数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;可以避免缓存击穿问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;如果更新数据库失败，而缓存已经被删除，那么这段时间内将无法从缓存中获取数据，导致请求直接访问数据库，增加数据库压力。&lt;/li&gt;
&lt;li&gt;如果删除缓存和更新数据库之间有延迟，可能会导致短暂的数据不一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;适用场景：
&lt;ul&gt;
&lt;li&gt;更新操作频繁，但对数据一致性要求稍低的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;延迟双删策略（Double Eviction with Delay）&lt;/p&gt;
&lt;p&gt;原理：当数据更新时，先删除缓存中的数据，然后立即设置一个临时缓存项（如使用 Redis 的 EXPIRE 命令设置一个很短的过期时间），再更新数据库。当临时缓存项过期后，真正的更新操作完成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;减少了直接访问数据库的概率。&lt;/li&gt;
&lt;li&gt;通过设置临时缓存项，可以减少更新数据库失败导致的数据不一致问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;实现相对复杂。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;适用场景：
&lt;ul&gt;
&lt;li&gt;高并发场景下，对数据一致性要求较高的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用消息队列&lt;/p&gt;
&lt;p&gt;原理：当数据在数据库中更新后，发送一个消息到消息队列中，由另一个消费者监听消息队列并更新缓存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;解耦数据库和缓存更新操作。&lt;/li&gt;
&lt;li&gt;可以异步处理缓存更新，减少数据库更新时的延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;增加了系统的复杂性。&lt;/li&gt;
&lt;li&gt;需要处理消息队列的可靠性和消息重复消费问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;适用场景：
&lt;ul&gt;
&lt;li&gt;高并发、大数据量的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓存预热&lt;/p&gt;
&lt;p&gt;原理：在系统启动或数据更新后，主动将数据加载到缓存中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;避免冷启动时大量请求直接访问数据库。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;需要额外的机制来触发预热操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;适用场景：
&lt;ul&gt;
&lt;li&gt;系统启动或数据更新后，希望尽快恢复服务的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;乐观锁或版本号&lt;/p&gt;
&lt;p&gt;原理：在数据库中为数据添加一个版本号字段，每次更新时都需要检查版本号是否匹配。如果不匹配，则说明数据已被其他操作更新，需要重新获取最新数据并再次尝试更新。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;保证了数据的一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;可能会出现更新冲突，需要重试机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;适用场景：
&lt;ul&gt;
&lt;li&gt;对数据一致性要求极高的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;如何保证-redis-的高并发&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#如何保证-redis-的高并发&#34;&gt;#&lt;/a&gt; 如何保证 Redis 的高并发？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;单机优化
&lt;ul&gt;
&lt;li&gt;硬件优化：选择高性能的硬件设备，如 SSD 硬盘、高速网络接口卡以及足够的内存。&lt;/li&gt;
&lt;li&gt;内存管理：合理设置 Redis 的最大内存限制，避免内存溢出导致的服务不可用。&lt;/li&gt;
&lt;li&gt;持久化策略：选择合适的持久化方式（RDB 或 AOF），并调整相关的配置，以减少对性能的影响。&lt;/li&gt;
&lt;li&gt;数据结构选择：根据应用场景选择合适的数据结构，以减少内存使用并提高访问效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主从复制
&lt;ul&gt;
&lt;li&gt;读写分离：通过主从复制实现读写分离，主节点负责写操作，从节点负责读操作，可以显著提高并发处理能力。&lt;/li&gt;
&lt;li&gt;自动故障转移：使用 Redis Sentinel（哨兵）机制来监控主从节点的状态，并在主节点发生故障时自动进行故障转移，保证高可用性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分布式集群
&lt;ul&gt;
&lt;li&gt;Redis Cluster：使用 Redis 集群来水平扩展 Redis，集群可以自动将数据分片存储在不同的节点上，并提供数据复制功能。这样可以支持更高的并发量和更大的数据集。&lt;/li&gt;
&lt;li&gt;数据分片：手动将数据分片存储在不同的 Redis 实例上，可以减轻单个节点的压力。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;客户端优化
&lt;ul&gt;
&lt;li&gt;连接池：使用连接池来复用客户端连接，减少建立和销毁连接的开销。&lt;/li&gt;
&lt;li&gt;批处理：批量处理请求，例如使用 MGET、MSET 等命令来一次处理多个键值对，减少网络往返次数。&lt;/li&gt;
&lt;li&gt;命令管道：使用 Redis 的命令管道（pipelining）特性，将多个命令一次性发送给 Redis 服务器，减少网络延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调整配置
&lt;ul&gt;
&lt;li&gt;网络配置：优化网络配置，例如调整 TCP 缓冲区大小、禁用 Nagle 算法等，以提高网络传输效率。&lt;/li&gt;
&lt;li&gt;I/O 多路复用：Redis 使用事件驱动模型来处理客户端请求，可以处理大量的并发连接。确保操作系统和 Redis 的事件处理机制配置得当。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;监控与调优
&lt;ul&gt;
&lt;li&gt;性能监控：定期监控 Redis 的性能指标，如 CPU 使用率、内存使用情况、网络延迟等，以便及时发现性能瓶颈。&lt;/li&gt;
&lt;li&gt;负载均衡：使用负载均衡器来分配客户端请求，确保各个 Redis 节点的负载均衡。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;避免热点 Key
&lt;ul&gt;
&lt;li&gt;Key 的设计：合理设计 Key，避免热点 Key 的产生，例如使用哈希分片（Hash Ring）来分散请求。&lt;/li&gt;
&lt;li&gt;过期时间：为热点 Key 设置合理的过期时间，并且可以使用随机化过期时间来避免雪崩效应。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;异步处理
&lt;ul&gt;
&lt;li&gt;异步持久化：使用异步的方式进行持久化操作，避免阻塞主线程。&lt;/li&gt;
&lt;li&gt;多线程处理：Redis 6.0 引入了多线程模型来处理部分 I/O 密集型任务，如 AOF 重写和 RDB 持久化，可以进一步提升性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;redis-如何保证原子性&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#redis-如何保证原子性&#34;&gt;#&lt;/a&gt; Redis 如何保证原子性？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;单线程模型: Redis 采用单线程模型来处理所有的客户端请求。这意味着在同一时间内，只有一个客户端请求被处理，因此消除了并发竞争条件，保证了命令执行的顺序性和原子性。&lt;/li&gt;
&lt;li&gt;命令级别的原子性: Redis 中的大多数命令都是原子性的，这意味着它们在执行过程中不会被其他操作打断。例如，SET, GET, INCR,&lt;br&gt;
DECR, HSET, HGET 等命令在执行时，整个操作过程不会被中断，从而保证了操作的完整性。&lt;/li&gt;
&lt;li&gt;事务机制: Redis 提供了事务机制，允许用户将多个命令打包成一个事务，通过 MULTI 命令开启事务，然后执行一系列命令，最后通过 EXEC 命令提交事务。&lt;br&gt;
在事务中，Redis 会将这些命令放入队列中，等到事务提交时，这些命令会按照顺序依次执行，从而保证了事务内的操作的原子性。&lt;/li&gt;
&lt;li&gt;WATCH 命令: WATCH 命令可以监视一个或多个键，如果监视的键在执行 EXEC 之前被其他客户端修改了，那么事务会被取消。这实际上是一种乐观锁机制，用来保证在某些特定场景下的数据一致性。&lt;/li&gt;
&lt;li&gt;Lua 脚本: Redis 允许在服务器端执行 Lua 脚本来处理复杂的操作。Lua 脚本在执行时具有原子性，即整个脚本作为一个整体执行，期间不会被打断。&lt;br&gt;
这意味着脚本中的多个 Redis 命令会被作为一个单独的操作来执行，从而保证了操作的原子性。&lt;/li&gt;
&lt;li&gt;数据结构的设计: Redis 内部的数据结构设计也是为了支持高效的原子操作。例如，对于有序集合（Sorted&lt;br&gt;
Sets），Redis 使用了跳跃表（Skiplist），这是一种支持快速插入、删除和查找操作的数据结构，可以高效地支持原子性操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;常用命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#常用命令&#34;&gt;#&lt;/a&gt; 常用命令&lt;/h2&gt;
&lt;h3 id=&#34;cmd访问redis&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#cmd访问redis&#34;&gt;#&lt;/a&gt; cmd 访问 redis&lt;/h3&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;redis-cli.exe -h 127.0.0.1 -p 6379&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;字符串string相关命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#字符串string相关命令&#34;&gt;#&lt;/a&gt; 字符串 (String) 相关命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SET key value：设置键 key 的值为 value。&lt;/li&gt;
&lt;li&gt;GET key：获取键 key 的值。&lt;/li&gt;
&lt;li&gt;GETSET key value：设置键 key 的值为 value，并返回键 key 的旧值。&lt;/li&gt;
&lt;li&gt;INCR key：将键 key 的值加一，仅支持整数值。&lt;/li&gt;
&lt;li&gt;INCRBY key increment：将键 key 的值加上指定的增量 increment。&lt;/li&gt;
&lt;li&gt;DECR key：将键 key 的值减一。&lt;/li&gt;
&lt;li&gt;DECRBY key decrement：将键 key 的值减去指定的减量 decrement。&lt;/li&gt;
&lt;li&gt;APPEND key value：将 value 追加到键 key 的值后面。&lt;/li&gt;
&lt;li&gt;STRLEN key：返回键 key 的值的长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;列表list相关命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#列表list相关命令&#34;&gt;#&lt;/a&gt; 列表 (List) 相关命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;LPUSH key value [value …]：将一个或多个值 value 插入到键 key 的列表头部。&lt;/li&gt;
&lt;li&gt;RPUSH key value [value …]：将一个或多个值 value 插入到键 key 的列表尾部。&lt;/li&gt;
&lt;li&gt;LPOP key：移除并返回键 key 的列表的第一个元素。&lt;/li&gt;
&lt;li&gt;RPOP key：移除并返回键 key 的列表的最后一个元素。&lt;/li&gt;
&lt;li&gt;LRANGE key start stop：返回键 key 的列表中指定范围内的元素。&lt;/li&gt;
&lt;li&gt;LREM key count value：移除键 key 的列表中等于 value 的元素，count 参数决定了移除的数量。&lt;/li&gt;
&lt;li&gt;LSET key index value：将键 key 的列表中的指定位置 index 的值设为 value。&lt;/li&gt;
&lt;li&gt;LLEN key：返回键 key 的列表的长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;哈希hash相关命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#哈希hash相关命令&#34;&gt;#&lt;/a&gt; 哈希 (Hash) 相关命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HSET key field value：将哈希表 key 中的域 field 的值设为 value。&lt;/li&gt;
&lt;li&gt;HGET key field：返回哈希表 key 中域 field 的值。&lt;/li&gt;
&lt;li&gt;HGETALL key：返回哈希表 key 中所有域的值。&lt;/li&gt;
&lt;li&gt;HDEL key field [field …]：删除一个或多个哈希表 key 中的域 field。&lt;/li&gt;
&lt;li&gt;HEXISTS key field：查看哈希表 key 中指定域 field 是否存在。&lt;/li&gt;
&lt;li&gt;HLEN key：返回哈希表 key 中域的数量。&lt;/li&gt;
&lt;li&gt;HKEYS key：返回哈希表 key 中所有域的列表。&lt;/li&gt;
&lt;li&gt;HVALS key：返回哈希表 key 中所有值的列表。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;集合set相关命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#集合set相关命令&#34;&gt;#&lt;/a&gt; 集合 (Set) 相关命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SADD key member [member …]：将一个或多个成员 member 加入到集合 key 中。&lt;/li&gt;
&lt;li&gt;SMEMBERS key：返回集合 key 中的所有成员。&lt;/li&gt;
&lt;li&gt;SCARD key：返回集合 key 中的成员数。&lt;/li&gt;
&lt;li&gt;SREM key member [member …]：将一个或多个成员 member 从集合 key 中移除。&lt;/li&gt;
&lt;li&gt;SISMEMBER key member：判断成员 member 是否是集合 key 的成员。&lt;/li&gt;
&lt;li&gt;SINTER key [key …]：返回给定多个集合的交集成员。&lt;/li&gt;
&lt;li&gt;SUNION key [key …]：返回给定多个集合的并集成员。&lt;/li&gt;
&lt;li&gt;SDIFF key [key …]：返回给定多个集合的差集成员。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;有序集合sorted-set相关命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#有序集合sorted-set相关命令&#34;&gt;#&lt;/a&gt; 有序集合 (Sorted Set) 相关命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ZADD key score member [score member …]：将一个或多个成员 member 及其分数 score 加入到有序集合 key 中。&lt;/li&gt;
&lt;li&gt;ZRANGE key start stop [WITHSCORES]：返回有序集合 key 中指定范围内的成员。&lt;/li&gt;
&lt;li&gt;ZREVRANGE key start stop [WITHSCORES]：返回有序集合 key 中指定范围内的成员，成员按分数值递减排列。&lt;/li&gt;
&lt;li&gt;ZREM key member [member …]：将一个或多个成员 member 从有序集合 key 中移除。&lt;/li&gt;
&lt;li&gt;ZCARD key：返回有序集合 key 中的成员数。&lt;/li&gt;
&lt;li&gt;ZSCORE key member：返回有序集合 key 中成员 member 的分数值。&lt;/li&gt;
&lt;li&gt;ZCOUNT key min max：计算在有序集合 key 中指定区间分数的成员数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;通用命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#通用命令&#34;&gt;#&lt;/a&gt; 通用命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;EXPIRE key seconds：为键 key 设置生存时间。&lt;/li&gt;
&lt;li&gt;TTL key：返回键 key 剩余的生存时间。&lt;/li&gt;
&lt;li&gt;DEL key [key …]：删除一个或多个键 key。&lt;/li&gt;
&lt;li&gt;SELECT index：选择编号为 index 的数据库。&lt;/li&gt;
&lt;li&gt;FLUSHDB：清除当前数据库中的所有数据。&lt;/li&gt;
&lt;li&gt;FLUSHALL：清除所有数据库中的所有数据。&lt;/li&gt;
&lt;li&gt;KEYS pattern：返回匹配 pattern 的所有键。&lt;/li&gt;
&lt;li&gt;TYPE key：返回键 key 的类型。&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
