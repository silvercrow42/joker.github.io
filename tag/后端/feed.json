{
    "version": "https://jsonfeed.org/version/1",
    "title": "Joker • All posts by \"后端\" tag",
    "description": "",
    "home_page_url": "https://silvercrow42.github.io/joker.github.io",
    "items": [
        {
            "id": "https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/",
            "url": "https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/",
            "title": "【Redis】Redis面试题汇总与详解",
            "date_published": "2024-09-13T05:52:28.000Z",
            "content_html": "<h1 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h1>\n<h2 id=\"redis-是什么\"><a class=\"markdownIt-Anchor\" href=\"#redis-是什么\">#</a> Redis 是什么</h2>\n<p>Redis（Remote Dictionary Server）是一个开源的键值存储系统，以其高性能和低延迟著称。它最初由 Salvatore<br>\nSanfilippo 编写，并于 2009 年首次发布。Redis 不仅可以作为数据库使用，还可以作为缓存和消息代理。Redis 支持多种数据结构，如字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted<br>\nsets）等，这使得它非常适合用于多种应用场景</p>\n<h2 id=\"redis-的特点\"><a class=\"markdownIt-Anchor\" href=\"#redis-的特点\">#</a> Redis 的特点</h2>\n<ul>\n<li>内存存储：Redis 将所有数据都存储在内存中，这使得它能够提供非常高的读写速度，通常能够达到数十万次每秒的读写操作（QPS）。</li>\n<li>持久化：尽管 Redis 主要是一个内存数据库，但它也提供了数据持久化的机制，包括 RDB（Redis Database Backup）快照和 AOF（Append Only<br>\nFile）日志两种方式。</li>\n<li>数据结构丰富：除了基本的键值对存储之外，Redis 还支持多种复杂的数据结构，如列表、集合、有序集合等，这使得它非常适合用于构建复杂的数据模型。</li>\n<li>网络透明：Redis 使用 TCP 协议，客户端可以通过网络访问 Redis 服务器，支持跨平台部署。</li>\n<li>主从复制：Redis 支持主从复制机制，可以轻松地设置数据备份和读写分离。</li>\n<li>Lua 脚本：Redis 支持在服务器端执行 Lua 脚本，允许用户将复杂的操作封装成一个原子性的操作。</li>\n<li>事务：Redis 支持事务，允许用户将一系列操作打包成一个单独的命令序列执行。</li>\n<li>发布 / 订阅模式：Redis 支持发布 / 订阅模式，可以用于构建消息队列或事件驱动的应用程序。</li>\n<li>集群：Redis 3.0 之后版本支持官方的集群模式，可以实现数据的水平扩展。</li>\n<li>多线程：Redis 6.0 版本引入了多线程模型，用于异步处理 I/O 和其他耗时操作，进一步提升了性能。</li>\n</ul>\n<h2 id=\"redis-的应用场景\"><a class=\"markdownIt-Anchor\" href=\"#redis-的应用场景\">#</a> Redis 的应用场景</h2>\n<p>由于其高性能和灵活性，Redis 被广泛应用于多种场景中：</p>\n<ul>\n<li>缓存：由于 Redis 的高速读写能力，它经常被用作 Web 应用的缓存层，以减轻后端数据库的压力。</li>\n<li>会话存储：Redis 可以用来存储用户的会话信息，支持快速的读取和更新操作。</li>\n<li>排行榜：Redis 的有序集合非常适合用来构建排行榜，可以高效地进行排序和范围查询。</li>\n<li>消息队列：通过发布 / 订阅模式，Redis 可以作为一个轻量级的消息队列系统。</li>\n<li>实时数据分析：Redis 的数据结构非常适合用于处理实时数据流，如实时统计、监控等。</li>\n<li>分布式锁：Redis 可以用来实现简单的分布式锁机制，协调多个节点上的并发操作。</li>\n</ul>\n<h2 id=\"redis-的数据结构\"><a class=\"markdownIt-Anchor\" href=\"#redis-的数据结构\">#</a> Redis 的数据结构</h2>\n<h3 id=\"底层数据结构\"><a class=\"markdownIt-Anchor\" href=\"#底层数据结构\">#</a> 底层数据结构</h3>\n<h4 id=\"redisobject\"><a class=\"markdownIt-Anchor\" href=\"#redisobject\">#</a> redisObject</h4>\n<p>定义：redisObject（通常缩写为 robj）是 Redis 中用来表示数据库键值对的一个核心数据结构。每一个键值对在 Redis 内部都会被转化为一个 redisObject 实例进行管理。这个结构体不仅包含了键或值本身的数据，还提供了额外的信息来帮助 Redis 更好地管理和操作这些对象。</p>\n<p>用途：redisObject 是 Redis 中键值对存储的数据结构，它封装了键和值，并提供了额外的元数据，如引用计数、过期时间等。其主要作用在于：</p>\n<ul>\n<li>类型和编码：它使得 Redis 能够灵活地存储不同类型的数据，并且可以根据数据的特点选择最合适的编码方式来存储，从而优化内存使用和访问速度。</li>\n<li>内存管理：通过引用计数，redisObject 支持对象的共享和自动内存回收，减少了不必要的内存分配和释放操作。</li>\n<li>LRU 缓存淘汰：通过记录对象的最后访问时间，Redis 可以实现基于 LRU 算法的对象淘汰，从而在内存资源有限的情况下，优先保留最近使用的对象。</li>\n<li>共享对象：对于一些常用的简单对象（如数字 0 和 1，以及空字符串），Redis 会创建一次并复用，这减少了创建和销毁对象的开销。</li>\n</ul>\n<p>底层实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> lru:REDIS_LRU_BITS; <span class=\"comment\">/* LRU time (relative to server.lruclock) */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"type\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n<p>redisObject 的基本结构通常包含以下字段：</p>\n<ul>\n<li>type: 一个 4 位的无符号整数，用来标识对象的类型。Redis 支持多种数据类型，如字符串（string）、列表（list）、集合（set）、哈希（hash）、有序集合（sorted<br>\nset）等，每种类型都有一个对应的标识符。</li>\n<li>encoding: 另一个 4 位的无符号整数，表示对象的编码方式。不同的数据类型有不同的内部编码方式，例如字符串可以是普通的字符串，也可以是压缩后的字符串（embstr），列表可以是链表（list）或者快速列表（quicklist）等。</li>\n<li>lru: 一个时间戳，记录了对象最后一次被访问的时间（相对于服务器的 lruclock）。这个字段用于实现 Redis 的 LRU（Least Recently<br>\nUsed）缓存淘汰策略。</li>\n<li>refcount: 引用计数器，用来追踪有多少地方引用了这个对象。当一个对象不再被任何地方引用时，其引用计数器减至零，Redis 可以回收该对象占用的内存。</li>\n<li>ptr: 一个指向实际数据的指针。这个指针指向的具体内容依赖于对象的类型和编码方式。</li>\n</ul>\n<h4 id=\"动态字符串sds\"><a class=\"markdownIt-Anchor\" href=\"#动态字符串sds\">#</a> 动态字符串（SDS）</h4>\n<p>定义：SDS（Simple Dynamic String）是一种动态字符串，它使用一个结构体来保存字符串的指针、长度和未使用的空间。</p>\n<p>底层实现：使用简单动态字符串（SDS）来存储数据，SDS 是为了克服 C 字符串的一些不足而设计的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//记录buf数组中已使用字节的数量</span></span><br><span class=\"line\">    <span class=\"comment\">//等于 SDS 保存字符串的长度</span></span><br><span class=\"line\">    <span class=\"type\">int</span> len;</span><br><span class=\"line\">    <span class=\"comment\">//记录 buf 数组中未使用字节的数量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"built_in\">free</span>;</span><br><span class=\"line\">    <span class=\"comment\">//字节数组，用于保存字符串</span></span><br><span class=\"line\">    <span class=\"type\">char</span> buf[];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用 SDS 保存字符串 “Redis” 具体图示如下：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/1120165-20180528075607627-218845583.png\" class=\"\" title=\"1120165-20180528075607627-218845583.png\">\n<p>图片来源：《Redis 设计与实现》</p>\n<p>我们看上面对于 SDS 数据类型的定义：</p>\n<ul>\n<li>len 保存了 SDS 保存字符串的长度</li>\n<li>buf [] 数组用来保存字符串的每个元素</li>\n<li>free j 记录了 buf 数组中未使用的字节数量</li>\n</ul>\n<p>上面的定义相对于 C 语言对于字符串的定义，有什么好处？</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/1120165-20180527234349672-568401853.png\" class=\"\" title=\"1120165-20180528075607627-218845583.png\">\n<ol>\n<li>\n<p>常数复杂度获取字符串长度：由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O (1)。而对于 C<br>\n 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O (n)。通过 strlen key 命令可以获取 key 的字符串长度。</p>\n</li>\n<li>\n<p>杜绝缓冲区溢出：我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于<br>\n SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求。如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p>\n</li>\n<li>\n<p>减少修改字符串的内存重新分配次数:<br>\nC 语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p>\n<p>而对于 SDS，由于 len 属性和 free 属性的存在，对于修改字符串 SDS 实现了空间预分配和惰性空间释放两种策略：</p>\n<ol>\n<li>空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</li>\n<li>惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free<br>\n 属性将这些字节的数量记录下来，等待后续使用。（当然 SDS 也提供了相应的 API，当我们有需要时，也可以手动释放这些未使用的空间。）</li>\n</ol>\n</li>\n<li>\n<p>二进制安全</p>\n<p>因为 C 字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此 C 字符串无法正确存取；而所有<br>\n SDS 的 API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len<br>\n 属性表示的长度来判断字符串是否结束。</p>\n</li>\n<li>\n<p>兼容部分 C 字符串函数</p>\n<p>虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库 &lt;string.h&gt; 中的一部分函数。</p>\n</li>\n</ol>\n<p>一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）来使用。</p>\n<h4 id=\"压缩列表zip-list\"><a class=\"markdownIt-Anchor\" href=\"#压缩列表zip-list\">#</a> 压缩列表（Zip List）</h4>\n<p>定义：Ziplist 是一种特殊的内存紧凑型数据结构，用于存储多个相邻的元素。它主要用于实现 Redis 中的列表（List）和哈希（Hash）数据类型，当这些数据类型的数据量较小且元素较短时，使用 ziplist 可以节省内存空间。</p>\n<p>底层实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> header; <span class=\"comment\">// 标记ziplist的开始，通常是一个固定的字节（例如 0x01）</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> length; <span class=\"comment\">// 整个ziplist的长度，包括所有条目和前缀信息。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Entries</span></span><br><span class=\"line\">    <span class=\"comment\">// Each entry has a length prefix and content</span></span><br><span class=\"line\">    <span class=\"comment\">// The number of entries is determined by the length field</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Example entry structure:</span></span><br><span class=\"line\">    <span class=\"comment\">// Length prefix (1 or 5 bytes)</span></span><br><span class=\"line\">    <span class=\"comment\">// Content (variable length)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// End marker</span></span><br><span class=\"line\">    <span class=\"type\">char</span> end; <span class=\"comment\">// 标记ziplist的结束，通常是一个固定的字节（例如 0xff）。</span></span><br><span class=\"line\">&#125; <span class=\"type\">ziplist_t</span>;</span><br></pre></td></tr></table></figure>\n<p>实现细节：</p>\n<ul>\n<li>前缀：每个元素的前缀包含了元素的长度信息，以及元素的类型信息。</li>\n<li>长度编码：ziplist 使用可变长度编码来存储元素的长度，这样可以更高效地利用内存。</li>\n<li>内存紧凑：由于 ziplist 将所有元素存储在一个连续的内存区域中，因此它可以有效地减少内存碎片。</li>\n</ul>\n<p>特点</p>\n<ul>\n<li>连续存储：ziplist 将多个元素存储在一个连续的内存块中。</li>\n<li>元素和长度信息：每个元素的前面都会有一个前缀，这个前缀包含了元素的长度信息。</li>\n<li>支持多种类型：ziplist 可以存储整数或字符串，整数直接存储在前缀中，字符串则存储在前缀之后。</li>\n</ul>\n<h4 id=\"双向链表linkedlist\"><a class=\"markdownIt-Anchor\" href=\"#双向链表linkedlist\">#</a> 双向链表（linkedlist）</h4>\n<p>定义：在 Redis 中，linkedlist（通常指的是 Redis 内部实现的双向链表）是 Redis 用来存储 list 键值对的一种底层数据结构。它允许 Redis 从列表的两端高效地添加和移除元素，</p>\n<p>底层实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个双向链表节点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span>  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span>&#123;</span></span><br><span class=\"line\">       <span class=\"comment\">//前置节点</span></span><br><span class=\"line\">       <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\">       <span class=\"comment\">//后置节点</span></span><br><span class=\"line\">       <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">       <span class=\"comment\">//节点的值</span></span><br><span class=\"line\">       <span class=\"type\">void</span> *value;  </span><br><span class=\"line\">&#125;listNode</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个双向链表</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span>&#123;</span></span><br><span class=\"line\">     <span class=\"comment\">//表头节点</span></span><br><span class=\"line\">     listNode *head;</span><br><span class=\"line\">     <span class=\"comment\">//表尾节点</span></span><br><span class=\"line\">     listNode *tail;</span><br><span class=\"line\">     <span class=\"comment\">//链表所包含的节点数量</span></span><br><span class=\"line\">     <span class=\"type\">unsigned</span> <span class=\"type\">long</span> len;</span><br><span class=\"line\">     <span class=\"comment\">//节点值复制函数</span></span><br><span class=\"line\">     <span class=\"type\">void</span> (*<span class=\"built_in\">free</span>) (<span class=\"type\">void</span> *ptr);</span><br><span class=\"line\">     <span class=\"comment\">//节点值释放函数</span></span><br><span class=\"line\">     <span class=\"type\">void</span> (*<span class=\"built_in\">free</span>) (<span class=\"type\">void</span> *ptr);</span><br><span class=\"line\">     <span class=\"comment\">//节点值对比函数</span></span><br><span class=\"line\">     <span class=\"type\">int</span> (*match) (<span class=\"type\">void</span> *ptr,<span class=\"type\">void</span> *key);</span><br><span class=\"line\">&#125;<span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure>\n<p>数据结构如下图</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/1120165-20180528074403440-111834793.png\" class=\"\" title=\"1120165-20180528074403440-111834793.png\">\n<p>Redis 的 linkedlist 是由一系列 listNode 节点构成的双向链表。</p>\n<p>每个 listNode 包含三个主要部分：</p>\n<ul>\n<li>prev：指向列表中前一个节点的指针。</li>\n<li>next：指向列表中后一个节点的指针。</li>\n<li>value：存储实际数据的字段，这个字段实际上是指向 redisObject 的指针，redisObject 包含了实际的数据和元数据（如类型、编码等）。</li>\n</ul>\n<p>每个 list 包含三个主要部分：</p>\n<ul>\n<li>head：指向链表的第一个节点。</li>\n<li>tail：指向链表的最后一个节点。</li>\n<li>len：链表的长度，即链表中节点的数量。</li>\n</ul>\n<p>特点</p>\n<ul>\n<li>双向链接：每个节点都包含前驱和后继指针，这使得可以从链表的任一端开始遍历整个链表。</li>\n<li>无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL, 对链表的访问都是以 NULL 结束。</li>\n<li>带链表长度计数器：通过 len 属性获取链表长度的时间复杂度为 O (1)。</li>\n<li>多态：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值。</li>\n<li>动态增长：随着元素的增加，链表可以动态增长。</li>\n</ul>\n<h4 id=\"哈希表hashtable\"><a class=\"markdownIt-Anchor\" href=\"#哈希表hashtable\">#</a> 哈希表（Hashtable）</h4>\n<p>定义：hashtable（哈希表）是一种用于存储键值对的数据结构，它在 Redis 内部用于实现哈希（hash）类型。哈希表允许快速地插入、查找和删除键值对，并且提供了良好的性能。</p>\n<p>底层实现：Redis 中的哈希表实现主要包括两个核心组件：一个数组和一个链表。数组中的每个槽（slot）都可以存储一个链表，链表中的每个节点代表一个键值对。这种设计允许哈希表处理哈希冲突，即多个键映射到同一个数组索引的情况。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    dictEntry **table; <span class=\"comment\">// 哈希桶数组</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> size; <span class=\"comment\">// 哈希桶数组大小</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> used; <span class=\"comment\">// 已使用的哈希桶数量</span></span><br><span class=\"line\">    dictResizeFunc *resize; <span class=\"comment\">// 重置哈希表大小的函数</span></span><br><span class=\"line\">    <span class=\"type\">void</span> (*rehashidx); <span class=\"comment\">// 当前正在进行的哈希表重置索引</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> states; <span class=\"comment\">// 哈希表状态标志</span></span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure>\n<p>Redis 中的哈希表结构定义通常包括以下几个部分：</p>\n<ul>\n<li>table：一个数组，数组的每个元素都是一个链表。</li>\n<li>size：数组的大小。</li>\n<li>used：已使用的槽的数量，即存储键值对的链表数量。</li>\n<li>resize_policy：在某些 Redis 版本中，可能还包括用于控制何时进行重新哈希（resizing）的策略。</li>\n</ul>\n<p>哈希表 table 中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *key; <span class=\"comment\">// 键</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"type\">void</span> *val; <span class=\"comment\">// 值</span></span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> ival; <span class=\"comment\">// 整数值</span></span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span> <span class=\"comment\">// 指向下一个同散列值的dictEntry</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure>\n<p>每个键值对存储在一个 dictEntry 结构体中，该结构体包含：</p>\n<ul>\n<li>key：键的指针，指向 redisObject。</li>\n<li>val：值的指针，同样指向 redisObject。</li>\n<li>next：指向链表中下一个节点的指针，用于处理哈希冲突。</li>\n</ul>\n<h5 id=\"哈希冲突的优化\"><a class=\"markdownIt-Anchor\" href=\"#哈希冲突的优化\">#</a> 哈希冲突的优化</h5>\n<p>我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过 next 这个指针可以将多个哈希值相同的键值对连接在一起，用来解决哈希冲突。</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/1120165-20180528080655703-1600710948.png\" class=\"\" title=\"1120165-20180528080655703-1600710948.png\">\n<ol>\n<li>\n<p>哈希算法：Redis 计算哈希值和索引值方法如下：</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"number\">1</span>、使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class=\"line\">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class=\"line\">#<span class=\"number\">2</span>、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值</span><br><span class=\"line\">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>解决哈希冲突：这个问题上面我们介绍了，方法是链地址法。通过字典里面的 *next 指针指向下一个具有相同索引值的哈希表节点。</p>\n</li>\n<li>\n<p>扩容和收缩：当哈希表保存的键值对太多或者太少时，就要通过 rerehash (重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：</p>\n<ol>\n<li>如果执行扩展操作，会基于原哈希表创建一个大小等于 ht [0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。<br>\n相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。</li>\n<li>重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。</li>\n<li>所有键值对都迁徙完毕后，释放原哈希表的内存空间。</li>\n</ol>\n</li>\n<li>\n<p>触发扩容的条件：</p>\n<ol>\n<li>服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于 1。</li>\n<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于 5。</li>\n</ol>\n<p>ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。</p>\n</li>\n<li>\n<p>渐近式 rehash</p>\n<p>什么叫渐进式 rehash？ 也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在 Redis 中的键值对只有几个几十个，那么<br>\n rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行<br>\n rehash，势必会造成 Redis 一段时间内不能进行别的操作。所以 Redis 采用渐进式<br>\n rehash, 这样在进行渐进式 rehash 期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行<br>\n增加操作，一定是在新的哈希表上进行的。</p>\n</li>\n</ol>\n<h4 id=\"整数集合intset\"><a class=\"markdownIt-Anchor\" href=\"#整数集合intset\">#</a> 整数集合（intset）</h4>\n<p>定义：一种特殊的数据结构，主要用于存储整数类型的集合，并且这些整数集合不允许有重复的元素。</p>\n<p>底层实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">intset</span>&#123;</span></span><br><span class=\"line\">     <span class=\"comment\">//编码方式</span></span><br><span class=\"line\">     <span class=\"type\">uint32_t</span> encoding;</span><br><span class=\"line\">     <span class=\"comment\">//集合包含的元素数量</span></span><br><span class=\"line\">     <span class=\"type\">uint32_t</span> length;</span><br><span class=\"line\">     <span class=\"comment\">//保存元素的数组</span></span><br><span class=\"line\">     <span class=\"type\">int8_t</span> contents[];</span><br><span class=\"line\">&#125;intset;</span><br></pre></td></tr></table></figure>\n<p>intset 的数据结构定义通常包括以下几个部分：</p>\n<ul>\n<li>length：表示集合中元素的数量。</li>\n<li>encoding：表示集合中元素的类型，可以是 int16_t、int32_t 或 int64_t，具体取决于集合中最大的整数值所需的位数。</li>\n<li>contents：一个动态数组，用于存储实际的整数值。每个整数根据 encoding 字段指定的类型占用相应的字节数。</li>\n</ul>\n<p>动态升级</p>\n<p>当尝试向 intset 中添加一个超出当前整数类型范围的整数时，Redis 会执行一个称为 “编码升级” 的过程。这个过程会将 intset 中的所有元素转换为更大类型的整数，以适应新加入的元素。例如，如果 intset 当前使用的是 int32_t 类型，而尝试插入一个 int64_t 类型的值，则所有现有的 int32_t 值会被转换成 int64_t 类型。</p>\n<h4 id=\"跳表skip-list\"><a class=\"markdownIt-Anchor\" href=\"#跳表skip-list\">#</a> 跳表（Skip List）</h4>\n<p>定义：Skiplist 是一种线性数据结构，它提供了比传统平衡树更快的查找性能，同时实现相对简单。Redis 使用 skiplist 来实现有序集合（Sorted<br>\nSet）。</p>\n<p>底层实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplist</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">header</span>;</span> <span class=\"comment\">// 跳表头部</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">tail</span>;</span> <span class=\"comment\">// 跳表尾部</span></span><br><span class=\"line\">    <span class=\"type\">int</span> length; <span class=\"comment\">// 跳表长度</span></span><br><span class=\"line\">    <span class=\"type\">int</span> level; <span class=\"comment\">// 跳表层级</span></span><br><span class=\"line\">&#125; zskiplist;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">double</span> score; <span class=\"comment\">// 成员的分数</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *obj; <span class=\"comment\">// 成员对象</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">backward</span>;</span> <span class=\"comment\">// 指向前一个节点的指针</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistLevel</span> &#123;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">forward</span>;</span> <span class=\"comment\">// 指向后一个节点的指针</span></span><br><span class=\"line\">        <span class=\"type\">int</span> span; <span class=\"comment\">// 跨越的节点数量</span></span><br><span class=\"line\">    &#125; level[]; <span class=\"comment\">// 层级数组</span></span><br><span class=\"line\">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>\n<p>实现细节：</p>\n<ul>\n<li>节点结构：skiplist 中的每个节点包含一个元素、一个分数（用于排序）、一个指向前一个节点的指针以及一个或多个指向下一层节点的指针。</li>\n<li>层级：每个节点可以有多个层级，每个层级对应一个指针，指向下一个具有相同高度的节点。</li>\n<li>查找：查找时，从最高层开始，沿着指针前进直到找到目标元素或到达最低层。</li>\n</ul>\n<p>特点：</p>\n<ul>\n<li>多级索引：skiplist 通过构建多级索引来加速查找，每一级索引都是前一级索引的一个子集。</li>\n<li>随机高度：新插入的元素的高度是随机确定的，通常使用随机化算法来决定新节点的高度。</li>\n<li>高效插入和删除：由于 skiplist 的多级索引结构，插入和删除操作也相当高效。</li>\n</ul>\n<h3 id=\"数据结构的使用\"><a class=\"markdownIt-Anchor\" href=\"#数据结构的使用\">#</a> 数据结构的使用</h3>\n<h4 id=\"字符串string\"><a class=\"markdownIt-Anchor\" href=\"#字符串string\">#</a> 字符串（String）</h4>\n<p>用途：存储字符串数据，如文本、数字、日期等。</p>\n<p>实现：根据不同的情况下字符串对象的 encoding 有三种，分别是：int、raw、embstr。</p>\n<ol>\n<li>\n<p>如果一个字符串对象保存的是整数值，并且这个整数值可以用 long 类型标识，那么字符串对象会讲整数值保存在 ptr 属性中，并将<br>\n encoding 设置为 int。比如 set number 10086 命令。</p>\n</li>\n<li>\n<p>如果字符串对象保存的是一个字符串值，并且这个字符串的长度大于 44 字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为<br>\n raw。在这种情况下，ptr 字段指向一个 SDS（Simple Dynamic String）结构。S 在这种情况下，ptr 字段指向一个 SDS（Simple Dynamic<br>\nString）结构。</p>\n</li>\n<li>\n<p>如果字符串对象保存的是一个字符串值，并且这个字符串的长度小于等于 44 字节，那么字符串对象将使用 embstr<br>\n 编码的方式来保存这个字符串。embstr 同样基于 SDS，是一种将 RedisObject 对象头和 SDS 对象连续存在一起，使用 malloc<br>\n 方法一次分配内存的存储形式。 这种编码方式的一些优点：</p>\n<ol>\n<li>embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次。</li>\n<li>释放 embstr 编码的字符串对象只需要调用一次内存释放函数，而释放 raw 编码的字符串对象需要调用两次内存释放函数。</li>\n<li>因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起 raw<br>\n 编码的字符串对象能够更好地利用缓存带来的优势。</li>\n</ol>\n</li>\n</ol>\n<p>为什么分界线是 44 字节？</p>\n<p>Redis 的 embstr 编码的实现中，字符串对象头和字符串对象本身是连续的，因此需要一个字节来保存字符串的长度。<br>\nembstr 最小占用空间为 19（16+3），而 64-19-1（结尾的 \\0）=44，所以 embstr 只能容纳 44 字节。</p>\n<p>使用场景：</p>\n<ul>\n<li>计数器：例如网站的访问计数，可以使用 INCR 或 INCRBY 命令来递增计数器。</li>\n<li>会话存储：存储用户的登录状态或其他临时信息。</li>\n<li>消息队列：使用 LPUSH 和 BRPOP 命令实现简单的消息队列。</li>\n<li>缓存：存储经常访问的数据，减少数据库的访问压力。</li>\n</ul>\n<h4 id=\"列表list\"><a class=\"markdownIt-Anchor\" href=\"#列表list\">#</a> 列表（List）</h4>\n<p>用途：用于存储有序的元素列表，如队列、栈等。</p>\n<p>实现：列表对象的 encoding 有 ziplist 和 linkedlist 两种。</p>\n<ul>\n<li>当列表的长度小于 512，并且所有元素的长度都小于 64 字节时，使用压缩列表 (ziplist) 存储</li>\n<li>当列表的长度大于等于 512，或者有元素长度大于 64 字节时，使用链表 (linkedlist) 存储。</li>\n</ul>\n<p>使用场景：</p>\n<ul>\n<li>消息队列：使用 LPUSH 和 BRPOP 命令实现先进先出（FIFO）的消息队列。</li>\n<li>历史记录：保存用户的浏览历史或购买记录，可以使用 RPUSH 和 LPOP 命令。</li>\n<li>排行榜：使用列表存储排名信息，通过 LREM 命令可以移除特定成员。</li>\n</ul>\n<h4 id=\"哈希hash\"><a class=\"markdownIt-Anchor\" href=\"#哈希hash\">#</a> 哈希（Hash）</h4>\n<p>用途：存储键值对，其中键是唯一的，值可以重复。</p>\n<p>实现：哈希对象的 encoding 有 ziplist 和 hashtable 两种。</p>\n<ul>\n<li>当哈希对象保存的键值对数量小于 512，并且所有键值对的长度都小于 64 字节时，使用压缩列表存储；</li>\n<li>当哈希对象保存的键值对数量大于等于 512，或者有键值对长度大于 64 字节时，使用 hashtable 存储。</li>\n</ul>\n<p>使用场景：</p>\n<ul>\n<li>对象存储：存储复杂对象，如用户信息，每个字段对应用户的一个属性。</li>\n<li>购物车：每个用户有一个购物车，购物车中的商品信息可以用哈希表来存储。</li>\n<li>会话管理：存储用户的会话信息，每个会话 ID 对应一个哈希表。</li>\n</ul>\n<h4 id=\"集合set\"><a class=\"markdownIt-Anchor\" href=\"#集合set\">#</a> 集合（Set）</h4>\n<p>用途：存储不重复的元素集合，如集合、去重列表等。</p>\n<p>实现：集合对象的 encoding 有 intset 和 hashtable 两种。</p>\n<ul>\n<li>当集合中元素数量小于 512，并且所有元素的长度都小于 64 字节时，使用 intset 存储；</li>\n<li>当集合中元素数量大于等于 512，或者有元素长度大于 64 字节时，使用 hashtable 存储。</li>\n</ul>\n<p>使用场景：</p>\n<ul>\n<li>去重：例如在一个活动中，确保每个用户只能参与一次。</li>\n<li>标签系统：每个项目可以有多个标签，使用集合来存储项目的标签。</li>\n<li>好友关系：存储用户的好友列表，可以快速判断两个用户是否互为好友。</li>\n</ul>\n<h4 id=\"有序集合sorted-set\"><a class=\"markdownIt-Anchor\" href=\"#有序集合sorted-set\">#</a> 有序集合（Sorted Set）</h4>\n<p>用途：存储有序的元素集合，其中元素是唯一的，并且可以按照一定的顺序排列。</p>\n<p>实现：有序集合对象的 encoding 有 ziplist 和 skiplist 两种。</p>\n<ol>\n<li>当有序集合中的元素数量小于 512，并且所有元素的长度都小于 64 字节时，使用压缩列表 (ziplist) 存储；</li>\n<li>当有序集合中的元素数量大于等于 512，或者有元素长度大于 64 字节时，使用跳表 (skiplist) 存储。</li>\n</ol>\n<p>使用场景：</p>\n<ul>\n<li>排行榜：根据分数排序的排行榜，如游戏得分、用户贡献度等。</li>\n<li>优先级队列：每个元素都有一个优先级，可以按优先级取出元素。</li>\n<li>时间轴：按时间戳排序的消息或帖子显示，如微博、Facebook 的时间线。</li>\n<li>地理信息：存储地理位置信息，并使用 GEO 命令查询附近的地点。</li>\n</ul>\n<h4 id=\"其他数据结构\"><a class=\"markdownIt-Anchor\" href=\"#其他数据结构\">#</a> 其他数据结构</h4>\n<ul>\n<li>\n<p>Bitmaps：二进制位数组，适合用于存储大量稀疏数据，如用户访问记录、权限控制等。</p>\n<p>使用场景：</p>\n<ul>\n<li>统计分析：例如统计某一天有多少独立用户访问了网站，可以使用一个位图来表示每个用户是否访问过。</li>\n<li>权限管理：每个用户可以有多个权限位，使用位图来表示用户的权限。</li>\n</ul>\n</li>\n<li>\n<p>HyperLogLog：用于近似计算不重复元素的数量，非常适合处理大规模数据集。</p>\n<p>使用场景：</p>\n<ul>\n<li>近似计数：用于估算大量数据中的不重复元素数量，例如统计网站的独立访客数。</li>\n</ul>\n</li>\n<li>\n<p>Streams：类似于消息队列，用于处理异步消息传递，可以实现类似 Kafka 的功能。</p>\n<p>使用场景：</p>\n<ul>\n<li>事件日志：记录系统中的事件，如用户行为日志，可以使用 XADD 添加事件，XREAD 读取事件。</li>\n<li>异步处理：作为消息队列的一部分，将事件发布到流中，然后由消费者异步处理。</li>\n</ul>\n</li>\n<li>\n<p>Geo：用于存储地理位置信息，并提供基于地理位置的查询功能。</p>\n<p>使用场景：</p>\n<ul>\n<li>位置服务：存储地理位置信息，并支持基于地理位置的搜索，如查找附近的餐厅或酒店。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"redis-综合应用示例\"><a class=\"markdownIt-Anchor\" href=\"#redis-综合应用示例\">#</a> Redis 综合应用示例</h4>\n<p>假设我们要构建一个社交网络应用，可以使用 Redis 来实现以下功能：</p>\n<ul>\n<li>用户信息存储：使用 Hash 类型存储每个用户的个人信息，如用户名、头像、生日等。</li>\n<li>好友关系：使用 Set 类型存储每个用户的好友列表。</li>\n<li>动态时间线：使用 Sorted Set 类型存储用户的动态，根据发布时间排序。</li>\n<li>消息通知：使用 List 类型作为消息队列，存储用户收到的通知消息。</li>\n<li>在线状态：使用 BitMap 类型记录每天用户的在线状态。</li>\n<li>热门话题：使用 HyperLogLog 类型来估计参与某个话题讨论的独立用户数量。</li>\n</ul>\n<h2 id=\"redis-的持久化\"><a class=\"markdownIt-Anchor\" href=\"#redis-的持久化\">#</a> Redis 的持久化</h2>\n<p>redis 是一个内存数据库，数据保存在内存中，但是我们都知道内存的数据变化是很快的，也容易发生丢失。幸好 Redis 还为我们提供了持久化的机制，分别是 RDB (<br>\nRedis DataBase) 和 AOF (Append Only File)。</p>\n<h3 id=\"rdb机制\"><a class=\"markdownIt-Anchor\" href=\"#rdb机制\">#</a> RDB 机制</h3>\n<p>RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为 dump.rdb。</p>\n<p>Redis 提供了三种机制：save、bgsave、自动化来触发 RDB 持久化过程：</p>\n<ul>\n<li>\n<p>save 触发方式</p>\n<p>该命令会阻塞当前 Redis 服务器，执行 save 命令期间，Redis 不能处理其他命令，直到 RDB 过程完成为止。具体流程如下：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg\" class=\"\" title=\"e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg\">\n<p>执行完成时候如果存在老的 RDB 文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p>\n</li>\n<li>\n<p>bgsave 触发方式</p>\n<p>执行该命令时，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg\" class=\"\" title=\"023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg\">\n<p>具体操作是 Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短。基本上<br>\n Redis 内部所有的 RDB 操作都是采用 bgsave 命令。</p>\n</li>\n<li>\n<p>自动触发</p>\n<p>自动触发是由我们的配置文件来完成的。在 redis.conf 配置文件中，里面有如下配置，我们可以去设置：</p>\n<ol>\n<li>save：这里是用来配置触发 Redis 的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如 “save m<br>\nn”。表示 m 秒内数据集存在 n 次修改时，自动触发 bgsave。</li>\n<li>stop-writes-on-bgsave-error：默认值为 yes。<br>\n当启用了 RDB 且最后一次后台保存数据失败，Redis 是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果 Redis 重启了，那么又可以重新开始接收数据了</li>\n<li>rdbcompression；默认值是 yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</li>\n<li>rdbchecksum：默认值是 yes。在存储快照后，我们还可以让 redis 使用 CRC64 算法来进行数据校验，但是这样做会增加大约 10% 的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</li>\n<li>dbfilename：设置快照的文件名，默认是 dump.rdb</li>\n<li>dir：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</li>\n</ol>\n<p>我们可以修改这些配置来实现我们想要的效果。</p>\n</li>\n</ul>\n<p>因为第三种方式是配置的，所以我们对前两种进行一个对比：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/1c950a7b02087bf43b4490d50ac25f2a11dfcf7e.jpeg\" class=\"\" title=\"1c950a7b02087bf43b4490d50ac25f2a11dfcf7e.jpeg\">\n<p>RDB 的优势和劣势</p>\n<ul>\n<li>\n<p>优势</p>\n<ul>\n<li>RDB 文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</li>\n<li>生成 RDB 文件的时候，redis 主进程会 fork () 一个子进程来处理所有保存工作，主进程不需要进行任何磁盘 IO 操作。</li>\n<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>\n</ul>\n</li>\n<li>\n<p>劣势</p>\n<ul>\n<li>RDB 快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。<br>\n当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"aof机制\"><a class=\"markdownIt-Anchor\" href=\"#aof机制\">#</a> AOF 机制</h3>\n<p>全量备份总是耗时的，Redis 提供一种更加高效的方式 AOF，工作机制很简单，Redis 会将每一个收到的写命令都通过 write 函数追加到文件中。通俗的理解就是日志记录。</p>\n<ol>\n<li>\n<p>持久化原理</p>\n<p>他的原理看下面这张图：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/32fa828ba61ea8d3c2502e396b1b3848251f58b0.jpeg\" class=\"\" title=\"32fa828ba61ea8d3c2502e396b1b3848251f58b0.jpeg\">\n<p>每当有一个写命令过来时，就直接保存在我们的 AOF 文件中。</p>\n</li>\n<li>\n<p>文件重写原理</p>\n<p>AOF 的方式也同时带来了另一个问题：持久化文件会变的越来越大。为了解决这个问题，redis 提供了 bgrewriteaof 命令用来压缩 aof 的持久化文件。这条命令会将内存中的数据以命令的方式保存到临时文件中，同时会 fork 出一条新进程来将文件重写。</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/09fa513d269759ee28454d2c4cea4b106c22dfd3.jpeg\" class=\"\" title=\"09fa513d269759ee28454d2c4cea4b106c22dfd3.jpeg\">\n<p>重写 aof 文件的操作，并没有读取旧的 aof 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 aof 文件，这点和快照有点类似。</p>\n</li>\n</ol>\n<p>AOF 也有三种触发机制</p>\n<ul>\n<li>每修改同步 always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</li>\n<li>每秒同步 everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失</li>\n<li>不同 no：从不同步</li>\n</ul>\n<p>三种触发机制的对比如下图</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/b17eca8065380cd7df69859ba056a5325982816c.jpeg\" class=\"\" title=\"b17eca8065380cd7df69859ba056a5325982816c.jpeg\">\n<p>AOF 的优势和劣势</p>\n<ul>\n<li>优势\n<ul>\n<li>AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次 fsync 操作，最多丢失 1 秒钟的数据。</li>\n<li>AOF 日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</li>\n<li>AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</li>\n<li>AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。<br>\n比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大</li>\n<li>AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"持久化机制的选择\"><a class=\"markdownIt-Anchor\" href=\"#持久化机制的选择\">#</a> 持久化机制的选择</h3>\n<p>通常情况下我们是二者结合使用的。</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>RDB</th>\n<th>AOF</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>启动优先级</td>\n<td>低</td>\n<td>高</td>\n</tr>\n<tr>\n<td>体积</td>\n<td>小</td>\n<td>大</td>\n</tr>\n<tr>\n<td>恢复速度</td>\n<td>快</td>\n<td>慢</td>\n</tr>\n<tr>\n<td>数据安全性</td>\n<td>丢数据</td>\n<td>取决于刷盘策略</td>\n</tr>\n<tr>\n<td>轻重</td>\n<td>重</td>\n<td>轻</td>\n</tr>\n</tbody>\n</table>\n<p>RDB 使用场景</p>\n<ul>\n<li>数据恢复要求不高：如果应用程序可以接受在两次快照之间数据丢失的风险，那么 RDB 是一个很好的选择。</li>\n<li>需要快速恢复大量数据：由于 RDB 文件是一个完整的数据库快照，因此在需要快速恢复大量数据时，RDB 提供了更快的恢复速度。</li>\n<li>定期备份：RDB 适用于需要定期进行完整备份的场景，比如每天一次的全量备份。</li>\n<li>数据归档：RDB 文件可以轻松地传输到远程服务器或存储设备上，用于长期的数据归档或灾难恢复。</li>\n</ul>\n<p>AOF 使用场景</p>\n<ul>\n<li>数据安全性要求高：如果应用程序不能容忍任何数据丢失，那么 AOF 是更好的选择，因为它可以保证数据的完整性。</li>\n<li>频繁写入操作：对于写密集型的应用场景，AOF 可以更好地保证数据的一致性。</li>\n<li>数据重放：AOF 文件可以用来重放数据，这对于调试和审计非常有用。</li>\n<li>自动修复：Redis 可以定期对 AOF 文件进行重写，以压缩文件大小并移除冗余命令。</li>\n</ul>\n<h2 id=\"redis-的内存调度\"><a class=\"markdownIt-Anchor\" href=\"#redis-的内存调度\">#</a> Redis 的内存调度</h2>\n<h3 id=\"redis-的过期策略\"><a class=\"markdownIt-Anchor\" href=\"#redis-的过期策略\">#</a> Redis 的过期策略</h3>\n<h4 id=\"设置过期时间\"><a class=\"markdownIt-Anchor\" href=\"#设置过期时间\">#</a> 设置过期时间</h4>\n<p>Redis 对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置 key 的有效时间。Expires 字典保存了所有键的过期时间，Expires 也被称为过期字段。</p>\n<p>一般主要包括 5 种处理过期方式，其中 expire 都是以秒为单位，pexpire 都是以毫秒为单位的。</p>\n<ul>\n<li><code>EXPIRE key seconds</code> ：将 key 的生存时间设置为 ttl 秒</li>\n<li><code>PEXPIRE key milliseconds</code> ：将 key 的生成时间设置为 ttl 毫秒</li>\n<li><code>EXPIREAT key timestamp</code> ：将 key 的过期时间设置为 timestamp 所代表的的秒数的时间戳</li>\n<li><code>PEXPIREAT key milliseconds-timestamp</code> ：将 key 的过期时间设置为 timestamp 所代表的的毫秒数的时间戳</li>\n<li><code>setex(String key, int seconds, String value)</code> ：字符串独有的方式，为指定的 key 设置值及其过期时间。如果 key 已经存在，<br>\nSETEX 命令将会替换旧的值。</li>\n</ul>\n<p>注：</p>\n<ul>\n<li>timestamp 为 unix 时间戳（例如：timestamp=1499788800 表示将在 2017.07.12 过期）</li>\n<li>1、2 两种方式是设置一个过期的时间段，就是咱们处理验证码最常用的策略，设置三分钟或五分钟后失效，把分钟数转换成秒或毫秒存储到 Redis 中。</li>\n<li>3、4 两种方式是指定一个过期的时间 ，比如优惠券的过期时间是某年某月某日，只是单位不一样。</li>\n<li>如果没有设置时间，那缓存就是永不过期</li>\n<li>如果设置了过期时间，之后又想让缓存永不过期，使用 persist key</li>\n</ul>\n<h4 id=\"过期策略\"><a class=\"markdownIt-Anchor\" href=\"#过期策略\">#</a> 过期策略</h4>\n<ul>\n<li>\n<p>定时过期（Active Expiration）</p>\n<p>含义：当一个键设置了过期时间时，Redis 会在键的过期时间到达时立即清除这个键。</p>\n<p>优点：这种方法可以保证内存被尽快释放，过期的键不会占用内存太久。</p>\n<p>缺点：定时过期需要为每个设置了过期时间的键创建一个定时器，这会占用大量的 CPU 资源来处理过期的数据，从而影响 Redis 的响应时间和吞吐量。</p>\n</li>\n<li>\n<p>被动过期（Lazy Expiration）</p>\n<p>含义：当访问一个键时，Redis 会检查这个键是否已经过期。如果过期，Redis 会删除这个键并返回相应的错误信息给客户端。</p>\n<p>优点：这种方法对 CPU 资源友好，因为它只在访问键时才会检查过期情况。</p>\n<p>缺点：如果过期的键没有被及时访问，那么它将继续占用内存，直到被访问或通过其他方式清理掉为止。</p>\n<p>流程：</p>\n<ol>\n<li>在进行 get 或 setnx 等操作时，先检查 key 是否过期，</li>\n<li>若过期，删除 key，然后执行相应操作；</li>\n<li>若没过期，直接执行相应操作</li>\n</ol>\n</li>\n<li>\n<p>定期过期（Periodic Reaping）</p>\n<p>含义：Redis 会周期性地检查过期的键，并删除一部分过期的键。这种策略试图在内存消耗和 CPU 使用之间找到一个平衡点，可以通过</p>\n<ul>\n<li>配置 redis.conf 的 hz 选项，默认为 10 （即 1 秒执行 10 次，100ms 一次，值越大说明刷新频率越快，对 Redis 性能损耗也越大）</li>\n<li>配置 redis.conf 的 maxmemory 最大值，当已用内存超过 maxmemory 限定时，就会触发主动清理策略。</li>\n</ul>\n<p>优点：通过周期性地检查和删除过期键，可以有效地减少内存浪费，同时通过限制删除操作的执行时长和频率来减少对 CPU 时间的影响。</p>\n<p>缺点：难以确定删除操作执行的时长和频率。如果删除操作执行得太频繁或执行的时间太长，定期删除策略就会退化成定时删除，导致占用太多的 CPU 执行时间。如果删除操作执行得太少或执行时间太短，定期删除策略又会类似于被动过期，导致内存浪费。</p>\n<p>流程：其核心是对指定个数个库的每一个库随机删除小于等于指定个数个过期 key：</p>\n<ol>\n<li>遍历每个数据库（就是 redis.conf 中配置的 “database” 数量，默认为 16）；\n<ol>\n<li>检查当前库中的指定个数个 key （默认是每个库检查 20 个，相当于该循环执行 20 次）：\n<ol>\n<li>如果当前库中没有一个 key 设置了过期时间，直接执行下一个库的遍历；</li>\n<li>随机获取一个设置了过期时间的 key，检查是否过期，如果过期则删除；</li>\n<li>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<p>综合策略</p>\n<p>在实际应用中，Redis 通常会结合使用上述三种策略来管理过期键。例如，Redis 可能会使用定期过期作为主要的过期策略，同时辅以被动过期来处理未被定期过期策略捕获的过期键。此外，对于一些关键操作，Redis 可能会采用定时过期来确保某些重要键在过期后能够立即被释放。</p>\n<h4 id=\"持久化中的过期\"><a class=\"markdownIt-Anchor\" href=\"#持久化中的过期\">#</a> 持久化中的过期</h4>\n<ul>\n<li>\n<p>RDB 对过期 key 的处理</p>\n<p>过期 key 对 RDB 没有任何影响</p>\n<ul>\n<li>从内存数据库持久化数据到 RDB 文件\n<ul>\n<li>持久化 key 之前，会检查是否过期，过期的 key 不进入 RDB 文件</li>\n</ul>\n</li>\n<li>从 RDB 文件恢复数据到内存数据库\n<ul>\n<li>数据载入数据库之前，会对 key 先进行过期检查，如果过期，不导入数据库（主库情况）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>AOF 对过期 key 的处理<br>\n过期 key 对 AOF 没有任何影响</p>\n<ul>\n<li>从内存数据库持久化数据到 AOF 文件：\n<ul>\n<li>当 key 过期后，还没有被删除，此时进行执行持久化操作（该 key 是不会进入 aof 文件的，因为没有发生修改命令）</li>\n<li>当 key 过期后，在发生删除操作时，程序会向 aof 文件追加一条 del 命令（在将来的以 aof 文件恢复数据的时候该过期的键就会被删掉）</li>\n</ul>\n</li>\n<li>AOF 重写\n<ul>\n<li>重写时，会先判断 key 是否过期，已过期的 key 不会重写到 aof 文件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"pipeline\"><a class=\"markdownIt-Anchor\" href=\"#pipeline\">#</a> Pipeline</h2>\n<p>Redis 的 Pipeline 功能允许客户端将多个命令打包成一个请求发送给 Redis 服务器，而不是逐个发送命令。这样做可以显著减少客户端与服务器之间的网络往返次数，从而提高<br>\n Redis 的性能和效率。下面详细介绍 Redis Pipeline 的工作原理、使用场景以及如何使用。</p>\n<p>Pipeline 的工作原理</p>\n<ol>\n<li>打包命令：客户端将多个 Redis 命令打包成一个请求，这个请求包含了所有命令的数据。</li>\n<li>发送请求：客户端一次性将打包好的请求发送给 Redis 服务器。</li>\n<li>执行命令：Redis 服务器接收到请求后，依次执行其中的所有命令。</li>\n<li>返回结果：Redis 服务器将各个命令的结果保存起来，并在所有命令执行完毕后，一次性将所有结果返回给客户端。</li>\n<li>处理结果：客户端接收到所有命令的结果后，按顺序处理这些结果。</li>\n</ol>\n<p>Pipeline 的优点</p>\n<ul>\n<li>减少网络延迟：通过减少客户端与服务器之间的网络往返次数，Pipeline 可以显著降低网络延迟，提高整体性能。</li>\n<li>提高吞吐量：由于减少了网络交互次数，客户端可以更快地处理更多的命令。</li>\n<li>事务性操作：虽然 Pipeline 不保证命令执行的原子性，但是它可以模拟事务的行为，即可以将一组命令作为一个整体发送和接收结果。</li>\n</ul>\n<p>使用场景</p>\n<ul>\n<li>批量操作：当你需要执行一系列相关联的命令时，使用 Pipeline 可以提高效率。</li>\n<li>性能优化：在需要频繁与 Redis 进行交互的应用场景中，使用 Pipeline 可以减少网络开销，提升性能。</li>\n<li>模拟事务：虽然 Redis 的 Pipeline 不保证命令的原子性，但是在不需要严格事务性的场景下，可以使用 Pipeline 来模拟事务行为。</li>\n</ul>\n<p>如何使用 Pipeline<br>\n 在不同的 Redis 客户端库中，使用 Pipeline 的方式略有不同。以下是在几种常见语言中使用 Pipeline 的示例：</p>\n<p>JavaScript (Node.js)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> redis = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;redis&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> client = redis.<span class=\"title function_\">createClient</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">client.<span class=\"title function_\">pipeline</span>()</span><br><span class=\"line\">    .<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;foo&#x27;</span>, <span class=\"string\">&#x27;bar&#x27;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">exec</span>(<span class=\"function\">(<span class=\"params\">err, replies</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(replies); <span class=\"comment\">// replies is an array of responses</span></span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>Python (redis-py)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const redis = require(<span class=\"string\">&quot;redis&quot;</span>);</span><br><span class=\"line\">const client = redis.createClient();</span><br><span class=\"line\"></span><br><span class=\"line\">client.pipeline()</span><br><span class=\"line\">  .<span class=\"built_in\">set</span>(<span class=\"string\">&#x27;foo&#x27;</span>, <span class=\"string\">&#x27;bar&#x27;</span>)</span><br><span class=\"line\">  .get(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"built_in\">exec</span>((err, replies) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) throw err;</span><br><span class=\"line\">    console.log(replies); // replies <span class=\"keyword\">is</span> an array of responses</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>java (jedis)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">Jedis jedis=<span class=\"keyword\">new</span> <span class=\"title class_\">Jedis</span>(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        Pipeline pipelined=jedis.pipelined();</span><br><span class=\"line\">        pipelined.set(<span class=\"string\">&quot;foo&quot;</span>,<span class=\"string\">&quot;bar&quot;</span>);</span><br><span class=\"line\">        pipelined.get(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">        List&lt;Object&gt; results=pipelined.syncAndReturnAll();</span><br><span class=\"line\">        System.out.println(results);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>注意事项</p>\n<ul>\n<li>命令数量：虽然 Pipeline 可以显著提高性能，但如果打包的命令数量过多，可能会导致单个请求的体积过大，增加客户端的等待时间，并可能导致网络阻塞。</li>\n<li>命令执行顺序：Pipeline 中的命令是按照发送顺序执行的，因此需要确保命令间的依赖关系不会导致错误。</li>\n<li>错误处理：如果 Pipeline 中的某条命令执行失败，整个 Pipeline 的结果都会受到影响。因此，在处理 Pipeline<br>\n 的结果时，需要注意检查每个命令的执行状态。</li>\n</ul>\n<p>原生批命令 (mset, mget) 与 Pipeline 对比</p>\n<ul>\n<li>原生批命令是原子性，pipeline 是非原子性</li>\n<li>原生批命令一命令多个 key, 但 pipeline 支持多命令（存在事务），非原子性</li>\n<li>原生批命令是服务端实现，而 pipeline 需要服务端与客户端共同完成</li>\n</ul>\n<h2 id=\"redis-事务\"><a class=\"markdownIt-Anchor\" href=\"#redis-事务\">#</a> Redis 事务</h2>\n<p>Redis 事务是 Redis 中的一个重要特性，它允许客户端在一个事务中执行多个命令，并确保这些命令要么全部执行成功，要么全部执行失败。在事务中，客户端可以提交或回滚整个事务，而不需要关心事务中的命令是否成功执行。尽管<br>\n Redis 事务并不提供传统意义上的 ACID 事务特性（原子性、一致性、隔离性、持久性），但它确实提供了一些基本的功能，使得开发者可以更方便地处理一系列相关的命令。</p>\n<p>Redis 事务的主要功能包括：</p>\n<ul>\n<li>命令队列：客户端可以将多个命令放入一个队列中，然后通过 EXEC 命令一次性发送给 Redis 服务器执行。</li>\n<li>监视（WATCH）：客户端可以监视一个或多个键，如果在执行 EXEC 命令之前这些键被其他客户端修改，则事务会被取消。</li>\n<li>取消（DISCARD）：如果在事务执行之前发现某些条件不满足，客户端可以选择取消事务。</li>\n</ul>\n<p>Redis 事务的实现分为几个步骤：</p>\n<ul>\n<li>事务开始：客户端通过 MULTI 命令开始一个事务。</li>\n<li>命令入队：在 MULTI 命令之后，客户端可以发送任意数量的命令，这些命令将被放入事务队列中，但不会立即执行。</li>\n<li>事务执行：通过 EXEC 命令，客户端可以执行事务队列中的所有命令。如果在此之前使用了 WATCH 命令监视的键被修改，则事务会被取消。</li>\n<li>取消事务：如果在执行 EXEC 命令之前，客户端想要取消事务，可以使用 DISCARD 命令。</li>\n</ul>\n<p>Redis 中事务的特性有：</p>\n<ul>\n<li>原子性：一旦事务开始执行，Redis 会保证事务中的所有命令要么全部执行成功，要么都不执行。然而，如果命令在执行过程中出现错误（如类型错误），Redis<br>\n 会继续执行后续命令。</li>\n<li>一致性：Redis 事务在一定程度上保证了一致性，特别是通过使用 WATCH 命令监视键的变化，可以防止脏读。</li>\n<li>隔离性：由于 Redis 是单线程的，事务中的命令会按顺序执行，因此不存在并发事务之间的隔离性问题。</li>\n<li>持久性：Redis 的持久化机制（如 RDB 或 AOF）保证了数据的持久性，但这与事务无关。</li>\n</ul>\n<p>Redis 事务的限制</p>\n<ul>\n<li>不支持回滚：如果事务中的某个命令失败，Redis 会继续执行剩余的命令，并不会回滚之前的命令。</li>\n<li>错误处理：如果事务中的命令出现错误，Redis 会记录错误并继续执行后续命令。客户端需要处理这些错误。</li>\n<li>性能考虑：虽然事务可以减少网络往返次数，但如果事务中的命令数量过多，可能会导致单个请求过大，反而影响性能。</li>\n</ul>\n<p>Redis 事务的使用场景</p>\n<ul>\n<li>批量操作：当需要执行一系列相关的命令时，可以使用事务来减少网络往返次数，提高性能。</li>\n<li>乐观锁：通过 WATCH 命令监视键的变化，可以实现乐观锁机制，确保在执行事务之前键没有被其他客户端修改。</li>\n<li>模拟事务：虽然 Redis 事务不提供严格的 ACID 特性，但在不需要强一致性的场景下，可以使用事务来模拟事务行为。</li>\n</ul>\n<h2 id=\"redis-多线程\"><a class=\"markdownIt-Anchor\" href=\"#redis-多线程\">#</a> Redis 多线程</h2>\n<p>Redis 作为一种高性能的键值存储系统，最初是单线程设计的，这意味着 Redis 在处理客户端的请求时，包括获取 (socket 读)<br>\n、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的单线程。但如果严格来讲从 Redis 4<br>\n 之后并不是单线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 key 的删除等等。<br>\n这样的设计保证了数据的一致性和简单性，但也限制了 Redis 在多核 CPU 环境下的性能潜力。从 Redis 6.0 开始，Redis<br>\n 引入了多线程的支持，以充分利用现代多核处理器的优势。</p>\n<p>Redis 6 为何引入多线程？</p>\n<p>随着目前行业内越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的<br>\n QPS。常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点，比如：</p>\n<ul>\n<li>\n<p>要管理的 Redis 服务器太多，维护代价大；</p>\n</li>\n<li>\n<p>某些适用于单个 Redis 服务器的命令不适用于数据分区；</p>\n</li>\n<li>\n<p>数据分区无法解决热点读 / 写问题；</p>\n</li>\n<li>\n<p>数据偏斜，重新分配和放大 / 缩小变得更加复杂等等。</p>\n</li>\n</ul>\n<p>从 Redis 自身角度来说，因为读写网络的 read/write 系统调用占用了 Redis 执行期间大部分 CPU 时间，瓶颈主要在于网络的 IO 消耗，<br>\n 优化主要有两个方向:</p>\n<ul>\n<li>\n<p>提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式；</p>\n</li>\n<li>\n<p>使用多线程充分利用多核，典型的实现比如 Memcached。</p>\n</li>\n</ul>\n<p>协议栈优化的这种方式跟 Redis 关系不大，支持多线程是一种最有效最便捷的操作方式。所以总结起来，Redis 支持多线程主要就是两个原因：</p>\n<ul>\n<li>可以充分利用服务器 CPU 资源，目前主线程只能利用一个核；</li>\n<li>多线程任务可以分摊 Redis 同步 IO 读写负荷。</li>\n</ul>\n<p>Redis 多线程的工作原理</p>\n<p>在 Redis 6.0 中，多线程主要用于处理客户端的网络 I/O 操作，包括读取客户端请求、解析请求以及将响应写回到客户端。具体来说：</p>\n<ul>\n<li>多线程 I/O：Redis 在主线程之外创建了若干个 I/O 子线程，这些子线程负责读取客户端的请求数据，并将其传递给主线程进行处理。主线程处理完请求后，子线程再负责将响应写回到客户端。</li>\n<li>命令执行：尽管引入了多线程，Redis 的命令执行仍然是单线程的。这意味着 Redis 仍然保证了数据的一致性，因为所有命令都在同一个线程中顺序执行。</li>\n</ul>\n<p>配置多线程</p>\n<p>Redis 6.0 中的多线程支持需要在 redis.conf 文件中进行配置。Redis 6 的多线程默认是禁用的，只使用主线程。可以通过设置<br>\n io-threads-do-reads 参数来启用多线程 I/O 支持，并指定子线程的数量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">io-threads 4  # 设置子线程的数量</span><br><span class=\"line\">io-threads-do-reads yes  # 启用子线程读取</span><br></pre></td></tr></table></figure>\n<p>官方建议线程数应小于机器的核数，并且给出了一个简单的指导原则：对于 4 核的机器，建议设置 2 或 3 个线程；对于 8 核的机器，建议设置<br>\n 6 个线程。线程数并不是越多越好，一般超过 8 个线程就没有太多的意义了。</p>\n<p>使用场景</p>\n<ul>\n<li>网络 I/O 密集型操作：当 Redis 实例面临大量的网络 I/O 负载时，多线程可以帮助减轻主线程的压力，提高系统的整体吞吐量。</li>\n<li>多核 CPU 利用率：在多核处理器环境下，多线程可以让 Redis 更好地利用硬件资源，特别是在处理高并发请求时。</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>单线程命令执行：尽管 Redis 引入了多线程支持，但命令的执行仍然是单线程的。这意味着 Redis 依然保证了数据的一致性和事务的安全性。</li>\n<li>适用性：多线程功能最适合在网络 I/O 成为性能瓶颈的情况下使用。如果 Redis 实例的 CPU 占用率已经很高，那么开启多线程可能并不会带来显著的性能提升。</li>\n<li>兼容性：在 Redis 的其他模式（如集群模式）中，多线程功能可能不完全适用，因此在使用时需要谨慎。</li>\n</ul>\n<h2 id=\"常见面试问题\"><a class=\"markdownIt-Anchor\" href=\"#常见面试问题\">#</a> 常见面试问题</h2>\n<h3 id=\"redis-为何这么快\"><a class=\"markdownIt-Anchor\" href=\"#redis-为何这么快\">#</a> Redis 为何这么快</h3>\n<ul>\n<li>内存存储：Redis 将所有数据存储在内存中，而不是磁盘上。内存的读写速度远超磁盘，这使得 Redis 能够实现极低的延迟和高吞吐量。内存中的数据访问速度几乎是瞬时的，而磁盘则需要等待机械臂移动到正确的位置才能开始读写，这大大降低了速度。</li>\n<li>高效的数据结构：Redis 提供了多种高效的数据结构，如跳跃表（skiplist）用于实现有序集合（Sorted<br>\nSet），压缩列表（ziplist）用于节省空间，哈希表（hashtable）用于实现散列（Hash）等。这些数据结构经过优化，能够在内存中高效地存储和检索数据。</li>\n<li>合理的数据编码：Redis 根据数据的不同类型和大小，使用不同的编码格式来存储数据。例如，短字符串可能会使用更为紧凑的编码方式，从而减少内存占用并加快处理速度。</li>\n<li>单线程模型：Redis 采用单线程模型来处理客户端的所有请求。这意味着在任何给定的时间内，只有一个客户端请求正在被执行。虽然这限制了并发处理能力，但也消除了多线程之间上下文切换和锁的竞争，从而减少了不必要的开销。</li>\n<li>非阻塞 I/O：Redis 使用事件驱动模型来处理客户端连接和请求。它使用了类似于 epoll 的 I/O 多路复用技术来监听多个客户端连接上的事件，<br>\n当有事件发生时（例如，客户端发送了一个命令），Redis 会立即处理这个事件。这种方式使得 Redis 可以同时处理大量的客户端连接，而不会因为一个客户端的阻塞而影响其他客户端的响应速度。</li>\n<li>异步持久化：为了防止持久化操作影响 Redis 的性能，Redis 提供了异步持久化选项。例如，RDB 快照和 AOF 日志都可以在后台进程执行，不会阻塞主线程处理客户端请求。</li>\n<li>线程分离：Redis 6.0 引入了多线程处理部分 I/O 密集型任务，如 AOF 重写和 RDB 持久化，这样可以进一步提高 Redis 的性能，因为这些任务不再完全阻塞单一线程。</li>\n</ul>\n<h3 id=\"redis为何使用单线程\"><a class=\"markdownIt-Anchor\" href=\"#redis为何使用单线程\">#</a> Redis 为何使用单线程</h3>\n<p>Redis 选择单线程模型的原因有以下几个方面：</p>\n<ul>\n<li>内存操作速度快：Redis 的所有数据都存储在内存中，内存的读写速度非常快。因此，对于基于内存的操作而言，CPU 并不是性能瓶颈。如果使用多线程，反而需要解决多线程同步的问题，这可能会增加额外的 CPU 负担。</li>\n<li>数据结构简单：Redis 中的数据结构相对简单，操作也较为迅速，这使得单线程就能够高效地处理大量的客户端请求。</li>\n<li>非阻塞 I/O 模型：Redis 使用了非阻塞的 I/O 模型，即多路复用 I/O 机制（如 epoll、select 等）。<br>\n这种机制使得单线程可以同时监听多个客户端连接的请求，并在有请求到达时异步地处理这些请求，从而有效地利用了单线程的能力来处理高并发连接。</li>\n<li>简化设计：单线程模型简化了 Redis 的设计和实现。由于不存在多线程间的竞争和同步问题，Redis 的代码更加简洁易懂，同时也减少了潜在的 bug。</li>\n<li>避免上下文切换开销：多线程模型会导致频繁的上下文切换，这会消耗大量的 CPU 资源。单线程模型避免了这种开销，使得 Redis 可以更加高效地使用 CPU 资源。</li>\n<li>易于实现高一致性：单线程模型下，数据的一致性更容易保证，因为不存在多线程并发修改同一份数据的问题。</li>\n<li>避免锁的竞争：在多线程环境下，为了避免数据冲突，通常需要使用锁机制。而锁的竞争会导致一部分线程处于等待状态，从而降低了系统的整体吞吐量。单线程模型避免了这种锁的竞争。</li>\n</ul>\n<p>然而，单线程模型也有其局限性。例如，对于 CPU 密集型的任务，单线程模型可能不是最佳选择，因为这样的任务会阻塞主线程，影响 Redis 处理其他请求的能力。为了解决这个问题，Redis 在后来的版本中引入了多线程来处理 I/O 密集型任务，如 AOF 重写和 RDB 持久化，以此来提升性能。</p>\n<h3 id=\"缓存三大问题以及解决方案\"><a class=\"markdownIt-Anchor\" href=\"#缓存三大问题以及解决方案\">#</a> 缓存三大问题以及解决方案？</h3>\n<ol>\n<li>\n<p>缓存击穿：指的是当某个 key 非常热点，在并发访问量大的情况下，如果这个 key 恰好在这个时刻失效了，那么所有请求都会落到数据库上，造成数据库瞬间压力过大。</p>\n<p>解决方案：</p>\n<ul>\n<li>设置热点数据永不过期：对于热点数据，可以将其设置为永不过期，或者设置一个较长的过期时间。\n<ul>\n<li>优点：\n<ol>\n<li>减少了因缓存失效导致的数据库压力。</li>\n<li>简单易实施。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>可能会导致缓存中的数据长时间不更新，影响数据的新鲜度。</li>\n<li>如果数据量很大，可能会占用较多的内存资源。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>数据更新频率较低，且数据新鲜度要求不高的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>互斥锁：使用互斥锁（Mutex）机制来控制缓存更新的过程。当缓存失效时，先获取锁，然后检查数据库中是否有数据，如果有则更新缓存，最后释放锁。\n<ul>\n<li>优点：\n<ol>\n<li>可以确保在缓存失效时，只有一部分请求会真正落到数据库上，减少了数据库的压力。</li>\n<li>数据更新及时。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>锁的使用会增加系统的复杂性。</li>\n<li>如果并发量极高，可能会出现锁竞争激烈的情况。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>数据更新频繁，且数据新鲜度要求较高的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>懒加载：当缓存失效后，可以先返回旧数据或占位符，然后异步加载最新数据并更新缓存。\n<ul>\n<li>优点：\n<ol>\n<li>用户体验较好，不会立即感知到数据陈旧。</li>\n<li>减少了数据库的瞬时压力。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>数据更新可能有延迟。</li>\n<li>实现复杂度较高。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>数据更新频率适中，对用户体验有一定要求的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>缓存穿透：是指查询一个一定不存在的数据，这个数据在缓存中不存在，同时在数据库中也不存在，每次请求都会直接穿透缓存去查询数据库，造成数据库压力巨大。</p>\n<p>解决方案：</p>\n<ul>\n<li>设置空值缓存：当查询到数据库中不存在的数据时，可以将这个查询结果（通常是 null 或特殊标识）缓存起来，设置一定的过期时间。\n<ul>\n<li>优点：\n<ol>\n<li>直接解决了缓存穿透问题，减少了对数据库的无效请求。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>如果恶意攻击者利用不存在的 key 频繁请求，可能会导致缓存中存储大量无效数据。</li>\n<li>需要合理设置过期时间，避免长期占用缓存空间。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于存在大量无效查询请求的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>布隆过滤器（Bloom Filter）：使用布隆过滤器来判断数据是否存在，可以有效地拦截那些一定不存在的数据查询。\n<ul>\n<li>优点：\n<ol>\n<li>有效拦截不存在的数据查询，减少无效请求。</li>\n<li>占用空间小，查询速度快。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>存在一定的误判率，即可能存在少量的假阳性（False Positive）。</li>\n<li>需要合理设计布隆过滤器的容量和哈希函数数量。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于数据量大且对数据精确性有一定容忍度的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>API 层面的验证：在业务逻辑层面增加对输入数据的校验，提前过滤掉非法或无效的查询请求。\n<ul>\n<li>优点：\n<ol>\n<li>从源头上过滤掉非法请求，减轻后续处理层的压力。</li>\n<li>提升系统的安全性。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>需要在业务逻辑中增加额外的验证步骤，增加了开发工作量。</li>\n<li>可能需要维护一份合法 key 的列表或规则。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于存在非法请求可能性的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>缓存雪崩：是指当缓存中的数据集中过期，导致大量请求同时穿透缓存去查询数据库，造成数据库压力剧增甚至崩溃。</p>\n<p>解决方案：</p>\n<ul>\n<li>分散缓存过期时间：避免大量数据同时过期，可以通过随机化设置过期时间来分散数据的过期时间。\n<ul>\n<li>优点：\n<ol>\n<li>有效避免了大量数据同时过期的情况，降低了数据库的压力。</li>\n<li>实现简单。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>需要合理设置随机过期时间，以确保数据分布均匀。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于数据量较大且有过期时间一致性的风险的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>限流降级：在缓存失效前，通过限流算法来控制请求的流量，一旦超过阈值则进行降级处理，返回默认值或缓存中的旧数据。\n<ul>\n<li>优点：\n<ol>\n<li>通过限流机制保护了后端系统，避免了突发流量的影响。</li>\n<li>可以根据实际情况调整限流策略。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>需要设计合理的降级策略，以确保用户体验不受太大影响。</li>\n<li>实现复杂度较高。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于流量波动较大的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>备用缓存：准备一个备用缓存系统，当主缓存系统出现故障或过载时，可以切换到备用缓存继续服务。\n<ul>\n<li>优点：\n<ol>\n<li>提供了冗余保障，增强了系统的可用性。</li>\n<li>可以平滑地切换到备用系统，减少服务中断时间。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>需要维护两套缓存系统，增加了运维成本。</li>\n<li>切换逻辑需要考虑数据同步问题。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于对系统可用性要求较高的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>异步更新：当缓存失效时，可以先返回旧数据或占位符，然后异步加载最新数据并更新缓存。\n<ul>\n<li>优点：\n<ol>\n<li>用户体验较好，不会立即感知到数据陈旧。</li>\n<li>减少了数据库的瞬时压力。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>数据更新可能有延迟。</li>\n<li>实现复杂度较高。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于数据更新频率适中，对用户体验有一定要求的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"如何保证数据库和redis缓存一致性\"><a class=\"markdownIt-Anchor\" href=\"#如何保证数据库和redis缓存一致性\">#</a> 如何保证数据库和 Redis 缓存一致性？</h3>\n<ol>\n<li>\n<p>最终一致性（Eventual Consistency）</p>\n<p>在分布式系统中，通常追求的是最终一致性而非强一致性。最终一致性意味着在一段时间后，所有数据副本将收敛到同一个状态。对于缓存和数据库来说，这意味着在数据更新后，缓存最终会反映数据库中的最新状态。</p>\n</li>\n<li>\n<p>双写策略</p>\n<ol>\n<li>\n<p>先更新数据库，再删除缓存（Update Database First, Invalidate Cache）</p>\n<p>原理：当数据发生变化时，首先更新数据库中的数据，然后再删除缓存中的对应条目。当下次请求该数据时，由于缓存中没有该数据，所以会重新从数据库中读取并更新缓存。</p>\n<ul>\n<li>优点：\n<ul>\n<li>简单易实现。</li>\n<li>可以避免数据不一致的问题。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>如果删除缓存失败，则可能导致缓存中的数据比数据库中的数据旧。</li>\n<li>删除缓存操作可能会失败，需要有重试机制。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>更新操作较少，且对数据一致性要求较高的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>先删除缓存，再更新数据库（Invalidate Cache First, Update Database）</p>\n<p>原理：当数据发生变化时，先删除缓存中的数据，然后再更新数据库中的数据。</p>\n<ul>\n<li>优点：\n<ul>\n<li>可以避免缓存击穿问题。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>如果更新数据库失败，而缓存已经被删除，那么这段时间内将无法从缓存中获取数据，导致请求直接访问数据库，增加数据库压力。</li>\n<li>如果删除缓存和更新数据库之间有延迟，可能会导致短暂的数据不一致。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>更新操作频繁，但对数据一致性要求稍低的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>延迟双删策略（Double Eviction with Delay）</p>\n<p>原理：当数据更新时，先删除缓存中的数据，然后立即设置一个临时缓存项（如使用 Redis 的 EXPIRE 命令设置一个很短的过期时间），再更新数据库。当临时缓存项过期后，真正的更新操作完成。</p>\n<ul>\n<li>优点：\n<ul>\n<li>减少了直接访问数据库的概率。</li>\n<li>通过设置临时缓存项，可以减少更新数据库失败导致的数据不一致问题。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>实现相对复杂。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>高并发场景下，对数据一致性要求较高的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>使用消息队列</p>\n<p>原理：当数据在数据库中更新后，发送一个消息到消息队列中，由另一个消费者监听消息队列并更新缓存。</p>\n<ul>\n<li>优点：\n<ul>\n<li>解耦数据库和缓存更新操作。</li>\n<li>可以异步处理缓存更新，减少数据库更新时的延迟。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>增加了系统的复杂性。</li>\n<li>需要处理消息队列的可靠性和消息重复消费问题。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>高并发、大数据量的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>缓存预热</p>\n<p>原理：在系统启动或数据更新后，主动将数据加载到缓存中。</p>\n<ul>\n<li>优点：\n<ul>\n<li>避免冷启动时大量请求直接访问数据库。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>需要额外的机制来触发预热操作。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>系统启动或数据更新后，希望尽快恢复服务的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>乐观锁或版本号</p>\n<p>原理：在数据库中为数据添加一个版本号字段，每次更新时都需要检查版本号是否匹配。如果不匹配，则说明数据已被其他操作更新，需要重新获取最新数据并再次尝试更新。</p>\n<ul>\n<li>优点：\n<ul>\n<li>保证了数据的一致性。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>可能会出现更新冲突，需要重试机制。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>对数据一致性要求极高的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"如何保证-redis-的高并发\"><a class=\"markdownIt-Anchor\" href=\"#如何保证-redis-的高并发\">#</a> 如何保证 Redis 的高并发？</h3>\n<ol>\n<li>单机优化\n<ul>\n<li>硬件优化：选择高性能的硬件设备，如 SSD 硬盘、高速网络接口卡以及足够的内存。</li>\n<li>内存管理：合理设置 Redis 的最大内存限制，避免内存溢出导致的服务不可用。</li>\n<li>持久化策略：选择合适的持久化方式（RDB 或 AOF），并调整相关的配置，以减少对性能的影响。</li>\n<li>数据结构选择：根据应用场景选择合适的数据结构，以减少内存使用并提高访问效率。</li>\n</ul>\n</li>\n<li>主从复制\n<ul>\n<li>读写分离：通过主从复制实现读写分离，主节点负责写操作，从节点负责读操作，可以显著提高并发处理能力。</li>\n<li>自动故障转移：使用 Redis Sentinel（哨兵）机制来监控主从节点的状态，并在主节点发生故障时自动进行故障转移，保证高可用性。</li>\n</ul>\n</li>\n<li>分布式集群\n<ul>\n<li>Redis Cluster：使用 Redis 集群来水平扩展 Redis，集群可以自动将数据分片存储在不同的节点上，并提供数据复制功能。这样可以支持更高的并发量和更大的数据集。</li>\n<li>数据分片：手动将数据分片存储在不同的 Redis 实例上，可以减轻单个节点的压力。</li>\n</ul>\n</li>\n<li>客户端优化\n<ul>\n<li>连接池：使用连接池来复用客户端连接，减少建立和销毁连接的开销。</li>\n<li>批处理：批量处理请求，例如使用 MGET、MSET 等命令来一次处理多个键值对，减少网络往返次数。</li>\n<li>命令管道：使用 Redis 的命令管道（pipelining）特性，将多个命令一次性发送给 Redis 服务器，减少网络延迟。</li>\n</ul>\n</li>\n<li>调整配置\n<ul>\n<li>网络配置：优化网络配置，例如调整 TCP 缓冲区大小、禁用 Nagle 算法等，以提高网络传输效率。</li>\n<li>I/O 多路复用：Redis 使用事件驱动模型来处理客户端请求，可以处理大量的并发连接。确保操作系统和 Redis 的事件处理机制配置得当。</li>\n</ul>\n</li>\n<li>监控与调优\n<ul>\n<li>性能监控：定期监控 Redis 的性能指标，如 CPU 使用率、内存使用情况、网络延迟等，以便及时发现性能瓶颈。</li>\n<li>负载均衡：使用负载均衡器来分配客户端请求，确保各个 Redis 节点的负载均衡。</li>\n</ul>\n</li>\n<li>避免热点 Key\n<ul>\n<li>Key 的设计：合理设计 Key，避免热点 Key 的产生，例如使用哈希分片（Hash Ring）来分散请求。</li>\n<li>过期时间：为热点 Key 设置合理的过期时间，并且可以使用随机化过期时间来避免雪崩效应。</li>\n</ul>\n</li>\n<li>异步处理\n<ul>\n<li>异步持久化：使用异步的方式进行持久化操作，避免阻塞主线程。</li>\n<li>多线程处理：Redis 6.0 引入了多线程模型来处理部分 I/O 密集型任务，如 AOF 重写和 RDB 持久化，可以进一步提升性能。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"redis-如何保证原子性\"><a class=\"markdownIt-Anchor\" href=\"#redis-如何保证原子性\">#</a> Redis 如何保证原子性？</h3>\n<ol>\n<li>单线程模型: Redis 采用单线程模型来处理所有的客户端请求。这意味着在同一时间内，只有一个客户端请求被处理，因此消除了并发竞争条件，保证了命令执行的顺序性和原子性。</li>\n<li>命令级别的原子性: Redis 中的大多数命令都是原子性的，这意味着它们在执行过程中不会被其他操作打断。例如，SET, GET, INCR,<br>\nDECR, HSET, HGET 等命令在执行时，整个操作过程不会被中断，从而保证了操作的完整性。</li>\n<li>事务机制: Redis 提供了事务机制，允许用户将多个命令打包成一个事务，通过 MULTI 命令开启事务，然后执行一系列命令，最后通过 EXEC 命令提交事务。<br>\n在事务中，Redis 会将这些命令放入队列中，等到事务提交时，这些命令会按照顺序依次执行，从而保证了事务内的操作的原子性。</li>\n<li>WATCH 命令: WATCH 命令可以监视一个或多个键，如果监视的键在执行 EXEC 之前被其他客户端修改了，那么事务会被取消。这实际上是一种乐观锁机制，用来保证在某些特定场景下的数据一致性。</li>\n<li>Lua 脚本: Redis 允许在服务器端执行 Lua 脚本来处理复杂的操作。Lua 脚本在执行时具有原子性，即整个脚本作为一个整体执行，期间不会被打断。<br>\n这意味着脚本中的多个 Redis 命令会被作为一个单独的操作来执行，从而保证了操作的原子性。</li>\n<li>数据结构的设计: Redis 内部的数据结构设计也是为了支持高效的原子操作。例如，对于有序集合（Sorted<br>\nSets），Redis 使用了跳跃表（Skiplist），这是一种支持快速插入、删除和查找操作的数据结构，可以高效地支持原子性操作。</li>\n</ol>\n<h2 id=\"常用命令\"><a class=\"markdownIt-Anchor\" href=\"#常用命令\">#</a> 常用命令</h2>\n<h3 id=\"cmd访问redis\"><a class=\"markdownIt-Anchor\" href=\"#cmd访问redis\">#</a> cmd 访问 redis</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli.exe -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串string相关命令\"><a class=\"markdownIt-Anchor\" href=\"#字符串string相关命令\">#</a> 字符串 (String) 相关命令</h3>\n<ul>\n<li>SET key value：设置键 key 的值为 value。</li>\n<li>GET key：获取键 key 的值。</li>\n<li>GETSET key value：设置键 key 的值为 value，并返回键 key 的旧值。</li>\n<li>INCR key：将键 key 的值加一，仅支持整数值。</li>\n<li>INCRBY key increment：将键 key 的值加上指定的增量 increment。</li>\n<li>DECR key：将键 key 的值减一。</li>\n<li>DECRBY key decrement：将键 key 的值减去指定的减量 decrement。</li>\n<li>APPEND key value：将 value 追加到键 key 的值后面。</li>\n<li>STRLEN key：返回键 key 的值的长度。</li>\n</ul>\n<h3 id=\"列表list相关命令\"><a class=\"markdownIt-Anchor\" href=\"#列表list相关命令\">#</a> 列表 (List) 相关命令</h3>\n<ul>\n<li>LPUSH key value [value …]：将一个或多个值 value 插入到键 key 的列表头部。</li>\n<li>RPUSH key value [value …]：将一个或多个值 value 插入到键 key 的列表尾部。</li>\n<li>LPOP key：移除并返回键 key 的列表的第一个元素。</li>\n<li>RPOP key：移除并返回键 key 的列表的最后一个元素。</li>\n<li>LRANGE key start stop：返回键 key 的列表中指定范围内的元素。</li>\n<li>LREM key count value：移除键 key 的列表中等于 value 的元素，count 参数决定了移除的数量。</li>\n<li>LSET key index value：将键 key 的列表中的指定位置 index 的值设为 value。</li>\n<li>LLEN key：返回键 key 的列表的长度。</li>\n</ul>\n<h3 id=\"哈希hash相关命令\"><a class=\"markdownIt-Anchor\" href=\"#哈希hash相关命令\">#</a> 哈希 (Hash) 相关命令</h3>\n<ul>\n<li>HSET key field value：将哈希表 key 中的域 field 的值设为 value。</li>\n<li>HGET key field：返回哈希表 key 中域 field 的值。</li>\n<li>HGETALL key：返回哈希表 key 中所有域的值。</li>\n<li>HDEL key field [field …]：删除一个或多个哈希表 key 中的域 field。</li>\n<li>HEXISTS key field：查看哈希表 key 中指定域 field 是否存在。</li>\n<li>HLEN key：返回哈希表 key 中域的数量。</li>\n<li>HKEYS key：返回哈希表 key 中所有域的列表。</li>\n<li>HVALS key：返回哈希表 key 中所有值的列表。</li>\n</ul>\n<h3 id=\"集合set相关命令\"><a class=\"markdownIt-Anchor\" href=\"#集合set相关命令\">#</a> 集合 (Set) 相关命令</h3>\n<ul>\n<li>SADD key member [member …]：将一个或多个成员 member 加入到集合 key 中。</li>\n<li>SMEMBERS key：返回集合 key 中的所有成员。</li>\n<li>SCARD key：返回集合 key 中的成员数。</li>\n<li>SREM key member [member …]：将一个或多个成员 member 从集合 key 中移除。</li>\n<li>SISMEMBER key member：判断成员 member 是否是集合 key 的成员。</li>\n<li>SINTER key [key …]：返回给定多个集合的交集成员。</li>\n<li>SUNION key [key …]：返回给定多个集合的并集成员。</li>\n<li>SDIFF key [key …]：返回给定多个集合的差集成员。</li>\n</ul>\n<h3 id=\"有序集合sorted-set相关命令\"><a class=\"markdownIt-Anchor\" href=\"#有序集合sorted-set相关命令\">#</a> 有序集合 (Sorted Set) 相关命令</h3>\n<ul>\n<li>ZADD key score member [score member …]：将一个或多个成员 member 及其分数 score 加入到有序集合 key 中。</li>\n<li>ZRANGE key start stop [WITHSCORES]：返回有序集合 key 中指定范围内的成员。</li>\n<li>ZREVRANGE key start stop [WITHSCORES]：返回有序集合 key 中指定范围内的成员，成员按分数值递减排列。</li>\n<li>ZREM key member [member …]：将一个或多个成员 member 从有序集合 key 中移除。</li>\n<li>ZCARD key：返回有序集合 key 中的成员数。</li>\n<li>ZSCORE key member：返回有序集合 key 中成员 member 的分数值。</li>\n<li>ZCOUNT key min max：计算在有序集合 key 中指定区间分数的成员数。</li>\n</ul>\n<h3 id=\"通用命令\"><a class=\"markdownIt-Anchor\" href=\"#通用命令\">#</a> 通用命令</h3>\n<ul>\n<li>EXPIRE key seconds：为键 key 设置生存时间。</li>\n<li>TTL key：返回键 key 剩余的生存时间。</li>\n<li>DEL key [key …]：删除一个或多个键 key。</li>\n<li>SELECT index：选择编号为 index 的数据库。</li>\n<li>FLUSHDB：清除当前数据库中的所有数据。</li>\n<li>FLUSHALL：清除所有数据库中的所有数据。</li>\n<li>KEYS pattern：返回匹配 pattern 的所有键。</li>\n<li>TYPE key：返回键 key 的类型。</li>\n</ul>\n",
            "tags": [
                "后端",
                "数据库",
                "NoSQL",
                "缓存",
                "Redis"
            ]
        },
        {
            "id": "https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Spring%E3%80%91spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/",
            "url": "https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Spring%E3%80%91spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/",
            "title": "【Spring】Spring面试题汇总",
            "date_published": "2024-09-13T03:24:41.000Z",
            "content_html": "<h2 id=\"spring的基本概念\"><a class=\"markdownIt-Anchor\" href=\"#spring的基本概念\">#</a> Spring 的基本概念</h2>\n<h3 id=\"1-spring-是什么\"><a class=\"markdownIt-Anchor\" href=\"#1-spring-是什么\">#</a> 1、Spring 是什么？</h3>\n<p>Spring 是一个轻量级 Java 开发框架，最早有 Rod Johnson 创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的<br>\n JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发 Java 应用程序提供全面的基础架构支持。Spring 负责基础架构，因此 Java<br>\n 开发者可以专注于应用程序的开发。Spring 最根本的使命是解决企业级应用开发的复杂性，即简化 Java 开发。</p>\n<h3 id=\"2-spring-带来哪些好处\"><a class=\"markdownIt-Anchor\" href=\"#2-spring-带来哪些好处\">#</a> 2、Spring 带来哪些好处？</h3>\n<ul>\n<li>\n<p>基于 POJO 的轻量级和最小侵入性编程。</p>\n</li>\n<li>\n<p>DI 机制将对象之间的依赖关系交由框架处理，减低组件间的耦合性。</p>\n</li>\n<li>\n<p>基于 AOP 技术支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。</p>\n</li>\n<li>\n<p>对于主流的应用框架提供了集成支持。</p>\n</li>\n</ul>\n<h3 id=\"3-说说-spring-有哪些模块\"><a class=\"markdownIt-Anchor\" href=\"#3-说说-spring-有哪些模块\">#</a> 3、说说 Spring 有哪些模块？</h3>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Spring%E3%80%91spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/26e3bd5f237ab05ae63f5a697805b33b.png\" class=\"\" title=\"Spring模块\">\n<p>上图对应的是 Spring 4.x 版本的架构图，主要包括以下八个模块：</p>\n<ul>\n<li>\n<p><strong>Spring Core</strong>：基础，提供 IOC 和 DI 能力，可以说 Spring 其他所有的功能都依赖于该类库。</p>\n</li>\n<li>\n<p><strong>Spring Aspects</strong>：该模块为集成 AspectJ 提供支持。</p>\n</li>\n<li>\n<p><strong>Spring AOP</strong>：提供面向方面的编程实现。</p>\n</li>\n<li>\n<p><strong>Spring JDBC</strong>：Java 数据库连接。</p>\n</li>\n<li>\n<p><strong>Spring JMS</strong>：Java 消息服务。</p>\n</li>\n<li>\n<p><strong>Spring ORM</strong>：用于支持 Hibernate、Mybatis 等 ORM 工具。</p>\n</li>\n<li>\n<p><strong>Spring Web</strong>：为创建 Web 应用程序提供支持。</p>\n</li>\n<li>\n<p><strong>Spring Test</strong>：提供了对 JUnit 和 TestNG 测试框架的支持。</p>\n</li>\n</ul>\n<h3 id=\"4-spring-中使用了哪些设计模式\"><a class=\"markdownIt-Anchor\" href=\"#4-spring-中使用了哪些设计模式\">#</a> 4、Spring 中使用了哪些设计模式？</h3>\n<ul>\n<li>\n<p><strong>工厂模式</strong>：包括简单工厂和工厂方法，如通过 BeanFactory 或 ApplicationContext 创建 Bean 对象。</p>\n</li>\n<li>\n<p><strong>单例模式</strong>：Spring 中的 Bean 对象默认就是单例模式。</p>\n</li>\n<li>\n<p><strong>代理模式</strong>：Spring AOP 就是基于代理实现的，包括 JDK 动态代理和 CGlib 技术。</p>\n</li>\n<li>\n<p><strong>模板方法模式</strong>：Spring 中 jdbcTemplate 等以 Template 结尾对数据库操作的类就使用到模板模式。</p>\n</li>\n<li>\n<p><strong>观察者模式</strong>：Spring 事件驱动模型就是观察者模式很经典的应用。</p>\n</li>\n<li>\n<p><strong>适配器模式</strong>：Spring MVC 中，DispatcherServlet 根据请求解析到对应的 Handler（也就是我们常说的 Controller）后，开始由<br>\n HandlerAdapter 适配器处理。</p>\n</li>\n<li>\n<p><strong>装饰者模式</strong>：使用 DataSource 在不改动代码情况下切换数据源。</p>\n</li>\n<li>\n<p><strong>策略模式</strong>：Spring 对资源的访问，如 Resource 接口。</p>\n</li>\n</ul>\n<h3 id=\"5-spring-中有哪些不同类型事件\"><a class=\"markdownIt-Anchor\" href=\"#5-spring-中有哪些不同类型事件\">#</a> 5、Spring 中有哪些不同类型事件？</h3>\n<p>Spring 提供了以下 5 种标准的事件：</p>\n<ul>\n<li>\n<p><strong>上下文更新事件（ContextRefreshedEvent）</strong>：在调用 ConfigurableApplicationContext 接口中的 refresh () 方法时被触发。</p>\n</li>\n<li>\n<p><strong>上下文开始事件（ContextStartedEvent）</strong>：当容器调用 ConfigurableApplicationContext 的 Start () 方法开始 / 重新开始容器时触发该事件。</p>\n</li>\n<li>\n<p><strong>上下文停止事件（ContextStoppedEvent）</strong>：当容器调用 ConfigurableApplicationContext 的 Stop () 方法停止容器时触发该事件。</p>\n</li>\n<li>\n<p><strong>上下文关闭事件（ContextClosedEvent）</strong>：当 ApplicationContext 被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。</p>\n</li>\n<li>\n<p><strong>请求处理事件（RequestHandledEvent）</strong>：在 Web 应用中，当一个 http 请求（request）结束触发该事件。</p>\n</li>\n</ul>\n<p>至于如果监听这些事件：</p>\n<p>一个 Bean 实现了 ApplicationListener 接口，当一个 ApplicationEvent 被发布以后，Bean 会自动被通知。</p>\n<h2 id=\"spring-ioc\"><a class=\"markdownIt-Anchor\" href=\"#spring-ioc\">#</a> Spring IOC</h2>\n<h3 id=\"1-什么是-ioc\"><a class=\"markdownIt-Anchor\" href=\"#1-什么是-ioc\">#</a> 1、什么是 IOC？</h3>\n<p>IOC 是 Inversion of Control 的缩写，即控制反转。IOC 不是一项技术，而是一种设计思想。在 Java 开发中，Ioc 意味着你可以将设计好的对象交给<br>\n IOC 容器，完成初始化和管理，当你需要时由容器提供控制。</p>\n<p>Spring IOC 可谓是 Spring 的核心，对于 Spring 框架而言，所谓 IOC 就是由 Spring<br>\n 来负责控制对象的生命周期和对象间的关系。正这个控制过程中，需要动态的向某个对象提供它所需要的其他对象，这一点是通过<br>\n DI（Dependency Injection，依赖注入）来实现的。</p>\n<h3 id=\"2-ioc-的作用或好处\"><a class=\"markdownIt-Anchor\" href=\"#2-ioc-的作用或好处\">#</a> 2、IOC 的作用或好处？</h3>\n<p>实现对象间的解耦，同时降低应用开发的代码量和复杂度，使开发人员更专注业务。</p>\n<h3 id=\"3-ioc-的实现原理\"><a class=\"markdownIt-Anchor\" href=\"#3-ioc-的实现原理\">#</a> 3、IOC 的实现原理？</h3>\n<p>Spring 的 IOC 是基于工厂设计模式在加上反射实现。</p>\n<h3 id=\"4-spring-有哪些容器类\"><a class=\"markdownIt-Anchor\" href=\"#4-spring-有哪些容器类\">#</a> 4、Spring 有哪些容器类？</h3>\n<ul>\n<li><strong>BeanFactory</strong>：这是一个最简单的容器，它主要的功能是为依赖注入（DI）提供支持。</li>\n<li><strong>ApplicationContext</strong>：Application Context 是 Spring 中的高级容器。和 BeanFactory 类似，它可以加载和管理配置文件中定义的<br>\n Bean。 另外，它还增加了企业所需要的功能，比如，从属性文件中解析文本信息和将事件传递给所指定的监听器。</li>\n</ul>\n<p>一些常被使用的 ApplicationContext 实现类：</p>\n<ul>\n<li><strong>FileSystemXmlApplicationContext</strong>：该容器从 XML 文件中加载已被定义的 Bean， 需要提供 XML 文件的完整路径。</li>\n<li><strong>ClassPathXmlApplicationContext</strong>：同样从 XML 文件中加载已被定义的 Bean，但无需提供完整路径，因为它会从 CLASSPATH<br>\n 中搜索配置文件。</li>\n<li><strong>WebXmlApplicationContext</strong>：该容器会在一个 Web 应用程序的范围内加载在 XML 文件中已被定义的 Bean。</li>\n</ul>\n<h3 id=\"5-beanfactory-和-applicationcontext-的区别\"><a class=\"markdownIt-Anchor\" href=\"#5-beanfactory-和-applicationcontext-的区别\">#</a> 5、BeanFactory 和 ApplicationContext 的区别？</h3>\n<p>二者都是 Spring 框架的两大核心接口，都可以当做 Spring 的容器。其中 ApplicationContext 是 BeanFactory 的子接口。</p>\n<ul>\n<li>\n<p>BeanFactory 是 Spring 里面最底层的接口，包含了各种 Bean 的定义，读取配置文档，管理 Bean 的加载、实例化，控制 Bean<br>\n 的生命周期，维护对象之间的依赖关系等功能。</p>\n</li>\n<li>\n<p>ApplicationContext 接口作为 BeanFactory 的派生，除了提供 BeanFactory 所具有的功能外，还提供了更完整的框架功能：</p>\n<ul>\n<li>继承 MessageSource，支持国际化。</li>\n<li>统一的资源文件访问方式。</li>\n<li>提供在监听器中注册 Bean 的事件。</li>\n<li>支持同时加载多个配置文件。</li>\n<li>载入多个（有继承关系）上下文，使得每一个上下文都专注于一个特定的层次，如应用的 Web 层。</li>\n</ul>\n</li>\n</ul>\n<p><strong>具体区别体现在以下三个方面：</strong></p>\n<ol>\n<li>\n<p>加载方式不同</p>\n<ul>\n<li>\n<p>BeanFactroy 采用的懒加载方式注入 Bean，即只有在使用到某个 Bean 时才对该 Bean 实例化。这样，我们就不能在程序启动时发现一些存在的<br>\n Spring 的配置问题。</p>\n</li>\n<li>\n<p>ApplicationContext 是在启动时一次性创建了所有的 Bean。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>创建方式不同</p>\n<ul>\n<li>BeanFactory 通常以编程的方式被创建。</li>\n<li>ApplicationContext 还能以声明的方式创建，如使用 ContextLoader。</li>\n</ul>\n</li>\n<li>\n<p>注册方式不同</p>\n<ul>\n<li>二者都支持 BeanPostProcessor、BeanFactoryPostProcessor 的使用，但 BeanFactory 需要手动注册，而 ApplicationContext<br>\n 则是自动注册。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"6-有哪些注入方式以及区别\"><a class=\"markdownIt-Anchor\" href=\"#6-有哪些注入方式以及区别\">#</a> 6、有哪些注入方式以及区别？</h3>\n<p>Spring 支持多种依赖注入的方式，包括但不限于：</p>\n<ul>\n<li>构造器注入（Constructor Injection）</li>\n<li>属性注入（Property or Setter Injection）</li>\n<li>字段注入（Field Injection）</li>\n</ul>\n<h4 id=\"构造器注入\"><a class=\"markdownIt-Anchor\" href=\"#构造器注入\">#</a> 构造器注入</h4>\n<p>构造器注入是指通过构造器参数来传递依赖项。这种方式可以确保依赖项在对象创建时就已经存在，有助于提高对象的不可变性和稳定性。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SomeService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SomeDependency dependency;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">SomeService</span><span class=\"params\">(SomeDependency dependency)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dependency = Objects.requireNonNull(dependency, <span class=\"string\">&quot;dependency must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 Spring Boot 中，可以使用 @Autowired 注解来标记构造器，表明这是一个需要依赖注入的构造器。如果类中有多个构造器，那么需要显式地使用 @Autowired 注解来标注哪个构造器是注入构造器。</p>\n<h4 id=\"属性注入\"><a class=\"markdownIt-Anchor\" href=\"#属性注入\">#</a> 属性注入</h4>\n<p>属性注入是通过对象的 setter 方法来注入依赖项。这是最常用的一种方式，因为它允许在对象创建后注入依赖项，增加了灵活性。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SomeService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> SomeDependency dependency;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setDependency</span><span class=\"params\">(SomeDependency dependency)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dependency = Objects.requireNonNull(dependency, <span class=\"string\">&quot;dependency must not be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"字段注入\"><a class=\"markdownIt-Anchor\" href=\"#字段注入\">#</a> 字段注入</h4>\n<p>字段注入是通过直接在类成员变量上使用 @Autowired 注解来注入依赖项。这种方式简洁，但是不如构造器注入或属性注入那样清晰地表达依赖关系。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SomeService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SomeDependency dependency;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"一些使用上的规约\"><a class=\"markdownIt-Anchor\" href=\"#一些使用上的规约\">#</a> 一些使用上的规约</h4>\n<p>尽管 Spring 支持上述所有依赖注入方式，但 Spring 团队推荐使用构造器注入，特别是对于必填依赖项。构造器注入有助于确保依赖项在对象创建时已经就位，并且有助于提高对象的不可变性。此外，构造器注入使得依赖关系更加明确，便于阅读和理解代码。<br>\n对于可选依赖项，可以使用属性注入或字段注入。然而，无论选择哪种方式，都应该遵循一些最佳实践：</p>\n<ul>\n<li>避免使用字段注入：除非你有非常明确的理由使用字段注入，否则应尽量避免使用。字段注入可能会导致依赖关系不明确，难以维护。</li>\n<li>使用构造器注入：对于必填依赖项，应该优先使用构造器注入。</li>\n<li>使用断言确保依赖项不为空：在构造器或 setter 方法中使用 Objects.requireNonNull () 或类似方法来确保依赖项不是空的。</li>\n<li>考虑使用 @Required 注解：虽然 Spring 现在主要使用 @Autowired，但在某些情况下，@Required 注解仍然有用，它可以用来标记 setter 方法，表示该方法必须被 Spring 的自动装配机制调用。</li>\n</ul>\n<p>这些依赖注入方式的选择取决于具体的应用场景和个人偏好。构造器注入通常被认为是更安全、更清晰的选择，而字段注入虽然简单，但在某些情况下可能会导致代码难以理解和维护。</p>\n<h2 id=\"spring-bean\"><a class=\"markdownIt-Anchor\" href=\"#spring-bean\">#</a> Spring Bean</h2>\n<h3 id=\"1-spring-bean-有哪些作用域\"><a class=\"markdownIt-Anchor\" href=\"#1-spring-bean-有哪些作用域\">#</a> 1、Spring Bean 有哪些作用域？</h3>\n<p>Spring 提供以下五种 Bean 的作用域：</p>\n<ul>\n<li>Singleton：单例模式，默认的作用域。在整个 Spring IoC 容器中，一个 Bean 定义对应一个实例。</li>\n<li>Prototype：原型模式。每次从容器中请求该 Bean 时都会创建一个新的实例。</li>\n<li>Request：对于每一个 HTTP 请求，都会创建一个新的 Bean 实例。这个作用域仅在 Web 环境中可用。</li>\n<li>Session：在一个 HTTP Session 中，一个 Bean 定义对应一个实例。这个作用域同样仅在 Web 环境中可用。</li>\n<li>Global-session：在一个全局的 HTTP Session 中，一个 Bean 定义对应一个实例。这个作用域主要用于 Portlet 环境。</li>\n</ul>\n<p>值的注意的是：使用 Prototype 作用域时需要慎重的思考，因为频繁创建和销毁 Bean 会带来很大的性能开销。</p>\n<h4 id=\"spring-bean-作用域配置方式\"><a class=\"markdownIt-Anchor\" href=\"#spring-bean-作用域配置方式\">#</a> Spring Bean 作用域配置方式</h4>\n<p>Spring 提供了三种配置 Bean 作用域的方式：</p>\n<ul>\n<li>\n<p>XML 配置</p>\n<p>使用基于 XML 的配置文件时，可以通过<bean>标签的 scope 属性来指定 Bean 的作用域。</p>\n<p>例如，配置一个原型模式的 Bean：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;exampleBean&quot;</span>class=<span class=\"string\">&quot;com.example.ExampleBean&quot;</span>scope=<span class=\"string\">&quot;prototype&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>Java 配置类配置</p>\n<p>使用 Java 配置类（通过 @Configuration 和 @Bean 注解）时，可以在 Bean 定义的方法上使用 @Scope 注解来指定作用域。</p>\n<p>例如，定义一个原型模式的 Bean：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ExampleBean <span class=\"title function_\">exampleBean</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExampleBean</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ExampleSingletonBean <span class=\"title function_\">exampleSingletonBean</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExampleSingletonBean</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>Java 注解配置</p>\n<p>使用注解的方式配置 Bean 的作用域也很常见，特别是在组件扫描（Component Scanning）的情况下。可以直接在类或者方法级别使用 @Scope 注解。</p>\n<p>例如将一个 Service 组件设置为原型模式：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExampleBean</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"2-spring-的单例是否线程安全\"><a class=\"markdownIt-Anchor\" href=\"#2-spring-的单例是否线程安全\">#</a> 2、Spring 的单例是否线程安全？</h3>\n<p>Spring 框架中的 Bean 默认是单例模式（Singleton），这意味着在整个应用上下文中只会存在一个 Bean 实例。</p>\n<p>对于无状态的服务层 Bean 来说，Spring 的单例模式本身是线程安全的，因为它们不保存任何实例变量的状态，所有操作都是基于输入参数进行计算。</p>\n<p>但是，如果单例 Bean 有实例变量，并且这些变量在多个线程间共享并且被修改，则可能会出现线程安全问题。</p>\n<p>如何保证线程安全</p>\n<ul>\n<li>避免使用可变对象：尽量使用不可变对象或者确保对象在初始化之后不再改变其状态。</li>\n<li>同步访问：如果必须维护一些可变状态，可以通过同步方法或同步代码块来保证同一时间只有一个线程可以访问和修改这些状态。</li>\n<li>使用并发工具类：利用 Java 并发库中的工具类如 ConcurrentHashMap 等来管理共享资源。</li>\n<li>将 Bean 设计为原型模式：如果每个请求确实都需要独立的数据结构或状态，可以将 Bean 的作用域设置为<br>\n prototype，这样每次请求都会创建一个新的 Bean 实例，这样可能导致性能降低，但可以避免线程安全问题。</li>\n<li>使用 ThreadLocal：对于某些特定场景，可以使用 ThreadLocal 来实现线程之间的隔离，确保每个线程都有自己的独立副本。</li>\n</ul>\n<h3 id=\"3-spring-bean-的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#3-spring-bean-的生命周期\">#</a> 3、Spring Bean 的生命周期？</h3>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Spring%E3%80%91spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AF%A6%E8%A7%A3/0cb7664ed7f4ec62270c528f298e03a3.png\" class=\"\" title=\"Spring Bean 生命周期\">\n<p>Bean 在 Spring 容器中从创建到销毁经历了若干阶段，每一阶段都可以进行个性化定制。</p>\n<ol>\n<li>\n<p>Spring 对 Bean 进行实例化；</p>\n</li>\n<li>\n<p>Spring 将配置和 Bean 的引用注入到对应的属性中；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 BeanNameAware 接口，Spring 将 Bean 的 ID 传递给 setBeanName () 方法；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 BeanFactoryAware 接口，Spring 将调用 setBeanFactory () 方法将 BeanFactory 容器实例传入；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 ApplicationContextAware 接口，Spring 将调用 setApplicationContext () 方法将 Bean 所在的应用上下文的引用传入进来；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 postProcessBeforeInitialization () 方法；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 InitializingBean 接口，Spring 将调用它们的 afterPropertiesSet () 方法。类似地，如果 Bean 使用 initmethod<br>\n 声明了初始化方法，该方法也会被调用；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 postProcessAfterInitialization () 方法；</p>\n</li>\n<li>\n<p>此时，Bean 已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p>\n</li>\n<li>\n<p>如果 Bean 实现了 DisposableBean 接口，Spring 将调用它的 destroy () 接口方法。同样，如果使用 destroymethod<br>\n 声明了销毁方法，该方法也会被调用。</p>\n</li>\n</ol>\n<h2 id=\"spring-aop\"><a class=\"markdownIt-Anchor\" href=\"#spring-aop\">#</a> Spring AOP</h2>\n<h3 id=\"1-什么是-aop-以及作用\"><a class=\"markdownIt-Anchor\" href=\"#1-什么是-aop-以及作用\">#</a> 1、什么是 AOP 以及作用？</h3>\n<p>AOP（Aspect Oriented Programming）是面向切面编程，是 OOP 的一个补充，它允许我们通过引入新的模块，来分离业务逻辑与非业务逻辑，从而实现代码复用。</p>\n<p>传统的 OOP 开发中代码逻辑是至上而下的过程中会长生一些横切性问题（大量与业务无关的重复代码），这些横切问题会散落在代码的各个地方且难以维护。AOP<br>\n 的编程思想就是把业务逻辑和横切的问题进行分离，从而达到解耦的目的，使代码的重用性和开发效率高（目的是重用代码，把公共的代码抽取出来）。</p>\n<p>即 AOP 的作用是对业务逻辑的各个部分进行隔离，降低业务逻辑的耦合性，提高程序的可重用型和开发效率。</p>\n<h3 id=\"2-有哪些应用场景\"><a class=\"markdownIt-Anchor\" href=\"#2-有哪些应用场景\">#</a> 2、有哪些应用场景？</h3>\n<ul>\n<li>事务管理：在多个服务或方法调用中需要统一管理事务的开始、提交或回滚。Spring AOP 可以通过声明式事务管理（例如使用<br>\n @Transactional 注解）来简化事务的控制逻辑。</li>\n<li>日志记录：对系统中的关键方法或接口的日志记录，包括方法调用前后的日志打印，以及异常捕获时的日志记录。这可以通过定义一个切面，在方法执行前后插入日志记录的逻辑来实现。</li>\n<li>权限验证：在调用某些敏感操作之前，需要进行权限验证。通过 AOP 可以在方法调用前进行权限检查，从而确保只有授权用户才能访问特定功能。</li>\n<li>性能监控：监控应用程序中方法的执行时间和资源消耗情况，这对于性能瓶颈分析非常有用。可以定义一个切面来记录方法执行的开始时间和结束时间，并计算执行时间。</li>\n<li>缓存操作：对数据访问操作的结果进行缓存，以减少数据库访问次数，提高响应速度。使用 AOP<br>\n 可以在方法执行前检查缓存，如果缓存中有数据则直接返回，否则执行方法并将结果存入缓存。</li>\n<li>输入输出参数校验：在方法执行前对传入的参数进行校验，确保参数的有效性；在方法执行后对返回值进行校验，确保返回值的正确性。</li>\n<li>资源锁定：在多线程环境中，为了防止资源竞争，可以使用 AOP 来添加锁定逻辑，确保资源的一致性和完整性。</li>\n<li>自定义注解：定义自定义注解，并通过 AOP 处理这些注解，实现特定的行为，如日志记录、性能统计等。</li>\n</ul>\n<h3 id=\"3-切面-切点-连接点-通知以及四者的关系\"><a class=\"markdownIt-Anchor\" href=\"#3-切面-切点-连接点-通知以及四者的关系\">#</a> 3、切面、切点、连接点、通知以及四者的关系？</h3>\n<p>在 Spring AOP 中，切面（Aspect）、切点（Pointcut）、连接点（Joinpoint）和通知（Advice）是核心概念，它们共同协作来实现面向切面编程的功能。下面是这些概念之间的关系：</p>\n<h4 id=\"1连接点-joinpoint\"><a class=\"markdownIt-Anchor\" href=\"#1连接点-joinpoint\">#</a> 1）连接点 (Joinpoint)</h4>\n<h5 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h5>\n<p>连接点是指程序执行过程中的某个特定点，比如方法执行、字段访问等。</p>\n<h5 id=\"示例\"><a class=\"markdownIt-Anchor\" href=\"#示例\">#</a> 示例</h5>\n<p>在代码中，连接点的具体表现形式通常是方法的调用。当你定义了一个方法，并且这个方法被 Spring AOP 所管理，那么这个方法的执行就是一个连接点。例如：</p>\n<pre><code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SomeService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 业务逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>在这个例子中，doSomething () 方法的执行就是一个连接点。</p>\n<p>不是所有的连接点都可以被切面所使用，只有那些被切点表达式匹配上的连接点才是 AOP 能够织入的连接点。</p>\n<h4 id=\"2切点-pointcut\"><a class=\"markdownIt-Anchor\" href=\"#2切点-pointcut\">#</a> 2）切点 (Pointcut)</h4>\n<h5 id=\"概念-2\"><a class=\"markdownIt-Anchor\" href=\"#概念-2\">#</a> 概念</h5>\n<p>切点（Pointcut）是 AOP 中的一个重要概念，它定义了哪些连接点（Joinpoint）会被切面（Aspect）所关注，确定哪些方法或类应该被切面所拦截。<br>\n一个切点可以匹配多个连接点，而一个连接点也可以被多个切点所匹配。</p>\n<p>在 Spring AOP 中，切点的表现形式通常包括以下几个方面：</p>\n<ul>\n<li>方法执行切点：最常用的形式，用于指定特定的方法执行。</li>\n<li>类执行切点：用于指定特定类的所有方法执行。</li>\n<li>异常切点：用于指定方法抛出特定异常时的切点。</li>\n<li>构造函数切点：用于指定构造函数的执行。</li>\n<li>字段访问切点：用于指定字段的访问或修改。</li>\n</ul>\n<p>Spring AOP 支持使用 AspectJ 的切点表达式语法来定义切点。基本语法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execution(modifier-pattern?ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)<span class=\"keyword\">throws</span>-pattern?)</span><br></pre></td></tr></table></figure>\n<p>其中：</p>\n<ul>\n<li>modifiers-pattern：修饰符模式（可选）。</li>\n<li>ret-type-pattern：返回类型模式。</li>\n<li>declaring-type-pattern：声明类型模式（可选）。</li>\n<li>name-pattern：方法名称模式。</li>\n<li>param-pattern：参数模式。</li>\n<li>throws-pattern：抛出异常模式（可选）。</li>\n</ul>\n<h5 id=\"示例-2\"><a class=\"markdownIt-Anchor\" href=\"#示例-2\">#</a> 示例</h5>\n<p>假设我们有一个 UserService 类，包含一个 login 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">login</span><span class=\"params\">(String username, String password)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 登录逻辑</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以通过注解表达式来定义切点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;execution(* com.example.service.UserService.login(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logBefore</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Logging before login&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">userServiceMethods</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;userServiceMethods()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logBeforeAllUserServiceMethods</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Logging before all UserService methods&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中：</p>\n<ul>\n<li><code>execution(* com.example.service.UserService.login(..))</code> ：表示拦截 UserService 类中的 login 方法。</li>\n<li><code>execution(* com.example.service.UserService.*(..))</code> ：表示拦截 UserService 类中的所有方法。</li>\n</ul>\n<h4 id=\"通知-advice\"><a class=\"markdownIt-Anchor\" href=\"#通知-advice\">#</a> 通知 (Advice)</h4>\n<h5 id=\"概念-3\"><a class=\"markdownIt-Anchor\" href=\"#概念-3\">#</a> 概念</h5>\n<p>通知（Advice）是 Spring AOP<br>\n 中的一个核心概念，它定义了在切点（Pointcut）匹配的连接点（Joinpoint）上执行的动作。通知可以分为多种类型，每种类型在不同的时机执行不同的逻辑。下面详细介绍通知的类型及其具体表现形式。</p>\n<p>Spring AOP 支持以下几种主要的通知类型：</p>\n<ol>\n<li>前置通知（Before Advice）：在方法执行前执行（关键字: Before）。</li>\n<li>后置通知（After Returning Advice）：仅当方法正常返回时执行（关键字: AfterReturning）。</li>\n<li>最终通知（After Advice）：无论方法是否抛出异常，都会在方法执行后执行（关键字: After）。</li>\n<li>异常通知（After Throwing Advice）：仅当方法抛出异常时执行（关键字: AfterThrowing）。</li>\n<li>环绕通知（Around Advice）：环绕通知，在方法执行前后都可执行，并且可以决定是否继续执行方法（关键字: Around）。</li>\n</ol>\n<p>不同类型的 AOP 通知适用于不同的场景：</p>\n<ol>\n<li>前置通知：适用于日志记录、权限验证、资源准备等。</li>\n<li>后置通知：适用于日志记录、资源释放、结果处理等。</li>\n<li>最终通知：适用于资源释放、日志记录等。</li>\n<li>异常通知：适用于异常记录、错误处理、资源释放等。</li>\n<li>环绕通知：适用于性能监控、事务管理、权限验证、资源控制等。</li>\n</ol>\n<h5 id=\"示例-3\"><a class=\"markdownIt-Anchor\" href=\"#示例-3\">#</a> 示例</h5>\n<ol>\n<li>\n<p>前置通知（Before Advice）</p>\n<p>前置通知是在方法执行前执行的通知。它可以用来进行一些准备工作，如日志记录、权限验证等。<br>\n示例代码：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logBefore</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Executing: &quot;</span> + method.getName());</span><br><span class=\"line\">        Object[] args = joinPoint.getArgs();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object arg : args) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Argument: &quot;</span> + arg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，logBefore 方法是一个前置通知，它会在 UserService 类中的所有方法执行前被调用。</p>\n</li>\n<li>\n<p>后置通知（After Returning Advice）</p>\n<p>后置通知是在方法正常返回后执行的通知。它可以用来进行一些清理工作，如关闭资源、记录日志等。<br>\n示例代码：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning(pointcut = &quot;execution(* com.example.service.UserService.*(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logAfterReturning</span><span class=\"params\">(JoinPoint joinPoint, Object result)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; returned: &quot;</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，logAfterReturning 方法是一个后置通知，它会在 UserService 类中的所有方法正常返回后被调用，并接收方法的返回值。</p>\n</li>\n<li>\n<p>最终通知（After Advice）</p>\n<p>最终通知是在方法执行后（无论方法是否正常返回或抛出异常）都会执行的通知。它可以用来进行一些必要的清理工作，如关闭资源等。<br>\n示例代码：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@After(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logFinally</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; has been executed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，logFinally 方法是一个最终通知，它会在 UserService 类中的所有方法执行后被调用。</p>\n</li>\n<li>\n<p>异常通知（After Throwing Advice）</p>\n<p>异常通知是在方法抛出异常后执行的通知。它可以用来记录异常信息、发送报警等。<br>\n示例代码：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterThrowing(pointcut = &quot;execution(* com.example.service.UserService.*(..))&quot;, throwing = &quot;ex&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logAfterThrowing</span><span class=\"params\">(JoinPoint joinPoint, Exception ex)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; threw exception: &quot;</span> + ex.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，logAfterThrowing 方法是一个异常通知，它会在 UserService 类中的所有方法抛出异常后被调用，并接收异常对象。</p>\n</li>\n<li>\n<p>环绕通知（Around Advice）</p>\n<p>环绕通知是在方法执行前后都可执行的通知。它可以完全控制方法的执行流程，包括是否继续执行方法、如何执行等。<br>\n示例代码：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">logAround</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before executing: &quot;</span> + method.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> joinPoint.proceed(); <span class=\"comment\">// 继续执行方法</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;After executing: &quot;</span> + method.getName());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; threw exception: &quot;</span> + e.getMessage());</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，logAround 方法是一个环绕通知，它会在 UserService 类中的所有方法执行前后都被调用，并且可以控制方法的执行流程。</p>\n</li>\n</ol>\n<h4 id=\"切面-aspect\"><a class=\"markdownIt-Anchor\" href=\"#切面-aspect\">#</a> 切面 (Aspect)</h4>\n<h5 id=\"概念-4\"><a class=\"markdownIt-Anchor\" href=\"#概念-4\">#</a> 概念</h5>\n<p>切面（Aspect）是 Spring AOP 中的核心概念之一，它将横切关注点（Cross-cutting<br>\nConcern）模块化为独立的组件。切面包含了多个通知（Advice）和切点（Pointcut），并通过这些通知和切点来实现特定的功能。下面详细介绍切面的概念、组成以及具体的应用场景。</p>\n<p>切面通常由以下几个部分组成：</p>\n<ul>\n<li>切点（Pointcut）：定义了哪些连接点（Joinpoint）会被切面所关注。</li>\n<li>通知（Advice）：定义了在切点匹配的连接点上执行的动作。</li>\n<li>引入（Introduction）：允许向现有类添加新的方法或属性。</li>\n<li>织入（Weaving）：将切面与应用程序的其他部分结合起来的过程。</li>\n</ul>\n<h5 id=\"示例-4\"><a class=\"markdownIt-Anchor\" href=\"#示例-4\">#</a> 示例</h5>\n<p>在 Spring AOP 中，切面通常通过 @Aspect 注解来定义，并且可以包含多个切点和通知。<br>\n示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 前置通知</span></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logBefore</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Executing: &quot;</span> + method.getName());</span><br><span class=\"line\">        Object[] args = joinPoint.getArgs();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object arg : args) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Argument: &quot;</span> + arg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 后置通知</span></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning(pointcut = &quot;execution(* com.example.service.UserService.*(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logAfterReturning</span><span class=\"params\">(JoinPoint joinPoint, Object result)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; returned: &quot;</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 最终通知</span></span><br><span class=\"line\">    <span class=\"meta\">@After(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logFinally</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; has been executed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 异常通知</span></span><br><span class=\"line\">    <span class=\"meta\">@AfterThrowing(pointcut = &quot;execution(* com.example.service.UserService.*(..))&quot;, throwing = &quot;ex&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logAfterThrowing</span><span class=\"params\">(JoinPoint joinPoint, Exception ex)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; threw exception: &quot;</span> + ex.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 环绕通知</span></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">logAround</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before executing: &quot;</span> + method.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> joinPoint.proceed(); <span class=\"comment\">// 继续执行方法</span></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">endTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;After executing: &quot;</span> + method.getName() + <span class=\"string\">&quot; (Time: &quot;</span> + (endTime - startTime) + <span class=\"string\">&quot;ms)&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Method &quot;</span> + method.getName() + <span class=\"string\">&quot; threw exception: &quot;</span> + e.getMessage());</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-aop-的实现原理\"><a class=\"markdownIt-Anchor\" href=\"#4-aop-的实现原理\">#</a> 4、AOP 的实现原理？</h3>\n<p>AOP 是基于代理实现的，Spring 提供了 JDK 动态代理和 CGlib 两种方式来生成代理对象。</p>\n<p>Spring AOP 会根据目标对象是否实现了接口来决定使用哪种代理策略：<br>\n如果目标对象实现了接口，则使用 JDK 动态代理。<br>\n如果目标对象没有实现任何接口，则使用 CGLIB 代理。<br>\n这种策略使得 Spring AOP 能够灵活地适应不同的情况，并且保证了代理对象能够正确地执行增强逻辑。</p>\n<p>以下介绍两种不同的代理策略原理。</p>\n<h4 id=\"jdk-动态代理\"><a class=\"markdownIt-Anchor\" href=\"#jdk-动态代理\">#</a> JDK 动态代理</h4>\n<p>JDK 动态代理是基于 Java 语言反射机制实现的。它要求被代理的对象必须实现一个或多个接口。Spring AOP 会利用这个特性，当目标对象实现了接口时，就会使用<br>\n JDK 动态代理来创建代理对象。</p>\n<p>工作原理：</p>\n<ul>\n<li>当一个对象实现了某个接口时，Spring 会通过 java.lang.reflect.Proxy 类来创建一个代理对象。</li>\n<li>这个代理对象实现了相同的接口，并且其内部持有对原始对象的引用。</li>\n<li>代理对象通过 InvocationHandler 接口来处理方法调用，这样可以在方法调用前后添加额外的行为。</li>\n</ul>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设有一个接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Doing something...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建代理对象</span></span><br><span class=\"line\">    <span class=\"type\">Service</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceImpl</span>();</span><br><span class=\"line\">    <span class=\"type\">Service</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (Service) Proxy.newProxyInstance(</span><br><span class=\"line\">            Service.class.getClassLoader(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[]&#123;Service.class&#125;,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;Before method call&quot;</span>);</span><br><span class=\"line\">                    <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(service, args);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;After method call&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">proxy.doSomething();</span><br></pre></td></tr></table></figure>\n<h4 id=\"cglib\"><a class=\"markdownIt-Anchor\" href=\"#cglib\">#</a> CGlib</h4>\n<p>CGLIB（Code Generation Library）是一个高性能的字节码生成库，它可以在运行时动态生成一个目标类的子类。这意味着即使目标对象没有实现任何接口，也可以通过<br>\n CGLIB 来创建代理对象。<br>\n工作原理：</p>\n<ul>\n<li>CGLIB 通过继承目标类来创建一个新的子类对象。</li>\n<li>在这个子类中，对父类的方法进行增强，也就是在方法调用前后添加额外的行为。</li>\n<li>这种方式不需要目标类实现任何接口，因此更加灵活。</li>\n</ul>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设有一个未实现接口的类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Doing something...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建代理对象</span></span><br><span class=\"line\">    <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\">enhancer.setSuperclass(Service.class);</span><br><span class=\"line\">        enhancer.setCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">MethodInterceptor</span>()&#123;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object obj,Method method,Object[]args,MethodProxy proxy)</span><span class=\"keyword\">throws</span> Throwable&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before method call&quot;</span>);</span><br><span class=\"line\">        Object result=proxy.invokeSuper(obj,args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After method call&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Service service=(Service)enhancer.create();</span><br><span class=\"line\">        service.doSomething();</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "后端",
                "java",
                "spring"
            ]
        },
        {
            "id": "https://silvercrow42.github.io/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/",
            "url": "https://silvercrow42.github.io/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/",
            "title": "【分布式】通过Zookeeper与Redisson实现Spring注解式分布式锁",
            "date_published": "2024-09-10T02:00:01.000Z",
            "content_html": "<p>在分布式系统中，由于服务部署在多个节点中，在运行时数据层面上天生无法互通，因此在处理多线程敏感的数据时，无法像单机应用开发一样通过 java 内部实现的多线程方案来解决。此时我们就需要通过分布式锁的方式来处理数据。</p>\n<p>本文将提供一个在 spring-cloud 基础上通过 ZooKeeper 或者 Redisson 实现的注解式的加锁方案。需要使用到 Spring<br>\nAOP，通过 ZooKeeper 加锁时需要 ZooKeeper 服务，使用 Redisson 加锁时需要使用 Redis 数据库。</p>\n<h2 id=\"依赖\"><a class=\"markdownIt-Anchor\" href=\"#依赖\">#</a> 依赖</h2>\n<p>当使用 Redisson 方式时需要引入 Redisson 依赖，版本号自行匹配替换。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/org.redisson/redisson --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.redisson<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>redisson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;redisson.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当使用 ZooKeeper 方式时需要引入连接 ZooKeeper 的依赖，版本号自行匹配替换。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-recipes --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;curator-recipes.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"配置访问锁服务的组件\"><a class=\"markdownIt-Anchor\" href=\"#配置访问锁服务的组件\">#</a> 配置访问锁服务的组件</h2>\n<h3 id=\"redisson\"><a class=\"markdownIt-Anchor\" href=\"#redisson\">#</a> Redisson</h3>\n<p>使用 redisson 作为锁服务的实现时，需要如下配置类配置 RedissonClient 组件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedissonLockConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.redis.url:redis://localhost:6379&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String redisUrl;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.redis.password:&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String redisPassword;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RedissonClient <span class=\"title function_\">redissonClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Config</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Config</span>();</span><br><span class=\"line\">        <span class=\"type\">SingleServerConfig</span> <span class=\"variable\">singleServerConfig</span> <span class=\"operator\">=</span> config.useSingleServer();</span><br><span class=\"line\">        singleServerConfig.setAddress(redisUrl);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isNotEmpty(redisPassword)) &#123;</span><br><span class=\"line\">            singleServerConfig.setPassword(redisPassword);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Redisson.create(config);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 redisUrl 为 Redis 服务的地址，redisPassword 为 Redis 服务的密码。</p>\n<p>RedissonClient 连接配置可以按需进行调整。</p>\n<h3 id=\"zookeeper\"><a class=\"markdownIt-Anchor\" href=\"#zookeeper\">#</a> ZooKeeper</h3>\n<p>使用 ZooKeeper 作为锁服务的实现时，需要如下配置类配置 CuratorFramework 组件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZooKeeperLockConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.url:localhost:2181&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.timeout:1000&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> timeout;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.retry:3&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> retry;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CuratorFramework <span class=\"title function_\">zkClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ExponentialBackoffRetry</span> <span class=\"variable\">exponentialBackoffRetry</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExponentialBackoffRetry</span>(timeout, retry);</span><br><span class=\"line\">        <span class=\"type\">CuratorFramework</span> <span class=\"variable\">curatorFramework</span> <span class=\"operator\">=</span> CuratorFrameworkFactory.newClient(url, exponentialBackoffRetry);</span><br><span class=\"line\">        curatorFramework.start();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> curatorFramework;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 url 是 ZooKeeper 服务地址，timeout 是连接超时时间，retry 是连接失败重试次数。</p>\n<p>CuratorFramework 连接配置可以按需进行调整。</p>\n<h2 id=\"加锁逻辑\"><a class=\"markdownIt-Anchor\" href=\"#加锁逻辑\">#</a> 加锁逻辑</h2>\n<p>在分布式系统中，多系统之间的数据很可能不互通，因此加锁肯定不是通过原始数据进行加锁。</p>\n<p>在加锁时，我们应该对应原始数据，生成唯一的对应该数据的 token 作为加锁依据的 key，同时该 key 在无论何时对于该原始数据而言生成的都是这个 key。这样一来，通过该 key 明确地指向原始数据进行加锁与解锁。</p>\n<p>例如在系统中，存在张 User 表，该表中 id 列为其主键。那么在进行数据加锁时，则可以考虑以如下格式：“User-[id 数据]” 来进行加锁解锁操作。</p>\n<h2 id=\"加锁实现\"><a class=\"markdownIt-Anchor\" href=\"#加锁实现\">#</a> 加锁实现</h2>\n<p>在进行实现时，首先考虑到一次加锁时可能涉及到多个数据，因此使用 key 集合来进行加锁，timeout 与 timeunit 用于指代锁的超时时长。</p>\n<p>抽象出如下方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(List&lt;String&gt; keys,Long timeout,TimeUnit unit)</span><span class=\"keyword\">throws</span> Exception;</span><br></pre></td></tr></table></figure>\n<p>LockEntity 为锁实例，用于进行解锁操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockEntity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object lock;</span><br><span class=\"line\"></span><br><span class=\"line\">    LockEntity(Object lock) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.lock = lock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lock <span class=\"keyword\">instanceof</span> RLock rLock) &#123;</span><br><span class=\"line\">            rLock.unlock();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lock <span class=\"keyword\">instanceof</span> InterProcessLock interProcessLock) &#123;</span><br><span class=\"line\">            interProcessLock.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>针对不同的锁类型，采取不同的解锁方法</p>\n<h3 id=\"redisson-2\"><a class=\"markdownIt-Anchor\" href=\"#redisson-2\">#</a> Redisson</h3>\n<p>逻辑：先通过 RedissonClient 组件遍历 keys 集合获取所有锁实例，再将以这些锁实例来获取一个 MultiLock 实例，来进行多锁的统一加锁解锁，再根据提供的 timeout 和 unit 加锁并返回 LockEntity 对象用来操作解锁。</p>\n<p>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys,Long timeout,TimeUnit unit)</span>&#123;</span><br><span class=\"line\">        ArrayList&lt;RLock&gt; rLocks=<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(keys.size());</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String key:keys)&#123;</span><br><span class=\"line\">        rLocks.add(redissonClient.getLock(key));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        RLock multiLock=redissonClient.getMultiLock(rLocks.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">RLock</span>[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(timeout!=<span class=\"literal\">null</span>&amp;&amp;timeout&gt;<span class=\"number\">0</span>&amp;&amp;unit!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">        multiLock.lock(timeout,unit);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        multiLock.lock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"zookeeper-2\"><a class=\"markdownIt-Anchor\" href=\"#zookeeper-2\">#</a> ZooKeeper</h3>\n<p>逻辑：同 Redisson 类似，先构造多锁对象，然后使用该对象进行加锁并返回</p>\n<p>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; lockKeys,Long timeout,TimeUnit unit)</span><span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">        InterProcessMultiLock multiLock=<span class=\"keyword\">new</span> <span class=\"title class_\">InterProcessMultiLock</span>(zkClient,lockKeys.stream().toList());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(timeout!=<span class=\"literal\">null</span>&amp;&amp;timeout&gt;<span class=\"number\">0</span>&amp;&amp;unit!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">        multiLock.acquire(timeout,unit);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        multiLock.acquire();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现通过注解加锁\"><a class=\"markdownIt-Anchor\" href=\"#实现通过注解加锁\">#</a> 实现通过注解加锁</h2>\n<h4 id=\"定义注解\"><a class=\"markdownIt-Anchor\" href=\"#定义注解\">#</a> 定义注解</h4>\n<ol>\n<li>\n<p>首先针对锁的实现方式，定义区分注解：</p>\n<ul>\n<li>\n<p>@RedisLock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RedisLock &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">timeout</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimeUnit <span class=\"title function_\">unit</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> TimeUnit.SECONDS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>@ZkLock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ZkLock &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">timeout</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimeUnit <span class=\"title function_\">unit</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> TimeUnit.SECONDS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这两个注解作用于方法上，用于表明当前方法需要使用到分布式锁，以及需要使用到哪种分布式锁，并提供锁的超时时间。</p>\n</li>\n<li>\n<p>其次针对方法参数中的的同步参数，提供一个注解 @SyncArg。</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.PARAMETER&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SyncArg &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 加锁依据，填入Spel表达式，用于生成锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * 应该确保每一个加锁对象能够生成一个固定的且独立的key</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用时可用上下文包括 arg：当前参数，method：当前运行的方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    String <span class=\"title function_\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"string\">&quot;#arg.hashCode()&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 是否采用多对象解析方式，多对象时将产生多个锁并同步加锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 当传入对象实现了 Iterable时，将遍历每一个子项，并且生成key时arg为当前遍历到的对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 当传入对象实现了Map时，将遍历每个Entry，生成key时arg为当前Entry</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">isMulti</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该注解作用于方法参数，表明该参数需要参照 value 值生成 key 来加锁，isMulti 用于标识当前参数是否是多对象参数。</p>\n</li>\n</ol>\n<h4 id=\"处理注解\"><a class=\"markdownIt-Anchor\" href=\"#处理注解\">#</a> 处理注解</h4>\n<p>首先，通过一个上下文对象用来自动生成加锁的 key。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockContext</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 被加锁的参数对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object arg;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成key的Spel表达式</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String keyExpression;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 是否为多对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> multi;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Getter(AccessLevel.PACKAGE)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; params;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(SyncArg syncArg, Object arg)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(arg, syncArg.value(), syncArg.isMulti());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(Object arg, String keyExpression, <span class=\"type\">boolean</span> multi)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(arg, keyExpression, multi, <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(Object arg, String keyExpression, <span class=\"type\">boolean</span> multi, Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.arg = arg;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.keyExpression = keyExpression;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.multi = multi;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.params = params;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key   key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 用于链式调用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockContext <span class=\"title function_\">addParam</span><span class=\"params\">(String key, Object value)</span> &#123;</span><br><span class=\"line\">        params.put(key, value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 用于链式调用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockContext <span class=\"title function_\">removeParam</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        params.remove(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getKey(<span class=\"keyword\">new</span> <span class=\"title class_\">SpelExpressionParser</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成key</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> parser Spel表达式解析器</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getKey</span><span class=\"params\">(SpelExpressionParser parser)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StandardEvaluationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StandardEvaluationContext</span>();</span><br><span class=\"line\">        HashMap&lt;String, Object&gt; contextMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(params);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!contextMap.containsKey(<span class=\"string\">&quot;arg&quot;</span>)) &#123;</span><br><span class=\"line\">            contextMap.put(<span class=\"string\">&quot;arg&quot;</span>, arg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        context.setVariables(contextMap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parser.parseExpression(keyExpression).getValue(context, String.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里通过继承抽象类的方式在抽象类中提供一些公共方法，由子类进行加锁的实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 格式化生成的key，在生成加锁key时会经过该方法，并以返回的key作为最终加锁时的key</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> generatedKey 通过上下文对象自动生成的key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 格式化后的key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过LockContext的形式生成锁key再加锁</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockContexts 用于生成锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeout      锁超时时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit         时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 锁对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> LockEntity <span class=\"title function_\">doLockByContext</span><span class=\"params\">(List&lt;LockContext&gt; lockContexts, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> doLock(getLockKeys(lockContexts), timeout, unit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> doLock(keys, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过锁keys进行加锁，由子类实现</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> keys    锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeout 超时时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit    时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 锁对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据方法及入参解析出LockContext列表</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method 加锁的方法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args   入参</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> LockContext列表</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> List&lt;LockContext&gt; <span class=\"title function_\">getLockContexts</span><span class=\"params\">(Method method, Object[] args)</span> &#123;</span><br><span class=\"line\">        Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class=\"line\">        ArrayList&lt;LockContext&gt; lockContexts = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; parameterAnnotations.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取参数注解，与参数一一对应</span></span><br><span class=\"line\">            Annotation[] annotations = parameterAnnotations[i];</span><br><span class=\"line\">            <span class=\"comment\">//找到@SyncArg注解</span></span><br><span class=\"line\">            <span class=\"type\">SyncArg</span> <span class=\"variable\">syncArg</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Annotation annotation : annotations) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (annotation <span class=\"keyword\">instanceof</span> SyncArg syncArgA) &#123;</span><br><span class=\"line\">                    syncArg = syncArgA;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (syncArg != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//注解存在则通过注解构造上下文对象</span></span><br><span class=\"line\">                <span class=\"type\">LockContext</span> <span class=\"variable\">lockContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(syncArg, args[i]);</span><br><span class=\"line\">                lockContext.addParam(<span class=\"string\">&quot;method&quot;</span>, method);</span><br><span class=\"line\">                lockContexts.add(lockContext);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lockContexts;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过上下文对象列表生成key集合</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockContexts 上下文对象列表</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> key集合</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> HashSet&lt;String&gt; <span class=\"title function_\">getLockKeys</span><span class=\"params\">(List&lt;LockContext&gt; lockContexts)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//解析上下文列表，生成key</span></span><br><span class=\"line\">        HashSet&lt;String&gt; keys = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">SpelExpressionParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SpelExpressionParser</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (LockContext lockContext : lockContexts) &#123;</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">multi</span> <span class=\"operator\">=</span> lockContext.isMulti();</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">arg</span> <span class=\"operator\">=</span> lockContext.getArg();</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">keyExpression</span> <span class=\"operator\">=</span> lockContext.getKeyExpression();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (multi &amp;&amp; arg <span class=\"keyword\">instanceof</span> Iterable&lt;?&gt; iterable) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//多对象模式且参数对象为Iterable时</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Object o : iterable) &#123;</span><br><span class=\"line\">                    <span class=\"type\">LockContext</span> <span class=\"variable\">singleContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(o, keyExpression, <span class=\"literal\">false</span>, lockContext.getParams());</span><br><span class=\"line\">                    keys.add(formatKey(singleContext.getKey(parser)));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (multi &amp;&amp; arg <span class=\"keyword\">instanceof</span> Map&lt;?, ?&gt; map) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//多对象模式且参数对象为map时</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Map.Entry&lt;?, ?&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">LockContext</span> <span class=\"variable\">singleContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(entry, keyExpression, <span class=\"literal\">false</span>, lockContext.getParams());</span><br><span class=\"line\">                    keys.add(formatKey(singleContext.getKey(parser)));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                keys.add(formatKey(lockContext.getKey(parser)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> keys;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"redisson实现\"><a class=\"markdownIt-Anchor\" href=\"#redisson实现\">#</a> Redisson 实现</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedissonLockService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RedissonClient redissonClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedissonLockService</span><span class=\"params\">(RedissonClient redissonClient)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redissonClient = redissonClient;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;@annotation(org.joker.commons.cloud.lock.annotation.RedisLock)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doLockByContext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;doLockByContext()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint point)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取方法对象</span></span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) point.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        <span class=\"comment\">//解析用于生成锁的上下文</span></span><br><span class=\"line\">        List&lt;LockContext&gt; lockContexts = getLockContexts(method, point.getArgs());</span><br><span class=\"line\">        <span class=\"comment\">//加锁并执行</span></span><br><span class=\"line\">        <span class=\"type\">RedisLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> method.getAnnotation(RedisLock.class);</span><br><span class=\"line\">        <span class=\"type\">LockEntity</span> <span class=\"variable\">lockEntity</span> <span class=\"operator\">=</span> doLockByContext(lockContexts, lock.timeout(), lock.unit());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> point.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lockEntity.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;cloud:lock:&quot;</span> + generatedKey;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys, Long timeout, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;RLock&gt; rLocks = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(keys.size());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">            rLocks.add(redissonClient.getLock(key));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">RLock</span> <span class=\"variable\">multiLock</span> <span class=\"operator\">=</span> redissonClient.getMultiLock(rLocks.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">RLock</span>[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timeout != <span class=\"literal\">null</span> &amp;&amp; timeout &gt; <span class=\"number\">0</span> &amp;&amp; unit != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            multiLock.lock(timeout, unit);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            multiLock.lock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 AOP 的方法，在 @RedisLock 注解处创建切面，在执行该方法之前先对该方法的参数进行处理，产生上下文列表，并依据该列表生成对应的 key 集合，再通过该 key 集合尝试获取锁。在获取锁成功后再执行对应的方法，在 finally 代码块中释放锁。</p>\n<h5 id=\"zookeeper实现\"><a class=\"markdownIt-Anchor\" href=\"#zookeeper实现\">#</a> ZooKeeper 实现</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZooKeeperLockService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CuratorFramework zkClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ZooKeeperLockService</span><span class=\"params\">(CuratorFramework zkClient)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.zkClient = zkClient;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;@annotation(org.joker.commons.cloud.lock.annotation.ZkLock)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doLockByContext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;doLockByContext()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint point)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取方法对象</span></span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) point.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        <span class=\"comment\">//解析用于生成锁的上下文</span></span><br><span class=\"line\">        List&lt;LockContext&gt; lockContexts = getLockContexts(method, point.getArgs());</span><br><span class=\"line\">        <span class=\"comment\">//加锁并执行</span></span><br><span class=\"line\">        <span class=\"type\">ZkLock</span> <span class=\"variable\">zkLock</span> <span class=\"operator\">=</span> method.getAnnotation(ZkLock.class);</span><br><span class=\"line\">        <span class=\"type\">LockEntity</span> <span class=\"variable\">lockEntity</span> <span class=\"operator\">=</span> doLockByContext(lockContexts, zkLock.timeout(), zkLock.unit());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> point.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lockEntity.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;/cloud/lock/&quot;</span> + generatedKey;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; lockKeys, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">InterProcessMultiLock</span> <span class=\"variable\">multiLock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InterProcessMultiLock</span>(zkClient, lockKeys.stream().toList());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timeout != <span class=\"literal\">null</span> &amp;&amp; timeout &gt; <span class=\"number\">0</span> &amp;&amp; unit != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            multiLock.acquire(timeout, unit);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            multiLock.acquire();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同 Redisson 类似，在 ZkLock 处创建切面，先根据注解解析对应参数的锁 key 后，再获取锁，然后执行方法并释放锁。</p>\n<h2 id=\"完整代码\"><a class=\"markdownIt-Anchor\" href=\"#完整代码\">#</a> 完整代码</h2>\n<p>以下按照包结构排列</p>\n<ul>\n<li>\n<p>…</p>\n<ul>\n<li>\n<p>lock</p>\n<ul>\n<li>\n<p>annotation</p>\n<ul>\n<li>\n<p>RedisLock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RedisLock &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">timeout</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimeUnit <span class=\"title function_\">unit</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> TimeUnit.SECONDS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>SyncArg</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.PARAMETER&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SyncArg &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 加锁依据，填入Spel表达式，用于生成锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * 应该确保每一个加锁对象能够生成一个固定的且独立的key</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用时可用上下文包括 arg：当前参数，method：当前运行的方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    String <span class=\"title function_\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"string\">&quot;#arg.hashCode()&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 是否采用多对象解析方式，多对象时将产生多个锁并同步加锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 当传入对象实现了 Iterable时，将遍历每一个子项，并且生成key时arg为当前遍历到的对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 当传入对象实现了Map时，将遍历每个Entry，生成key时arg为当前Entry</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">isMulti</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>ZkLock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ZkLock &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">timeout</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimeUnit <span class=\"title function_\">unit</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> TimeUnit.SECONDS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>config</p>\n<ul>\n<li>\n<p>RedissonLockConfig</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedissonLockConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.redis.url:redis://localhost:6379&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String redisUrl;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.redis.password:&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String redisPassword;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RedissonClient <span class=\"title function_\">redissonClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Config</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Config</span>();</span><br><span class=\"line\">        <span class=\"type\">SingleServerConfig</span> <span class=\"variable\">singleServerConfig</span> <span class=\"operator\">=</span> config.useSingleServer();</span><br><span class=\"line\">        singleServerConfig.setAddress(redisUrl);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isNotEmpty(redisPassword)) &#123;</span><br><span class=\"line\">            singleServerConfig.setPassword(redisPassword);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Redisson.create(config);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>ZooKeeperLockConfig</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZooKeeperLockConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.url:localhost:2181&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.timeout:1000&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> timeout;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.retry:3&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> retry;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CuratorFramework <span class=\"title function_\">zkClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ExponentialBackoffRetry</span> <span class=\"variable\">exponentialBackoffRetry</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExponentialBackoffRetry</span>(timeout, retry);</span><br><span class=\"line\">        <span class=\"type\">CuratorFramework</span> <span class=\"variable\">curatorFramework</span> <span class=\"operator\">=</span> CuratorFrameworkFactory.newClient(url, exponentialBackoffRetry);</span><br><span class=\"line\">        curatorFramework.start();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> curatorFramework;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>AbstractLockService</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 格式化生成的key，在生成加锁key时会经过该方法，并以返回的key作为最终加锁时的key</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> generatedKey 通过上下文对象自动生成的key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 格式化后的key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过LockContext的形式生成锁key再加锁</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockContexts 用于生成锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeout      锁超时时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit         时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 锁对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> LockEntity <span class=\"title function_\">doLockByContext</span><span class=\"params\">(List&lt;LockContext&gt; lockContexts, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> doLock(getLockKeys(lockContexts), timeout, unit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> doLock(keys, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过锁keys进行加锁，由子类实现</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> keys    锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeout 超时时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit    时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 锁对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据方法及入参解析出LockContext列表</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method 加锁的方法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args   入参</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> LockContext列表</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> List&lt;LockContext&gt; <span class=\"title function_\">getLockContexts</span><span class=\"params\">(Method method, Object[] args)</span> &#123;</span><br><span class=\"line\">        Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class=\"line\">        ArrayList&lt;LockContext&gt; lockContexts = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; parameterAnnotations.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取参数注解，与参数一一对应</span></span><br><span class=\"line\">            Annotation[] annotations = parameterAnnotations[i];</span><br><span class=\"line\">            <span class=\"comment\">//找到@SyncArg注解</span></span><br><span class=\"line\">            <span class=\"type\">SyncArg</span> <span class=\"variable\">syncArg</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Annotation annotation : annotations) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (annotation <span class=\"keyword\">instanceof</span> SyncArg syncArgA) &#123;</span><br><span class=\"line\">                    syncArg = syncArgA;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (syncArg != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//注解存在则通过注解构造上下文对象</span></span><br><span class=\"line\">                <span class=\"type\">LockContext</span> <span class=\"variable\">lockContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(syncArg, args[i]);</span><br><span class=\"line\">                lockContext.addParam(<span class=\"string\">&quot;method&quot;</span>, method);</span><br><span class=\"line\">                lockContexts.add(lockContext);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lockContexts;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过上下文对象列表生成key集合</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockContexts 上下文对象列表</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> key集合</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> HashSet&lt;String&gt; <span class=\"title function_\">getLockKeys</span><span class=\"params\">(List&lt;LockContext&gt; lockContexts)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//解析上下文列表，生成key</span></span><br><span class=\"line\">        HashSet&lt;String&gt; keys = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">SpelExpressionParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SpelExpressionParser</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (LockContext lockContext : lockContexts) &#123;</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">multi</span> <span class=\"operator\">=</span> lockContext.isMulti();</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">arg</span> <span class=\"operator\">=</span> lockContext.getArg();</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">keyExpression</span> <span class=\"operator\">=</span> lockContext.getKeyExpression();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (multi &amp;&amp; arg <span class=\"keyword\">instanceof</span> Iterable&lt;?&gt; iterable) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//多对象模式且参数对象为Iterable时</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Object o : iterable) &#123;</span><br><span class=\"line\">                    <span class=\"type\">LockContext</span> <span class=\"variable\">singleContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(o, keyExpression, <span class=\"literal\">false</span>, lockContext.getParams());</span><br><span class=\"line\">                    keys.add(formatKey(singleContext.getKey(parser)));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (multi &amp;&amp; arg <span class=\"keyword\">instanceof</span> Map&lt;?, ?&gt; map) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//多对象模式且参数对象为map时</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Map.Entry&lt;?, ?&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">LockContext</span> <span class=\"variable\">singleContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(entry, keyExpression, <span class=\"literal\">false</span>, lockContext.getParams());</span><br><span class=\"line\">                    keys.add(formatKey(singleContext.getKey(parser)));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                keys.add(formatKey(lockContext.getKey(parser)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> keys;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>LockContext</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockContext</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 被加锁的参数对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object arg;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成key的Spel表达式</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String keyExpression;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 是否为多对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> multi;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Getter(AccessLevel.PACKAGE)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; params;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(SyncArg syncArg, Object arg)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(arg, syncArg.value(), syncArg.isMulti());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(Object arg, String keyExpression, <span class=\"type\">boolean</span> multi)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(arg, keyExpression, multi, <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(Object arg, String keyExpression, <span class=\"type\">boolean</span> multi, Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.arg = arg;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.keyExpression = keyExpression;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.multi = multi;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.params = params;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key   key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 用于链式调用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockContext <span class=\"title function_\">addParam</span><span class=\"params\">(String key, Object value)</span> &#123;</span><br><span class=\"line\">        params.put(key, value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 用于链式调用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockContext <span class=\"title function_\">removeParam</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        params.remove(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getKey(<span class=\"keyword\">new</span> <span class=\"title class_\">SpelExpressionParser</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成key</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> parser Spel表达式解析器</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getKey</span><span class=\"params\">(SpelExpressionParser parser)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StandardEvaluationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StandardEvaluationContext</span>();</span><br><span class=\"line\">        HashMap&lt;String, Object&gt; contextMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(params);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!contextMap.containsKey(<span class=\"string\">&quot;arg&quot;</span>)) &#123;</span><br><span class=\"line\">            contextMap.put(<span class=\"string\">&quot;arg&quot;</span>, arg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        context.setVariables(contextMap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parser.parseExpression(keyExpression).getValue(String.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>LockEntity</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockEntity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object lock;</span><br><span class=\"line\"></span><br><span class=\"line\">    LockEntity(Object lock) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.lock = lock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lock <span class=\"keyword\">instanceof</span> RLock rLock) &#123;</span><br><span class=\"line\">            rLock.unlock();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lock <span class=\"keyword\">instanceof</span> InterProcessLock interProcessLock) &#123;</span><br><span class=\"line\">            interProcessLock.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>RedissonLockService</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedissonLockService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RedissonClient redissonClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedissonLockService</span><span class=\"params\">(RedissonClient redissonClient)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redissonClient = redissonClient;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;@annotation(org.joker.commons.cloud.lock.annotation.RedisLock)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doLockByContext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;doLockByContext()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint point)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取方法对象</span></span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) point.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        <span class=\"comment\">//解析用于生成锁的上下文</span></span><br><span class=\"line\">        List&lt;LockContext&gt; lockContexts = getLockContexts(method, point.getArgs());</span><br><span class=\"line\">        <span class=\"comment\">//加锁并执行</span></span><br><span class=\"line\">        <span class=\"type\">RedisLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> method.getAnnotation(RedisLock.class);</span><br><span class=\"line\">        <span class=\"type\">LockEntity</span> <span class=\"variable\">lockEntity</span> <span class=\"operator\">=</span> doLockByContext(lockContexts, lock.timeout(), lock.unit());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> point.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lockEntity.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;cloud:lock:&quot;</span> + generatedKey;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys, Long timeout, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;RLock&gt; rLocks = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(keys.size());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">            rLocks.add(redissonClient.getLock(key));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">RLock</span> <span class=\"variable\">multiLock</span> <span class=\"operator\">=</span> redissonClient.getMultiLock(rLocks.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">RLock</span>[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timeout != <span class=\"literal\">null</span> &amp;&amp; timeout &gt; <span class=\"number\">0</span> &amp;&amp; unit != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            multiLock.lock(timeout, unit);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            multiLock.lock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>ZooKeeper</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZooKeeperLockService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CuratorFramework zkClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ZooKeeperLockService</span><span class=\"params\">(CuratorFramework zkClient)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.zkClient = zkClient;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;@annotation(org.joker.commons.cloud.lock.annotation.ZkLock)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doLockByContext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;doLockByContext()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint point)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取方法对象</span></span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) point.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        <span class=\"comment\">//解析用于生成锁的上下文</span></span><br><span class=\"line\">        List&lt;LockContext&gt; lockContexts = getLockContexts(method, point.getArgs());</span><br><span class=\"line\">        <span class=\"comment\">//加锁并执行</span></span><br><span class=\"line\">        <span class=\"type\">ZkLock</span> <span class=\"variable\">zkLock</span> <span class=\"operator\">=</span> method.getAnnotation(ZkLock.class);</span><br><span class=\"line\">        <span class=\"type\">LockEntity</span> <span class=\"variable\">lockEntity</span> <span class=\"operator\">=</span> doLockByContext(lockContexts, zkLock.timeout(), zkLock.unit());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> point.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lockEntity.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;/cloud/lock/&quot;</span> + generatedKey;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; lockKeys, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">InterProcessMultiLock</span> <span class=\"variable\">multiLock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InterProcessMultiLock</span>(zkClient, lockKeys.stream().toList());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timeout != <span class=\"literal\">null</span> &amp;&amp; timeout &gt; <span class=\"number\">0</span> &amp;&amp; unit != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            multiLock.acquire(timeout, unit);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            multiLock.acquire();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"测试效果\"><a class=\"markdownIt-Anchor\" href=\"#测试效果\">#</a> 测试效果</h2>\n<p>采用如下 Spring 服务类进行效果测试，其中 run 中为测试代码，表达式 “#arg.getClass ().getSimpleName ()+#arg.getId ()<br>\n” 以 id 作为唯一主键生成 key，当前示例下生成的 key 为 Usertest01。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Getter</span></span><br><span class=\"line\">    <span class=\"meta\">@Setter</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;test01&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;测试用户&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">(User user)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        log.info(user.getName());</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">//模拟业务过程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RedisLock</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testRedisSync</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">            <span class=\"meta\">@SyncArg(&quot;#arg.getClass().getSimpleName()+#arg.getId()&quot;)</span> User user</span></span><br><span class=\"line\"><span class=\"params\">    )</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        test(user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ZkLock</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testZooKeeperSync</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">            <span class=\"meta\">@SyncArg(&quot;#arg.getClass().getSimpleName()+#arg.getId()&quot;)</span> User user</span></span><br><span class=\"line\"><span class=\"params\">    )</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        test(user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"不加锁\"><a class=\"markdownIt-Anchor\" href=\"#不加锁\">#</a> 不加锁</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestRunner</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestService testService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        TestService.<span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TestService</span>.User();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            testService.test(user);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>服务一：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/378a9d360acf6a6c560d3c2e9f68be60.png\" class=\"\" title=\"不加锁服务1log\">\n<p>服务二：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/248294a19780cc9e924184e26670a0c3.png\" class=\"\" title=\"不加锁服务2log\">\n<p>根据时间可以看到两个服务几乎同时在进行，如果存在变更数据的情况则可能存在出现数据不一致情况的风险。</p>\n<h3 id=\"使用redis锁\"><a class=\"markdownIt-Anchor\" href=\"#使用redis锁\">#</a> 使用 Redis 锁</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestRunner</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestService testService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        TestService.<span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TestService</span>.User();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            testService.testRedisSync(user);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>服务一：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/4507c4421a934baec554f92cea7b0038.png\" class=\"\" title=\"Redis锁服务1log\">\n<p>服务二：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/9158b26eab49184d53d500eb7c0e07b6.png\" class=\"\" title=\"Redis锁服务2log\">\n<p>根据时间可以看到两个服务在逐一有序地进行，能够实现锁的效果。</p>\n<h3 id=\"使用zookeeper锁\"><a class=\"markdownIt-Anchor\" href=\"#使用zookeeper锁\">#</a> 使用 ZooKeeper 锁</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestRunner</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestService testService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        TestService.<span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TestService</span>.User();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            testService.testZooKeeperSync(user);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>服务一：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/7ed3a36d886af2366487ddf9e679c224.png\" class=\"\" title=\"ZooKeeper服务1log\">\n<p>服务二：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/b00b26556a04f89fc3e1224726755a96.png\" class=\"\" title=\"ZooKeeper服务2log\">\n<p>同样能够实现锁的效果。</p>\n",
            "tags": [
                "后端",
                "Redis",
                "Redisson",
                "Zookeeper",
                "分布式锁"
            ]
        },
        {
            "id": "https://silvercrow42.github.io/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/",
            "url": "https://silvercrow42.github.io/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/",
            "title": "【RocketMQ】SpringBoot整合与使用RocketMQ（Windows）",
            "date_published": "2024-09-09T05:06:48.000Z",
            "content_html": "<p>由于是开发相关的文档，因此默认读者已经具备有 IDE，编者使用的是 IDEA 2022.1.3 以该版本作为演示基础。</p>\n<h1 id=\"spring引入rocketmq\"><a class=\"markdownIt-Anchor\" href=\"#spring引入rocketmq\">#</a> Spring 引入 RocketMQ</h1>\n<p>在适配 Spring 生态方面，RocketMQ 由于本身就是 Java 语言开发并且开源，拥有 Spring 开发基础就能够参照源码进行调试，并且其本身也提供了可直接用于 SpringBoot 整合的父项目，pom.xml 中通过如下配置即可引入该父项目。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.rocketmq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"学习springrocketmq范例\"><a class=\"markdownIt-Anchor\" href=\"#学习springrocketmq范例\">#</a> 学习 SpringRocketMQ 范例</h1>\n<p>RocketMQ 对于 Spring 拥有良好的适配，并且拥有对应的参考项目，接下来我们借助该项目了解一下 RocketMQ 的架构及用法。</p>\n<h2 id=\"基本概念\"><a class=\"markdownIt-Anchor\" href=\"#基本概念\">#</a> 基本概念</h2>\n<p>首先，为了方便理解，我们需要了解一下 RocketMQ 中的一些基本概念、运行逻辑与名词，方便后续理解掌握。</p>\n<blockquote>\n<p>该章节整理自文章<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc4MDk2OA==\"> RocketMQ 简介 - 阿里云开发者社区 (aliyun.com) </span>原文更加详细，可通过链接了解详情。</p>\n</blockquote>\n<h3 id=\"专有名词\"><a class=\"markdownIt-Anchor\" href=\"#专有名词\">#</a> 专有名词</h3>\n<h4 id=\"基本\"><a class=\"markdownIt-Anchor\" href=\"#基本\">#</a> 基本</h4>\n<ul>\n<li><strong>NameServer</strong>：注册中心，相当于 ZooKeeper，不过 RocketMQ 进行了另外的实现，比较轻便。</li>\n<li><strong>Broker</strong>：消息的管理中心，其负责管理 Topic 与保存传入的消息，并且会将自己注册到 NameServer 中供其调度，其由 RocketMQ 实现。</li>\n<li><strong>Producer</strong>：也称为消息发布者，负责产生消息，需要我们自行产生消息。</li>\n<li><strong>Consumer</strong>：也称为消息订阅者，负责接收消息并处理消息，需要我们自行处理消息。</li>\n</ul>\n<h4 id=\"消息属性相关\"><a class=\"markdownIt-Anchor\" href=\"#消息属性相关\">#</a> 消息属性相关</h4>\n<ul>\n<li><strong>Topic</strong>：消息主题，一级消息类型，生产者向其发送消息，消费者从中取出消息进行消费。</li>\n<li><strong>Message</strong>：生产者向 Topic 发送并最终传送给消费者的数据消息体。</li>\n<li><strong>Message ID</strong>：消息的全局唯一标识，由消息队列 RocketMQ 系统自动生成，唯一标识某条消息。</li>\n<li><strong>Message Key</strong>：消息的业务标识，由消息生产者（Producer）自行设置，可作为标识符使用标识一类业务逻辑，也可不提供。</li>\n<li><strong>Tag</strong>：消息标签，二级消息类型，由消息生产者（Producer）自行设置，用来进一步区分某个 Topic 下的消息</li>\n</ul>\n<h4 id=\"运行逻辑相关\"><a class=\"markdownIt-Anchor\" href=\"#运行逻辑相关\">#</a> 运行逻辑相关</h4>\n<ul>\n<li><strong>分区</strong>：即 Topic Partition，物理上的概念。每个 Topic 包含一个或多个分区，由 RocketMQ 实现。</li>\n<li><strong>消费位点</strong>：每个 Topic 会有多个分区，每个分区会统计当前消息的总条数，这个称为最大位点 MaxOffset；分区的起始位置对应的位置叫做起始位点 MinOffset。</li>\n<li><a id=\"Group\"><strong>Group</strong></a>：对生产者或消费者进行分组，同一组的生产者或消费者通常仅生产或消费同一类消息，且消息发布或订阅的逻辑一致，因此通常需要保证同组中的生产者与生产者之间或者消费者与消费者之间业务逻辑一致。在<a href=\"#%E9%9B%86%E7%BE%A4%E6%B6%88%E8%B4%B9\"> 集群消费 </a>模式下，该设计方式能够方便地对于生产者与消费者进行拓展。比如当某组中任务负载较大时，给组中额外增加多个生产者与消费者来分担该组的任务，降低负载。</li>\n<li><strong>Group ID</strong>：Group 的唯一标识，用于定位 Group，可以自行定制。</li>\n<li><strong>队列</strong>：一个 Topic 下会由一到多个队列来存储消息，其由 RocketMQ 实现。</li>\n<li><strong>Exactly-Once 投递语义</strong>：Exactly-Once 投递语义是指发送到消息系统的消息只能被 Consumer 处理且仅处理一次，即使 Producer 重试消息发送导致某消息重复投递，该消息在 Consumer 也只被消费一次。</li>\n</ul>\n<h4 id=\"消息收发相关\"><a class=\"markdownIt-Anchor\" href=\"#消息收发相关\">#</a> 消息收发相关</h4>\n<ul>\n<li><span id=\"集群消费\"><strong>集群消费</strong></span>：一个 Group ID 所标识的所有 Consumer 平均分摊消费消息。例如某个 Topic 有 9 条消息，一个 Group ID 有 3 个 Consumer 实例，那么在集群消费模式下每个实例平均分摊，只消费其中的 3 条消息。</li>\n<li><strong>广播消费</strong>：一个 Group ID 所标识的所有 Consumer 都会各自消费某条消息一次。例如某个 Topic 有 9 条消息，一个 Group ID 有 3 个 Consumer 实例，那么在广播消费模式下每个实例都会各自消费 9 条消息。</li>\n<li><strong>定时消息</strong>：Producer 将消息发送到消息队列 RocketMQ 服务端，但并不期望这条消息立马投递，而是推迟到在当前时间点之后的某一个时间投递到 Consumer 进行消费，该消息即定时消息。</li>\n<li><a id=\"延时消息\"><strong>延时消息</strong></a>：Producer 将消息发送到消息队列 RocketMQ 服务端，但并不期望这条消息立马投递，而是延迟一定时间后才投递到 Consumer 进行消费，该消息即延时消息。</li>\n<li><strong>事务消息</strong>：RocketMQ 提供类似 X/Open XA 的分布事务功能，通过消息队列 RocketMQ 的事务消息能达到分布式事务的最终一致。</li>\n<li><a id=\"顺序消息\"><strong>顺序消息</strong></a>：RocketMQ 提供的一种按照顺序进行发布和消费的消息类型，分为全局顺序消息和分区顺序消息。\n<ul>\n<li><strong>全局顺序消息</strong>：对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。</li>\n<li><strong>分区顺序消息</strong>：对于指定的一个 Topic，所有消息根据 Sharding Key 进行区块分区。同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。Sharding Key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Message Key 是完全不同的概念。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"概念相关\"><a class=\"markdownIt-Anchor\" href=\"#概念相关\">#</a> 概念相关</h4>\n<ul>\n<li><strong>消息堆积</strong>：Producer 已经将消息发送到消息队列 RocketMQ 的服务端，但由于 Consumer 消费能力有限，未能在短时间内将所有消息正确消费掉，此时在消息队列 RocketMQ 的服务端保存着未被消费的消息，该状态即消息堆积。</li>\n<li><strong>消息过滤</strong>：Consumer 可以根据消息标签（Tag）对消息进行过滤，确保 Consumer 最终只接收被过滤后的消息类型。消息过滤在消息队列 RocketMQ 的服务端完成。</li>\n<li><strong>消息轨迹</strong>：在一条消息从 Producer 发出到 Consumer 消费处理过程中，由各个相关节点的时间、地点等数据汇聚而成的完整链路信息。通过消息轨迹，您能清晰定位消息从 Producer 发出，经由消息队列 RocketMQ 服务端，投递给 Consumer 的完整链路，方便定位排查问题。</li>\n<li><strong>重置消费位点</strong>：以时间轴为坐标，在消息持久化存储的时间范围内（默认 3 天），重新设置 Consumer 对已订阅的 Topic 的消费进度，设置完成后 Consumer 将接收设定时间点之后由 Producer 发送到消息队列 RocketMQ 服务端的消息。</li>\n<li><strong>死信队列</strong>：死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明 Consumer 在正常情况下无法正确地消费该消息。此时，消息队列 RocketMQ 不会立刻将消息丢弃，而是将这条消息发送到该 Consumer 对应的特殊队列中。<br>\n消息队列 RocketMQ 将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。</li>\n</ul>\n<h3 id=\"消息流转模型\"><a class=\"markdownIt-Anchor\" href=\"#消息流转模型\">#</a> 消息流转模型</h3>\n<p>消息队列 RocketMQ 支持发布和订阅模型，消息生产者应用创建 Topic 并将消息发送到 Topic。消费者应用创建对 Topic 的订阅以便从其接收消息。通信可以是一对多（扇出）、多对一（扇入）和多对多。具体通信如下图所示。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/8c2f59ab52f03f20d7a859e7c8bb82b4.png\" class=\"\" title=\"消息流转模型\">\n<ul>\n<li><strong>生产者集群</strong>：用来表示发送消息应用，一个生产者集群下包含多个生产者实例，可以是多台机器，也可以是一台机器的多个进程，或者一个进程的多个生产者对象。<br>\n一个生产者集群可以发送多个 Topic 消息。发送分布式事务消息时，如果生产者中途意外宕机，消息队列 RocketMQ 服务端会主动回调生产者集群的任意一台机器来确认事务状态。</li>\n<li><strong>消费者集群</strong>：用来表示消费消息应用，一个消费者集群下包含多个消费者实例，可以是多台机器，也可以是多个进程，或者是一个进程的多个消费者对象。<br>\n一个消费者集群下的多个消费者以均摊方式消费消息。如果设置的是广播方式，那么这个消费者集群下的每个实例都消费全量数据。<br>\n一个消费者集群对应一个 Group ID，一个 Group ID 可以订阅多个 Topic，如上图中的 Group 2 所示。Group 和 Topic 的订阅关系可以通过直接在程序中设置即可。</li>\n</ul>\n<h2 id=\"获取范例项目\"><a class=\"markdownIt-Anchor\" href=\"#获取范例项目\">#</a> 获取范例项目</h2>\n<p>在安装文档中涉及到的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcS1leHRlcm5hbHM=\"> GitHub - apache/rocketmq-externals</span> 项目 ReadMe 中也提及到了一个关联 Spring 的 RocketMQ 项目。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/3dff3ecbdea41baddb69e24f1b1508d0.png\" class=\"\" title=\"拓展项目\">\n<p>项目地址如下<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcS1zcHJpbmc=\"> GitHub - apache/rocketmq-spring</span>。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/7f17ece34decafc3f316002155feaace.png\" class=\"\" title=\"拓展项目2\">\n<p>在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcS1zcHJpbmcvdHJlZS9tYXN0ZXIvcm9ja2V0bXEtc3ByaW5nLWJvb3Qtc2FtcGxlcw==\"> rocketmq-spring-boot-samples</span> 中则是基于 Spring 搭建的 RocketMQ 的范例项目，包含生产者与消费者 demo，可以进行参考学习。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/00ec143cf8ed26fc1976f7b12d66bc0d.png\" class=\"\" title=\"拓展项目3\">\n<p>由于该项目未依赖父项目，可以单独将其拉下来运行，也可以将该 rocketmq-spring 项目完整拉取下来使用。</p>\n<h3 id=\"span-id单独拉取单独拉取span\"><a class=\"markdownIt-Anchor\" href=\"#span-id单独拉取单独拉取span\">#</a> <span id=\"单独拉取\">单独拉取</span></h3>\n<p>项目拉取下来后使用 IDE 打开，IDEA 会自动加载 rocketmq-spring-boot-starter 的依赖，此时可能会出现依赖版本问题。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/1855df2c2cc50f3a51b2be2fbcec82b3.png\" class=\"\" title=\"下载样例项目\">\n<p>当前版本的 pom，此处给 rocketmq-spring-boot-starter 配置的是 2.2.3 快照版本，但是在 maven 仓库中已经修改 2.2.3 为正式的版本号，rocketmq-spring-boot-starter 源码版本也已经定义为 2.2.4-SNAPSHOT，此处应该是版本升级的疏漏。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/c6b66903f7110483a2f6fbb565e1611f.png\" class=\"\" title=\"下载样例项目2\">\n<p>对应修改一下版本号即可，修改为 2.2.3 直接重新运行一下 maven 导入。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/829c1285ceee1dc98d4b41a5f7df3182.png\" class=\"\" title=\"下载样例项目3\">\n<p>子项目均被解析为 maven 项目（项目图标右下角带蓝色小方格即表示已被解析为 maven 项目，且其中的文件结构不再是普通的文件夹结构，而是已包结构排列，并且特定的文件夹具有特定图标，如 java、resources、test 等），并且依赖项不报红，代表项目导入成功。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/cc2e1fedcb6a16cd07d8f3765e39c30a.png\" class=\"\" title=\"下载样例项目4\">\n<h3 id=\"完整拉取\"><a class=\"markdownIt-Anchor\" href=\"#完整拉取\">#</a> 完整拉取</h3>\n<p>项目拉取下来之后使用 IDE 打开，等待其安装依赖项，防止依赖项安装失败，或者找不到依赖项可以使用阿里的 maven 镜像。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mirrors</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>alimaven<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>aliyun maven<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">mirrorOf</span>&gt;</span>central<span class=\"tag\">&lt;/<span class=\"name\">mirrorOf</span>&gt;</span>        </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>项目导入成功。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/33ebac62954c73bc818a6b382c3fa99b.png\" class=\"\" title=\"下载样例项目5\">\n<p>编者此处 samples 并没有被解析为 maven，是由于在根目录的 pom.xml 中，该模块被默认注释掉了。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/6131a66f3f3e5ef5034e7b983c52b9e4.png\" class=\"\" title=\"下载样例项目6\">\n<p>将 module 标签处的注释放开然后重新跑 maven 一遍，maven 就会去解析 rocketmq-spring-boot-samples 下的 pom.xml 文件。此时可能会遇到与上文<a href=\"#%E5%8D%95%E7%8B%AC%E6%8B%89%E5%8F%96\"> 单独拉取 </a>时相同的情况，进入到 rocketmq-spring-boot-samples 下的 pom 中采用相同方式解决即可。</p>\n<h2 id=\"补充说明\"><a class=\"markdownIt-Anchor\" href=\"#补充说明\">#</a> 补充说明</h2>\n<p>此处补充一些范例项目中出现的不常见的且不涉及 RocketMQ 逻辑的代码的解析，方便对范例项目进行理解。</p>\n<h3 id=\"commandlinerunner\"><a class=\"markdownIt-Anchor\" href=\"#commandlinerunner\">#</a> CommandLineRunner</h3>\n<p>在生产者与消费者项目中都使用了 CommandLineRunner 接口。这里来探究以下该接口的效果。</p>\n<p>在启动 spring 应用时，会使用到如下的基本的 spring 启动代码 <code>SpringApplication.run(ProducerApplication.class, args)</code> ，进入到该方法中可以看到在经过多个默认的 run 方法后最终调用到了一个 run 方法中。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/2a07379410e7944edce47ae2826160c1.png\" class=\"\" title=\"run\">\n<p>我们可以看到在该方法中 spring 进行了一系列环境的初始化操作，将 spring 环境运行起来。这部分的逻辑都不重要。</p>\n<p>在 try 代码段的末尾，我们可以看到其调用了一段 <code>callRunners(context, applicationArguments)</code>  方法，传入了 spring 容器对象以及通过启动参数 args 构造出来的 ApplicationArguments 参数对象。</p>\n<p>进入到该方法中可以看到如下方法体。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/8b8970858a59e8a0e33e6f90dc0713f3.png\" class=\"\" title=\"run2\">\n<p>可以推出该方法的逻辑是将 ApplicationRunner.class 与 CommandLineRunner.class 构造出来的 Bean 添加到 runners 列表中，排序后依次将运行参数传入然后进行调用。</p>\n<p>简而言之，在启动 Spring 应用后，会在应用装配完毕时，运行 CommandLineRunner 与 ApplicationRunner 中的代码。并且该运行时机是要晚于 InitializingBean 的，能够确保所有 Bean 均已加载完毕。可以用来作为 Spring 应用启动后的初始化数据的方案，因为 bean 已装填完毕，可以正常使用 Spring 的功能。</p>\n<p>需要注意的是此处的代码是影响到 Spring 主线程的，如果出现异常会打断 Spring 应用的启动过程。</p>\n<p>在 demo 中的效果就是，对应的方法仅仅在启动时运行一遍，里面涉及到的就是一些演示代码。</p>\n<h2 id=\"理解范例项目\"><a class=\"markdownIt-Anchor\" href=\"#理解范例项目\">#</a> 理解范例项目</h2>\n<h3 id=\"生产者producer\"><a class=\"markdownIt-Anchor\" href=\"#生产者producer\">#</a> 生产者（Producer）</h3>\n<h4 id=\"extrocketmqtemplateconfiguration\"><a class=\"markdownIt-Anchor\" href=\"#extrocketmqtemplateconfiguration\">#</a> @ExtRocketMQTemplateConfiguration</h4>\n<p>该类是一个注解类，其携带了 Spring 中的 @Component 类，因此被该注解修饰的类会被 Spring 解析为一个 bean 组件，可以直接通过 spring bean 的一些方式来使用。</p>\n<p>很容易就能看出，该注解是用来修饰 RocketMQTemplate 及其拓展类，并且主要修饰发送方，即生产者端的 RocketMQTemplate。该注解能够为 RocketMQTemplate 及其拓展类规定一些默认的运行参数，生产者 demo 中就使用了其中的 nameServer 参数用于指定目标 NameServer 地址，使用了 tlsEnable 用于指定是否开启 tls 加密，使用 instanceName 指定实例名称。</p>\n<h4 id=\"rocketmqtemplate\"><a class=\"markdownIt-Anchor\" href=\"#rocketmqtemplate\">#</a> RocketMQTemplate</h4>\n<p>在生产者 demo 中，使用了该类中非常多种的发送方法，并且该类大多数方法都是用于生产者发送消息。因此将该类放到生产者部分讲解。需要注意的是对于每一类功能逻辑而言，应该单独拓展一个 RocketMQTemplate 子类，因为<a id=\"当使用事务消息时\">当使用事务消息时</a>，事务监听器是直接与 RocketMQTemplate 类进行绑定的，因此为了防止事务状态紊乱出错，推荐每个功能模块单独拓展一个 RocketMQTemplate 子类，后续会进行详述。因为该类中的方法众多，为了节省篇幅且便于拓展理解，这里对其进行大概的分类解释，便于自行了解这些方法的含义。</p>\n<h5 id=\"常见参数\"><a class=\"markdownIt-Anchor\" href=\"#常见参数\">#</a> 常见参数</h5>\n<ul>\n<li>\n<p>destination：用来定位当前参数需要发送到哪个 Topic，以及携带什么 Tag，标准格式为 <code>topicName:tags</code> （文档注释中此处为 tags，但是据查生产者是无法为消息指定多个 tag 的）。<br>\n例如：“test:tag1”，表示当前消息将会发送到名为 test 的 Topic 中，并且 tag 为 tag1。</p>\n</li>\n<li>\n<p>payload：消息载体，可以接收任何类对象，在发送前一般都会经过 MessageBuilder.withPayload (payload) 转化为 Message 对象。</p>\n</li>\n<li>\n<p>message/messages：一般是 Message 类对象，发送动作主要就是通过该类对象来进行，可以通过 MessageBuilder 获得</p>\n</li>\n<li>\n<p>timeout：发送超时时间，单位毫秒，当不指定时一般默认为 3 秒。</p>\n</li>\n<li>\n<p>delayLevel：延时级别，该参数不支持任意时间精度，仅支持特定的 level，例如定时 5s,10s,1m 等。其中 level=0 级表示不延时，level=1 表示 1 级延时，level=2 表示 2 级延时，以此类推。<br>\n延时级别的配置在 broker 配置（ROCKETMQ 根路径 /conf/broker.conf）中 <code>messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</code> 。时间单位支持：s、m、h、d，分别表示秒、分、时、天。</p>\n</li>\n<li>\n<p>delayTime：延时时间，可以详细指定延时时间，默认单位为毫秒。</p>\n</li>\n<li>\n<p>deliverTimeMills：交付时间，可以详细指定延时时间，默认单位为毫秒。</p>\n</li>\n<li>\n<p>mode：与 delayTime 或 deliverTimeMills 同时出现，接收 DelayMode 枚举对象。具有三种值，分别是 DELAY_SECONDS，DELAY_MILLISECONDS，DELIVER_TIME_MILLISECONDS。</p>\n<ul>\n<li>单独使用 deliverTimeMills 时，mode 默认为 DelayMode.DELIVER_TIME_MILLISECONDS</li>\n<li>单独使用 delayTime 时，默认 mode 为 DELAY_MILLISECONDS</li>\n</ul>\n<p>未查到二者的详细说明可能为新增 api，判断二者区别可能在于延时投递的方式不同。</p>\n</li>\n<li>\n<p>hashKey：用于为消息进行定位和排序。</p>\n</li>\n<li>\n<p>type：一般出现于同步消息时，用于规定返回消息的类型。</p>\n</li>\n<li>\n<p>sendCallback/rocketMQLocalRequestCallback：用于异步消息时的回调。</p>\n<ul>\n<li>sendCallback：为 SendCallback 对象，其中接收返回值时使用的是 SendResult 对象，内部以 byte 数组保存信息。</li>\n<li>rocketMQLocalRequestCallback：为 RocketMQLocalRequestCallback&lt;T&gt; 对象，返回值可以直接用泛型 T 接收，内部会自动转换成 T。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"同步与异步\"><a class=\"markdownIt-Anchor\" href=\"#同步与异步\">#</a> 同步与异步</h5>\n<ul>\n<li>\n<p>带 sync 的方法：表示同步方法，调用该方法之后会阻塞当前线程，直达该方法成功完成、超时或抛错。<br>\n例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SendResult</span> <span class=\"variable\">sendResult</span> <span class=\"operator\">=</span> rocketMQTemplate.syncSend(springTopic, <span class=\"string\">&quot;Hello, World!&quot;</span>);</span><br><span class=\"line\">System.out.printf(<span class=\"string\">&quot;syncSend1 to topic %s sendResult=%s %n&quot;</span>, springTopic, sendResult);</span><br></pre></td></tr></table></figure>\n<p>这里必须要等到 syncSend 返回了 SendResult 后才会来到下方的 printf。</p>\n</li>\n<li>\n<p>带 async 的方法：表示异步方法，其中需要定义对应的回调，即 SendCallback。调用该方法后并不会阻塞当前线程，当该方法处理成功或者失败是则会自行运行 SendCallback 中对应的代码块。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rocketMQTemplate.asyncSend(orderPaidTopic, <span class=\"keyword\">new</span> <span class=\"title class_\">OrderPaidEvent</span>(<span class=\"string\">&quot;T_001&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;88.00&quot;</span>)), <span class=\"keyword\">new</span> <span class=\"title class_\">SendCallback</span>() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span><span class=\"params\">(SendResult var1)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;async onSucess SendResult=%s %n&quot;</span>, var1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onException</span><span class=\"params\">(Throwable var1)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;async onException Throwable=%s %n&quot;</span>, var1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里该方法并没有返回值，该 async 方法会启用另外一个线程去发送消息，开始发送后放行主线程，由该线程完成剩下的接收并回调 SendCallback 操作。</p>\n</li>\n</ul>\n<h5 id=\"发送模式\"><a class=\"markdownIt-Anchor\" href=\"#发送模式\">#</a> 发送模式</h5>\n<ul>\n<li>\n<p>send：普通的发送方法，发送一条普通消息并通过 SendResult 接收返回消息，其中的数据形式为序列化后的 byte 数组形式，不可直接使用。</p>\n</li>\n<li>\n<p>convertAndSend：来自 Spring 的默认实现 AbstractMessageSendingTemplate 提供的方法，该方法会调用配置好的 MessageConverter 为消息载体进行转化，转化成 Message 对象后再进行发送，效果上与 send 并无不同。</p>\n</li>\n<li>\n<p>sendAndReceive：发送并接收远端的响应，同步与异步方式均可用。该可以将远端的响应反序列化成指定类型的对象，同步方式下需要提供 Type 对象来表明返回值类型，而异步方式下则需要提供 <code>RocketMQLocalRequestCallback&lt;T&gt;</code>  对象用来异步回调，该对象回调时则是通过其所提供的泛型来确定返回值类型。</p>\n</li>\n<li>\n<p>oneWay：发送消息，但是不追踪其返回，也就无法判断是否发送成功，拥有较高的运行性能，但是通过该方式发送可能会出现消息丢失的情况。</p>\n</li>\n<li>\n<p>delay：发送延时消息，需要提供一个延时，其他与普通消息一致，基本逻辑同上方对<a href=\"#%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF\"> 延时消息 </a>的表述一致。</p>\n</li>\n<li>\n<p>orderly：发送顺序消息，需要为消息提供一个 hashKey，用于对消息的排序，其他与普通消息一致，基本逻辑同上方对<a href=\"#%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF\"> 顺序消息 </a>的表述一致。</p>\n</li>\n</ul>\n<h5 id=\"发送事务消息\"><a class=\"markdownIt-Anchor\" href=\"#发送事务消息\">#</a> 发送事务消息</h5>\n<p>sendMessageInTransaction 用于发送事务消息，在构造消息时，可以通过 <code>setHeader(RocketMQHeaders.TRANSACTION_ID, [事务id])</code>  的方式向 header 中设置事务 id 用作事务标识，后续也可以从 header 中取出来使用。</p>\n<h6 id=\"事务监听器\"><a class=\"markdownIt-Anchor\" href=\"#事务监听器\">#</a> 事务监听器</h6>\n<p>在使用事务前，我们需要为事务实现一个事务监听器，节省篇幅，我们这里使用 demo 中较简单的监听器示例来讲解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RocketMQTransactionListener(rocketMQTemplateBeanName = &quot;extRocketMQTemplate&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExtTransactionListenerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">RocketMQLocalTransactionListener</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RocketMQLocalTransactionState <span class=\"title function_\">executeLocalTransaction</span><span class=\"params\">(Message msg, Object arg)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;ExtTransactionListenerImpl executeLocalTransaction and return UNKNOWN. \\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RocketMQLocalTransactionState.UNKNOWN;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RocketMQLocalTransactionState <span class=\"title function_\">checkLocalTransaction</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;ExtTransactionListenerImpl checkLocalTransaction and return COMMIT. \\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现事务监听器后，需要通过 @RocketMQTransactionListener 注解将监听器与 rocketMQTemplate 的 bean 进行关联，参数 rocketMQTemplateBeanName 用来确定需要关联的 RocketMQTemplate 的 bean 的名称，其默认值为 rocketMQTemplate。其与 RocketMQTemplate 是一一对应的关系，这也就是为什么上文提到<a href=\"#%E5%BD%93%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%97%B6\">当使用事务消息时</a>，最好单独拓展一个 rocketMQTemplate。</p>\n<p>并且该监听器也会被注册为 bean，并通过 org.apache.rocketmq.spring.autoconfigure.RocketMQTransactionConfiguration 类中的以下方法将 bean 对象与对应的 rocketMQTemplate 的 bean 对象进行关联。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterSingletonsInstantiated</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Map&lt;String, Object&gt; beans = <span class=\"built_in\">this</span>.applicationContext.getBeansWithAnnotation(RocketMQTransactionListener.class)</span><br><span class=\"line\">        .entrySet().stream().filter(entry -&gt; !ScopedProxyUtils.isScopedTarget(entry.getKey()))</span><br><span class=\"line\">        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span><br><span class=\"line\"></span><br><span class=\"line\">    beans.forEach(<span class=\"built_in\">this</span>::registerTransactionListener);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerTransactionListener</span><span class=\"params\">(String beanName, Object bean)</span> &#123;</span><br><span class=\"line\">    Class&lt;?&gt; clazz = AopProxyUtils.ultimateTargetClass(bean);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!RocketMQLocalTransactionListener.class.isAssignableFrom(bean.getClass())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(clazz + <span class=\"string\">&quot; is not instance of &quot;</span> + RocketMQLocalTransactionListener.class.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">RocketMQTransactionListener</span> <span class=\"variable\">annotation</span> <span class=\"operator\">=</span> clazz.getAnnotation(RocketMQTransactionListener.class);</span><br><span class=\"line\">    <span class=\"type\">RocketMQTemplate</span> <span class=\"variable\">rocketMQTemplate</span> <span class=\"operator\">=</span> (RocketMQTemplate) applicationContext.getBean(annotation.rocketMQTemplateBeanName());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (((TransactionMQProducer) rocketMQTemplate.getProducer()).getTransactionListener() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(annotation.rocketMQTemplateBeanName() + <span class=\"string\">&quot; already exists RocketMQLocalTransactionListener&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ((TransactionMQProducer) rocketMQTemplate.getProducer()).setExecutorService(<span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(annotation.corePoolSize(), annotation.maximumPoolSize(),</span><br><span class=\"line\">                                                                                                       annotation.keepAliveTime(), annotation.keepAliveTimeUnit(), <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingDeque</span>&lt;&gt;(annotation.blockingQueueSize())));</span><br><span class=\"line\">    ((TransactionMQProducer) rocketMQTemplate.getProducer()).setTransactionListener(RocketMQUtil.convert((RocketMQLocalTransactionListener) bean));</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;RocketMQLocalTransactionListener &#123;&#125; register to &#123;&#125; success&quot;</span>, clazz.getName(), annotation.rocketMQTemplateBeanName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说最终事务中使用到的监听器，是注入到 spring 容器中的监听器 bean，并不是新创建的，设计上需要注意。</p>\n<h6 id=\"监听器的用处\"><a class=\"markdownIt-Anchor\" href=\"#监听器的用处\">#</a> 监听器的用处</h6>\n<p>在事务监听器中包含两个方法，分别是<a id=\"executeLocalTransaction\"> <code>executeLocalTransaction</code> </a>和<a id=\"checkLocalTransaction\"> <code>checkLocalTransaction</code> </a>。，从事务的运行逻辑顺序入手，来探究一下这些方法的作用。以下给出事务的运行逻辑。</p>\n<blockquote>\n<p>图片引用自文章<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzaDIwNTAvYXJ0aWNsZS9kZXRhaWxzLzEyNDUxNzM1NQ==\"> RocketMQ 事务消息机制_rocketmqtransactionlistener</span></p>\n</blockquote>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8RocketMQ/c2eb61b0adcdc503d4314ecc070e2f25.png\" class=\"\" title=\"引用图片\">\n<ol>\n<li>在调用 Transaction 相关方法后，会先将消息发送出去，此时采用的是同步方式，即当前线程会被阻塞，直到获取到远端返回过来的发送结果。此时来到远端 broker 中的事务消息并不是一个可用消息，而是一个半消息，是无法被消费者消费的 **（此处对应图中第 1 步）**。</li>\n<li>根据发送结果的状态来进行，最终会提供一个 LocalTransactionState 来作为最终事务处理的依据：\n<ol>\n<li>当状态为 SEND_OK 时 **（此处对应图中第 2 步）<strong>，就会来到<a href=\"#executeLocalTransaction\"> executeLocalTransaction</a> 方法将此前发送的消息传入作为参数传入，由其进行本地事务的后续处理，然后提供一个事务状态 RocketMQLocalTransactionState 枚举。其中包含三种值并最终与 LocalTransactionState 相对应</strong>（此处对应图中第 3 步）**。\n<ul>\n<li>COMMIT 对应 LocalTransactionState 的<a href=\"#%E6%8F%90%E4%BA%A4\">提交</a>态</li>\n<li>ROLLBACK 对应 LocalTransactionState 的<a href=\"#%E5%9B%9E%E6%BB%9A\">回滚</a>态</li>\n<li>UNKNOWN 对应 LocalTransactionState 的<a href=\"#%E6%9C%AA%E7%9F%A5\">未知</a>态。</li>\n</ul>\n</li>\n<li>当状态为 FLUSH_DISK_TIMEOUT，FLUSH_SLAVE_TIMEOUT 或者 SLAVE_NOT_AVAILABLE 时，LocalTransactionState 将被置为<a href=\"#%E5%9B%9E%E6%BB%9A\">回滚</a>态。</li>\n<li>其他情况下，状态默认为<a href=\"#%E6%9C%AA%E7%9F%A5\">未知</a>态。</li>\n</ol>\n</li>\n<li>最后根据 LocalTransactionState 来对事务进行处理：\n<ul>\n<li><a id=\"提交\">提交</a>，告知 Broker 将当前事务消息置为可用，可以提供给消费者消费 **（此处对应图中第 4 步 Commit）**。</li>\n<li><a id=\"回滚\">回滚</a>，告知 Broker 回滚当前事务，删除对应的事务消息 **（此处对应图中第 4 步 Rollback）**。</li>\n<li><a id=\"未知\">未知</a>，可能当前事务应故（网络断开，回传消息受阻等）未能获取到消息的发送状态，或者由 executeLocalTransaction 提供了 UNKNOWN 的状态，接下来等待固定的时间后，broker 发起对事务的回查请求回查事务状态 **（此处对应图中第 5 步）<strong>。<br>\n消费者此时正常响应后，会进入到事务监听器的<a href=\"#checkLocalTransaction\"> <code>checkLocalTransaction</code> </a> 中来给出一个事务状态，判断事务接下来的处理方式</strong>（此处对应图中第 6 步）<strong>。最后发送给 broker 进行响应处理</strong>（此处对应图中第 7 步）**</li>\n</ul>\n</li>\n</ol>\n<p>可见监听器的主要用处，就是让开发者能够自行决定事务的提交和回滚，自定义实现消息的事务流程。发送事务消息的默认实现来自于 <code>org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl#sendMessageInTransaction</code>  方法，可以自行跟踪查看。</p>\n<h6 id=\"demo理解\"><a class=\"markdownIt-Anchor\" href=\"#demo理解\">#</a> demo 理解</h6>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RocketMQTransactionListener(rocketMQTemplateBeanName = &quot;extRocketMQTemplate&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExtTransactionListenerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">RocketMQLocalTransactionListener</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RocketMQLocalTransactionState <span class=\"title function_\">executeLocalTransaction</span><span class=\"params\">(Message msg, Object arg)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;ExtTransactionListenerImpl executeLocalTransaction and return UNKNOWN. \\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RocketMQLocalTransactionState.UNKNOWN;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RocketMQLocalTransactionState <span class=\"title function_\">checkLocalTransaction</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;ExtTransactionListenerImpl checkLocalTransaction and return COMMIT. \\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再看 demo 中的监听器梳理逻辑，就不难看出，该监听器关联名称为 <code>extRocketMQTemplate</code>  的 bean 组件，当我们通过使用该组件的 <code>sendMessageInTransaction</code>  方法发送事务消息时。</p>\n<ol>\n<li>消息发送成功后首先进入到 <code>executeLocalTransaction</code>  方法中，此处返回 UNKNOWN，也就是此时 broker 并不能确定当前事务需要如何处理，因此 broker 仍然将消息置为半消息状态，保存消息但是该消息不能被访问。</li>\n<li>再一段时间后，broker 再次尝试回查事务状态，此时来到 <code>checkLocalTransaction</code>  方法，此处返回 COMMIT，表示可以提交消息了，于是 broker 将消息置为可用状态。</li>\n</ol>\n<h3 id=\"消费者consumer\"><a class=\"markdownIt-Anchor\" href=\"#消费者consumer\">#</a> 消费者（Consumer）</h3>\n<p>对于消费者而言，消费消息具有两种模式，一种是 PUSH 模式，即当队列中存在消息，则 RocketMQ 服务端便将该消息 push 给对应消费该消息的消费者，即消费者被动消费消息，一种是 PULL 模式，即消费者通过 PULL 主动从 RocketMQ 服务端中获取未被消费的所有消息进行消费，即消费者主动消费。接下来讲解一下这两种模式的实现。</p>\n<h4 id=\"push模式\"><a class=\"markdownIt-Anchor\" href=\"#push模式\">#</a> PUSH 模式</h4>\n<p>push 模式下比较简单，消费者被动消费消息，只需要实现对应的监听器即可，由 RocketMQ 自行管理推送的逻辑。</p>\n<h5 id=\"rocketmqmessagelistener\"><a class=\"markdownIt-Anchor\" href=\"#rocketmqmessagelistener\">#</a> @RocketMQMessageListener</h5>\n<p>该类是一个注解类 ，用于添加到消费者监听器上，为该监听器指定一些对应的运行参数。例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RocketMQMessageListener(nameServer = &quot;$&#123;demo.rocketmq.myNameServer&#125;&quot;, topic = &quot;$&#123;demo.rocketmq.topic.user&#125;&quot;, consumerGroup = &quot;user_consumer&quot;)</span></span><br></pre></td></tr></table></figure>\n<p>这里为监听器指定了 NameServer 地址，并且指定了对应订阅的 topic，同时也可以通过 selectorType（默认值为 SelectorType.TAG）与 selectorExpression 为监听器指定对应的 tag 等分类信息，consumerGroup 为消费者指定了对应的<a href=\"#Group\">消费者组</a>。</p>\n<p>需要注意的是，该注解并不包含 Component 注解，因此不会将对应的监听器注册为 Spring bean 组件，需要自己另行注册或添加对应注解。</p>\n<h5 id=\"rocketmqlistener\"><a class=\"markdownIt-Anchor\" href=\"#rocketmqlistener\">#</a> RocketMQListener</h5>\n<p>该类为一个接口，是作为消费者需要实现的监听器接口之一，其接口代码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">RocketMQListener</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">onMessage</span><span class=\"params\">(T message)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该接口接受一个泛型参数，该泛型参数用于指定接受到的消息类型，当接受到对应的消息时，对应的消息内容会被转换为 T 所指定的类型传入到参数 message 中。</p>\n<p>demo 样例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RocketMQMessageListener(nameServer = &quot;$&#123;demo.rocketmq.myNameServer&#125;&quot;, topic = &quot;$&#123;demo.rocketmq.topic.user&#125;&quot;, consumerGroup = &quot;user_consumer&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserConsumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">RocketMQListener</span>&lt;User&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onMessage</span><span class=\"params\">(User message)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;######## user_consumer received: %s ; age: %s ; name: %s \\n&quot;</span>, message, message.getUserAge(), message.getUserName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该监听器会自动接收配置项 demo.rocketmq.topic.user 中的消息，当接收到消息时，会将消息中的二进制码部分反序列化为 User 对象作为 message 传入然后进行消费。</p>\n<h5 id=\"rocketmqreplylistener\"><a class=\"markdownIt-Anchor\" href=\"#rocketmqreplylistener\">#</a> RocketMQReplyListener</h5>\n<p>该类为一个接口，是作为消费者需要实现的监听器接口之一，其接口代码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">RocketMQReplyListener</span>&lt;T, R&gt; &#123;</span><br><span class=\"line\">    R <span class=\"title function_\">onMessage</span><span class=\"params\">(T message)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现该接口的监听器就支持对传入的消息回传进行对应的响应结果。该类接受的两个类型泛型 T、R 中，T 表示接受到的消息类型，效果同 RocketMQListener 中的 T；R 表示回传的响应数据的类型。</p>\n<p>demo 样例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RocketMQMessageListener(topic = &quot;$&#123;demo.rocketmq.objectRequestTopic&#125;&quot;, consumerGroup = &quot;$&#123;demo.rocketmq.objectRequestConsumer&#125;&quot;, selectorExpression = &quot;$&#123;demo.rocketmq.tag&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ObjectConsumerWithReplyUser</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">RocketMQReplyListener</span>&lt;User, User&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">onMessage</span><span class=\"params\">(User user)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;------- ObjectConsumerWithReplyUser received: %s \\n&quot;</span>, user);</span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">replyUser</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>();</span><br><span class=\"line\">        replyUser.setUserAge((<span class=\"type\">byte</span>) <span class=\"number\">10</span>);</span><br><span class=\"line\">        replyUser.setUserName(<span class=\"string\">&quot;replyUserName&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> replyUser;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该监听器能够接收配置项 demo.rocketmq.objectRequestTopic 指定的 topic 中具有由配置项 demo.rocketmq.tag 指定的 tag 的消息，当接收到消息时，会将消息中的二进制码部分反序列化为 User 对象作为 message 传入然后进行消费，完毕后构造了一个新的 User 对象作为响应返回，RocketMQ 将会将该返回值回传给消费者。</p>\n<h4 id=\"pull模式\"><a class=\"markdownIt-Anchor\" href=\"#pull模式\">#</a> PULL 模式</h4>\n<p>PULL 模式需要使用到此前提到的 RocketMQTemplate 类中的 receive 方法。</p>\n<h5 id=\"extrocketmqconsumerconfiguration\"><a class=\"markdownIt-Anchor\" href=\"#extrocketmqconsumerconfiguration\">#</a> @ExtRocketMQConsumerConfiguration</h5>\n<p>该类是一个注解类，同 @ExtRocketMQTemplateConfiguration 注解类似，作用于 RocketMQTemplate 子类上，不过主要用于提供给消费者主动拉取消息。例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ExtRocketMQConsumerConfiguration(topic = &quot;$&#123;demo.rocketmq.topic&#125;&quot;, group = &quot;string_consumer&quot;, tlsEnable = &quot;$&#123;demo.ext.consumer.tlsEnable&#125;&quot;)</span></span><br></pre></td></tr></table></figure>\n<p>这里为 RocketMQTemplate 指定了拉取的 topic，并指定了当前的消费者组，指定了是否开启 tls 加密。<br>\nser 对象作为响应返回，RocketMQ 将会将该返回值回传给消费者。</p>\n<h4 id=\"pull模式-2\"><a class=\"markdownIt-Anchor\" href=\"#pull模式-2\">#</a> PULL 模式</h4>\n<p>PULL 模式需要使用到此前提到的 RocketMQTemplate 类中的 receive 方法。</p>\n<h5 id=\"extrocketmqconsumerconfiguration-2\"><a class=\"markdownIt-Anchor\" href=\"#extrocketmqconsumerconfiguration-2\">#</a> @ExtRocketMQConsumerConfiguration</h5>\n<p>该类是一个注解类，同 @ExtRocketMQTemplateConfiguration 注解类似，作用于 RocketMQTemplate 子类上，不过主要用于提供给消费者主动拉取消息。例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ExtRocketMQConsumerConfiguration(topic = &quot;$&#123;demo.rocketmq.topic&#125;&quot;, group = &quot;string_consumer&quot;, tlsEnable = &quot;$&#123;demo.ext.consumer.tlsEnable&#125;&quot;)</span></span><br></pre></td></tr></table></figure>\n<p>这里为 RocketMQTemplate 指定了拉取的 topic，并指定了当前的消费者组，指定了是否开启 tls 加密。</p>\n",
            "tags": [
                "后端",
                "MQ",
                "RocketMQ"
            ]
        },
        {
            "id": "https://silvercrow42.github.io/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/",
            "url": "https://silvercrow42.github.io/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/",
            "title": "【RocketMQ】安装与部署（Windows）",
            "date_published": "2024-09-09T03:46:16.000Z",
            "content_html": "<h1 id=\"准备工作\"><a class=\"markdownIt-Anchor\" href=\"#准备工作\">#</a> 准备工作</h1>\n<h2 id=\"下载\"><a class=\"markdownIt-Anchor\" href=\"#下载\">#</a> 下载</h2>\n<p>可以在官网上下载<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yb2NrZXRtcS5hcGFjaGUub3JnL3poLw==\"> RocketMQ・官方网站 | RocketMQ (apache.org)</span><br>\n 或者直接到 Apache 的文件站点下<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcmNoaXZlLmFwYWNoZS5vcmcvZGlzdC9yb2NrZXRtcS8=\"> Index of /dist/rocketmq (apache.org)</span> 找到对应版本下载。</p>\n<p>这里以编写时的最新版本为例，选择 Binary 版本下载，该版本为编译后的版本，可以直接使用。</p>\n<p>Source 下载获取的是源码，需要经过编译后才可以使用，不过比较方便自行扩展，有扩展需求可以使用该版本自行编译。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/c687d3c664944954288c48a951b7aa5e.png\" class=\"\" title=\"官网下载页\">\n<p>下载完成后解压出来是如下的文件结构。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/7e6608c24fb49bcd9982d9b25fa9c819.png\" class=\"\" title=\"下载后的文件结构\">\n<p>以下以 windows 为环境演示。</p>\n<p>RocketMQ 依赖的是 Java 的运行环境，因此系统上应该安装 Java 并且拥有对应的环境变量 JAVA_HOME.</p>\n<p>RocketMQ 使用的 java 环境是 java8，对于高版本环境可能需要进行一些适配性的改动。</p>\n<p>在 RocketMQ 目录下的 bin 文件夹中有对应的服务启动脚本，包含 Linux 可运行的 sh 文件以及 Windows 可运行的 cmd 文件。</p>\n<h2 id=\"环境变量\"><a class=\"markdownIt-Anchor\" href=\"#环境变量\">#</a> 环境变量</h2>\n<p>解压完毕后需要手动添加名为 ROCKETMQ_HOME 的环境变量，索引到 RocketMQ 的解压目录即可，设置完毕后需要重启电脑。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/b9d692cbe18a30e8c27f757d0208f0ec.png\" class=\"\" title=\"环境变量设置\">\n<h1 id=\"nameserver\"><a class=\"markdownIt-Anchor\" href=\"#nameserver\">#</a> NameServer</h1>\n<p>打开 cmd 命令行后，通过 cd 命令进入到解压目录的 bin 目录下。然后使用 <code>start mqnamesrv.cmd </code> 命令新开一个命令行窗口启动 NameServer</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/31d4e322a0dd35ade7d8198071115f27.png\" class=\"\" title=\"新窗口启动NameServer\">\n<p>或者直接使用 <code>mqnamesrv.cmd</code>  在当前命令行中启动。</p>\n<p>其本质是通过此前设置的环境变量找到 RocketMQ 的 bin 路径，再通过该路径下的 runserver.cmd 脚本文件实现运行的，因此启动项配置其实来自 runserver.cmd 中。</p>\n<p>出现 The Name Server boot success 提示则表示 NameServer 服务启动成功，启动成功后不要关闭该命令窗口。</p>\n<h2 id=\"可能出现的问题\"><a class=\"markdownIt-Anchor\" href=\"#可能出现的问题\">#</a> 可能出现的问题</h2>\n<h3 id=\"please-set-the-rocketmq_home-variable-in-your-environment\"><a class=\"markdownIt-Anchor\" href=\"#please-set-the-rocketmq_home-variable-in-your-environment\">#</a> Please set the ROCKETMQ_HOME variable in your environment!</h3>\n<p>这个问题提示其实不够准确，并不一定是在我们没有设置环境变量时出现。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/45ac5254ebbaf057393dc8743474c119.png\" class=\"\" title=\"问题定位1\">\n<p>因为在运行过程中，脚本文件是通过环境变量来定位到 runserver.cmd 的位置再通过该脚本来启动应用的，因此在当 runserver.cmd 文件定位不到时才会出现该问题。</p>\n<p><strong>处理方法</strong>：可以重新打开一个命令行，然后通过 <code>echo %ROCKETMQ_HOME%</code> <br>\n 打印一下环境变量出来检查一下环境变量是否有误。同时这种方式也能够让环境变量刷新，如果此前曾经修改过环境变量而没有重启电脑，则这种方式能够让环境变量刷新成修改后的值。</p>\n<p>如果仍然没有解决，则可以进入到该对应路径下看看是否缺失了 runserver.cmd 文件，到这一步也都没有发现问题，那就只能重启一下试试，可能环境变量的更改并没有生效。</p>\n<h3 id=\"unrecognized-vm-option\"><a class=\"markdownIt-Anchor\" href=\"#unrecognized-vm-option\">#</a> Unrecognized VM option</h3>\n<p>在通过 runserver.cmd 运行时，如果以高于 java8 的版本作为环境运行可能会出现如下错误：<strong>Unrecognized VM option ’<br>\nUseConcMarkSweepGC’</strong></p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/41367fb287fe7a305b9b51f4c0fc252b.png\" class=\"\" title=\"问题定位2-1\">\n<p>这是因为在运行脚本中，包含了一些对 CMSGC 的一些调优参数。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/32ef686e52b0f1c87d1ef0640b87d779.png\" class=\"\" title=\"问题定位2-2\">\n<p>据查在 java9 中使用 G1 来作为 GC 的默认实现，从而废弃了 CMS 相关的一些参数。因此启动时需要进行一些相关参数的改动，或者将 java 降级，指定特定的 jre8 来作为虚拟机运行。</p>\n<p>在 sh 版本的 runserver 脚本中对 java 的版本进行了专门的适配，可以识别 java 版本采用特定的指令。如果使用 cmd 脚本时仍需要在 Java 高版本环境中运行，也可以参照 sh 版本脚本修改一下对应的虚拟机参数。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/3e12c58e5dd33d6864284ce2a5f8b783.png\" class=\"\" title=\"问题定位2-3\">\n<p><strong>处理方法</strong>：这里提供一个根据 sh 脚本修改过来的适配高版本 java 的 cmd 脚本，使用高版本运行时用该脚本替代原本的 runserver.cmd 即可。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\">rem Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class=\"line\">rem contributor license agreements.  See the NOTICE file distributed with</span><br><span class=\"line\">rem this work <span class=\"keyword\">for</span> additional information regarding copyright ownership.</span><br><span class=\"line\">rem The ASF licenses this file to You under the Apache License, Version <span class=\"number\">2.0</span></span><br><span class=\"line\">rem (the <span class=\"string\">&quot;License&quot;</span>); you may not use this file except <span class=\"keyword\">in</span> compliance with</span><br><span class=\"line\">rem the License.  You may obtain a <span class=\"built_in\">copy</span> of the License at</span><br><span class=\"line\">rem</span><br><span class=\"line\">rem     http://www.apache.org/licenses/LICENSE<span class=\"literal\">-2</span>.<span class=\"number\">0</span></span><br><span class=\"line\">rem</span><br><span class=\"line\">rem Unless required by applicable law or agreed to <span class=\"keyword\">in</span> writing, software</span><br><span class=\"line\">rem distributed under the License is distributed on an <span class=\"string\">&quot;AS IS&quot;</span> BASIS,</span><br><span class=\"line\">rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class=\"line\">rem See the License <span class=\"keyword\">for</span> the specific language governing permissions and</span><br><span class=\"line\">rem limitations under the License.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> not exist <span class=\"string\">&quot;%JAVA_HOME%\\bin\\java.exe&quot;</span> <span class=\"built_in\">echo</span> Please <span class=\"built_in\">set</span> the JAVA_HOME variable <span class=\"keyword\">in</span> your environment, We need java(x64)! &amp; <span class=\"keyword\">EXIT</span> /B <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA=%JAVA_HOME%\\bin\\java.exe&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">setlocal</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> BASE_DIR=%~dp0</span><br><span class=\"line\"><span class=\"built_in\">set</span> BASE_DIR=%BASE_DIR:~<span class=\"number\">0</span>,<span class=\"literal\">-1</span>%</span><br><span class=\"line\"><span class=\"keyword\">for</span> %%d <span class=\"keyword\">in</span> (%BASE_DIR%) <span class=\"keyword\">do</span> <span class=\"built_in\">set</span> BASE_DIR=%%~dpd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> CLASSPATH=.;%BASE_DIR%conf;%BASE_DIR%lib\\*;%CLASSPATH%</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -server -Xms4g -Xmx4g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=25 -XX:InitiatingHeapOccupancyPercent=30 -XX:SoftRefLRUPolicyMSPerMB=0&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -verbose:gc -Xloggc:&quot;</span>%USERPROFILE%\\rmq_srv_gc.log<span class=\"string\">&quot; -XX:+PrintGCDetails&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -XX:-OmitStackTraceInFastThrow&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -XX:-UseLargePages&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% %JAVA_OPT_EXT% -cp &quot;</span>%CLASSPATH%<span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> %*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;%JAVA%&quot;</span> %JAVA_OPT% %*</span><br></pre></td></tr></table></figure>\n<p><strong>为什么不对 cmd 脚本进行适配呢？</strong></p>\n<p>sh 脚本中的 java 版本适配其本质上，是通过运行  <code>java -version</code>  命令<br>\n获取到控制台输出的完整 java 版本信息。再通过字符串匹配的方式来获取 java 版本号，再去以 8 为基准去匹配对应的运行参数。</p>\n<p>经过测试，windows 平台下的 java -version 获取到的版本字符串通过命令行是无法捕获到的。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/b7e356d6851105053394a790c1b7de7f.png\" class=\"\" title=\"问题定位2-4\">\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/f051b72f858d696bb84b1f1c4eed0d5b.png\" class=\"\" title=\"问题定位2-5\">\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/1c6676e01f035d76dad63ad38e9526d7.png\" class=\"\" title=\"问题定位2-6\">\n<p>推测也就是这个原因 windows 导致没有办法单独通过命令行来确定 java 版本号，也自然就没有办法参照其进行适配了。</p>\n<h3 id=\"找不到或无法加载主类\"><a class=\"markdownIt-Anchor\" href=\"#找不到或无法加载主类\">#</a> 找不到或无法加载主类</h3>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/1e4aced6e93a87a20cd4152794c4fe3b.png\" class=\"\" title=\"问题定位3-1\">\n<p>该问题的主要诱因是环境变量中存在空格。导致解析命令时环境变量被分割成了两个命令。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/7ac4047b712f71097b7aff8518a1ec40.png\" class=\"\" title=\"问题定位3-2\">\n<p><strong>处理方法</strong>：最好的解决办法是变更目录，在 RocketMQ 的路径中不要存在空格。</p>\n<p>还有，其实当命令中存在不需要被分割的空格时，只需要使用 双引号 &quot;&quot; 将对应的命令包裹起来即可。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/3de37e56ef97c4035b99d58bca794e1a.png\" class=\"\" title=\"问题定位3-3\">\n<p>但是此处经过尝试后发现，该处被错误分割的情况消失，但是仍然存在问题，可能在 runserver 中的 BASE_DIR 与 CLASSPATH 等变量也需要加上双引号防止错误分割，解决起来较为麻烦，而且不清楚后续会不会造成其他问题，因此不再对这种情况进行处理。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/58845da6a693a14c8060ad228ef530fa.png\" class=\"\" title=\"问题定位3-4\">\n<h1 id=\"broker\"><a class=\"markdownIt-Anchor\" href=\"#broker\">#</a> Broker</h1>\n<h2 id=\"启动\"><a class=\"markdownIt-Anchor\" href=\"#启动\">#</a> 启动</h2>\n<p>在启动前需要先添加一个环境变量 NAMESRV_ADDR，用来指向 nameServer 服务的地址。因为测试部署时服务部署在本机，所以使用 localhost 地址，加上此前默认的端口 9876 作为环境变量值。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/66fc0e9db8f6c85a73f5ccd3f895102c.png\" class=\"\" title=\"broker环境变量\">\n<p>打开 cmd 命令行后，通过 cd 命令进入到 RocketMQ 解压目录的 bin 目录下，运行命令 <code>start mqbroker.cmd autoCreateTopicEnable=true</code>  启动服务。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/5ddf87816c70d2451863102cdf413784.png\" class=\"\" title=\"broker启动\">\n<p>出现 The broker […] boot success 提示则表示 broker 服务启动成功，启动成功后同样不要关闭该命令窗口。</p>\n<h3 id=\"可能出现的问题-2\"><a class=\"markdownIt-Anchor\" href=\"#可能出现的问题-2\">#</a> 可能出现的问题</h3>\n<p>因为运行逻辑类似，因此也会出现上述情况类似的问题，此处不过多阐述，对照着修改即可。</p>\n<p>关于 java 版本适配的问题，此处也提供一个高版本可用的运行脚本:</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\">rem Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class=\"line\">rem contributor license agreements.  See the NOTICE file distributed with</span><br><span class=\"line\">rem this work <span class=\"keyword\">for</span> additional information regarding copyright ownership.</span><br><span class=\"line\">rem The ASF licenses this file to You under the Apache License, Version <span class=\"number\">2.0</span></span><br><span class=\"line\">rem (the <span class=\"string\">&quot;License&quot;</span>); you may not use this file except <span class=\"keyword\">in</span> compliance with</span><br><span class=\"line\">rem the License.  You may obtain a <span class=\"built_in\">copy</span> of the License at</span><br><span class=\"line\">rem</span><br><span class=\"line\">rem     http://www.apache.org/licenses/LICENSE<span class=\"literal\">-2</span>.<span class=\"number\">0</span></span><br><span class=\"line\">rem</span><br><span class=\"line\">rem Unless required by applicable law or agreed to <span class=\"keyword\">in</span> writing, software</span><br><span class=\"line\">rem distributed under the License is distributed on an <span class=\"string\">&quot;AS IS&quot;</span> BASIS,</span><br><span class=\"line\">rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class=\"line\">rem See the License <span class=\"keyword\">for</span> the specific language governing permissions and</span><br><span class=\"line\">rem limitations under the License.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> not exist <span class=\"string\">&quot;%JAVA_HOME%\\bin\\java.exe&quot;</span> <span class=\"built_in\">echo</span> Please <span class=\"built_in\">set</span> the JAVA_HOME variable <span class=\"keyword\">in</span> your environment, We need java(x64)! &amp; <span class=\"keyword\">EXIT</span> /B <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA=%JAVA_HOME%\\bin\\java.exe&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">setlocal</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> BASE_DIR=%~dp0</span><br><span class=\"line\"><span class=\"built_in\">set</span> BASE_DIR=%BASE_DIR:~<span class=\"number\">0</span>,<span class=\"literal\">-1</span>%</span><br><span class=\"line\"><span class=\"keyword\">for</span> %%d <span class=\"keyword\">in</span> (%BASE_DIR%) <span class=\"keyword\">do</span> <span class=\"built_in\">set</span> BASE_DIR=%%~dpd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> CLASSPATH=.;%BASE_DIR%conf;%BASE_DIR%lib\\*;%CLASSPATH%</span><br><span class=\"line\"></span><br><span class=\"line\">rem ===========================================================================================</span><br><span class=\"line\">rem  JVM Configuration</span><br><span class=\"line\">rem ===========================================================================================</span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -server -Xms2g -Xmx2g&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=25 -XX:InitiatingHeapOccupancyPercent=30 -XX:SoftRefLRUPolicyMSPerMB=0 -XX:SurvivorRatio=8&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -verbose:gc -Xlog:gc*:file=%USERPROFILE%/mq_gc.log:time,tags:filecount=5,filesize=30M&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -XX:-OmitStackTraceInFastThrow&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -XX:+AlwaysPreTouch&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -XX:MaxDirectMemorySize=15g&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -XX:-UseLargePages -XX:-UseBiasedLocking&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% -Drocketmq.client.logUseSlf4j=true&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"string\">&quot;JAVA_OPT=%JAVA_OPT% %JAVA_OPT_EXT% -cp %CLASSPATH%&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;%JAVA%&quot;</span> %JAVA_OPT% %*</span><br></pre></td></tr></table></figure>\n<p>用其取代 runbroker.cmd 即可。</p>\n<h4 id=\"导包问题\"><a class=\"markdownIt-Anchor\" href=\"#导包问题\">#</a> 导包问题</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalAccessError: <span class=\"keyword\">class</span> <span class=\"title class_\">org</span>.apache.rocketmq.common.UtilAll (in unnamed <span class=\"keyword\">module</span> @<span class=\"number\">0x4bde3f8a</span>) cannot access <span class=\"keyword\">class</span> <span class=\"title class_\">sun</span>.nio.ch.DirectBuffer (in <span class=\"keyword\">module</span> java.base) because <span class=\"keyword\">module</span> java.base does not export sun.nio.ch to unnamed <span class=\"keyword\">module</span> @<span class=\"number\">0x4bde3f8a</span></span><br></pre></td></tr></table></figure>\n<p>在启动参数中额外添加一句 <code>--add-exports=java.base/sun.nio.ch=ALL-UNNAMED</code>  即可.。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;%JAVA%&quot;</span> %JAVA_OPT% %*</span><br></pre></td></tr></table></figure>\n<p>更改为</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;%JAVA%&quot;</span> <span class=\"literal\">--add-exports</span>=java.base/sun.nio.ch=ALL<span class=\"literal\">-UNNAMED</span>  %JAVA_OPT% %*</span><br></pre></td></tr></table></figure>\n<h1 id=\"控制台\"><a class=\"markdownIt-Anchor\" href=\"#控制台\">#</a> 控制台</h1>\n<p>上述服务搭建成功后服务就已经可用了，但是为了便于管理其中的数据，我们需要搭建一个控制台，用来提供一个前端页面供我们管理数据。</p>\n<h2 id=\"获取源码\"><a class=\"markdownIt-Anchor\" href=\"#获取源码\">#</a> 获取源码</h2>\n<p>在早些时候，控制台项目隶属于<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcS1leHRlcm5hbHM=\"> GitHub - apache/rocketmq-externals</span><br>\n 项目下，位于其中的 rocketmq-console 中，其中还包含一些其他的 RocketMQ 的拓展项目，可以参考使用。后来控制台项目单独独立了出来，我们可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcS1kYXNoYm9hcmQ=\"> GitHub - apache/rocketmq-dashboard</span><br>\n 仓库中找到。</p>\n<p>首先将其源码通过以下 git 指令克隆到本地。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/apache/rocketmq-dashboard.git</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装依赖\"><a class=\"markdownIt-Anchor\" href=\"#安装依赖\">#</a> 安装依赖</h2>\n<p>克隆完毕后因为还需要处理依赖，有条件的话可以直接使用 JAVA 编译器打开，使用 IDEA 导入为 maven 项目的话会自动加载依赖，其本质上就是 java<br>\nspring 的项目。如果依赖下载较慢可以使用阿里的 maven 仓库作为中央仓库，因为本来就是阿里的项目，应该不会存在依赖版本等的问题。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mirrors</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>alimaven<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>aliyun maven<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">mirrorOf</span>&gt;</span>central<span class=\"tag\">&lt;/<span class=\"name\">mirrorOf</span>&gt;</span>        </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>不借助编译器处理依赖的话可以 cd 到项目目录下，自行使用 mvn 的指令去处理依赖。</p>\n<h2 id=\"启动-2\"><a class=\"markdownIt-Anchor\" href=\"#启动-2\">#</a> 启动</h2>\n<p>在依赖安装完成之后，在运行之前先要修改一下配置。其实配置项的功能描述在 application.yml 中都有，没有的大多是 spring 的基本配置，查 spring 对应的配置项即可。此处只包括影响到应用启动的配置。</p>\n<h3 id=\"配置nameserver地址\"><a class=\"markdownIt-Anchor\" href=\"#配置nameserver地址\">#</a> 配置 NameServer 地址</h3>\n<p>在 application.yml 中，需要配置一下此前的 NameServer 的 ip 地址，因为源码中的配置文件中 NameServer 地址配置多了一个 127.0.0.2:<br>\n9876 地址，运行过程中连接不上可能会报错，删掉即可。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/ab64039c47990f681af7755c6bd38b34.png\" class=\"\" title=\"配置控制台1\">\n<p>此处可以配置一个，也可以配置多个，使用 yml 的数组写法即可，即在每一项数组元素均使用 “-” 开头。</p>\n<p>如果在 properties 文件中数组则是类似于通常数组的写法，只不过每个元素都要单独写一项，比较麻烦。</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">rocketmq.config.namesrvAddrs[0]</span>=<span class=\"string\">127.0.0.1:9876</span></span><br><span class=\"line\"><span class=\"attr\">rocketmq.config.namesrvAddrs[1]</span>=<span class=\"string\">127.0.0.2:9876</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"配置启动端口\"><a class=\"markdownIt-Anchor\" href=\"#配置启动端口\">#</a> 配置启动端口</h3>\n<p>也可以配置一下当前控制台的启动使用的访问端口，随意一个空闲端口即可。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/b8fde91e184e69dc9ff077345526cc86.png\" class=\"\" title=\"配置控制台2\">\n<h3 id=\"启动-3\"><a class=\"markdownIt-Anchor\" href=\"#启动-3\">#</a> 启动</h3>\n<p>使用编译器启动，通过 <code>mvn spring-boot:run</code>  启动或者通过 maven 打包成 jar 包然后运行 jar 包均可，运行成功后如下图。</p>\n<h2 id=\"部署\"><a class=\"markdownIt-Anchor\" href=\"#部署\">#</a> 部署</h2>\n<p>部署时可以参照传统的 maven 项目进行打包部署，另外官方也提供了 docker 镜像来便捷部署，根据 ReadMe 中描述，通过以下 docker 指令拉取 docker 镜像。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull apacherocketmq/rocketmq<span class=\"literal\">-dashboard</span>:latest</span><br></pre></td></tr></table></figure>\n<p>然后通过以下指令修改参数后运行即可</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run <span class=\"literal\">-d</span> <span class=\"literal\">--name</span> rocketmq<span class=\"literal\">-dashboard</span> <span class=\"literal\">-e</span> <span class=\"string\">&quot;JAVA_OPTS=-Drocketmq.namesrv.addr=127.0.0.1:9876&quot;</span> <span class=\"literal\">-p</span> <span class=\"number\">8080</span>:<span class=\"number\">8080</span> <span class=\"literal\">-t</span> apacherocketmq/rocketmq<span class=\"literal\">-dashboard</span>:latest</span><br></pre></td></tr></table></figure>\n<p>其中 rockermq.namesrv.addr 的值为此前部署的 NameServer 的地址，-p 参数冒号前的值为应用在虚拟机中的启动端口，后面的值应该映射到宿主机开放给该服务的端口。</p>\n<h2 id=\"访问\"><a class=\"markdownIt-Anchor\" href=\"#访问\">#</a> 访问</h2>\n<p>启动后通过部署的 ip+port 端口的形式访问即可。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/3dad91ef206cef1c546745174e4bf0ea.png\" class=\"\" title=\"控制台界面\">\n<p>需要中文界面的话可以通过 ChangeLanguage 来切换语言。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/017a22bd9ca7d08ef9fe8bfd5559ad35.png\" class=\"\" title=\"英文\">\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/de23f48aafc56e32495a4e8b2ef513b7.png\" class=\"\" title=\"汉语\">\n<p>多语化文件放置在源码目录下的 <code>src/main/resources/static/src/i18n</code>  文件夹中，可参照前端的 i18n 标准自行修改翻译或者添加其他语言。</p>\n<img data-src=\"/joker.github.io/2024/09/09/%E3%80%90RocketMQ%E3%80%91%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88Windows%EF%BC%89/cf3c5cd85f377a8d290e097b17e8dadd.png\" class=\"\" title=\"多语\">\n",
            "tags": [
                "后端",
                "MQ",
                "RocketMQ"
            ]
        }
    ]
}