{
    "version": "https://jsonfeed.org/version/1",
    "title": "Joker • All posts by \"redis\" tag",
    "description": "",
    "home_page_url": "https://silvercrow42.github.io/joker.github.io",
    "items": [
        {
            "id": "https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/",
            "url": "https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/",
            "title": "【Redis】Redis详解",
            "date_published": "2024-09-13T05:52:28.000Z",
            "content_html": "<h1 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h1>\n<h2 id=\"redis-是什么\"><a class=\"markdownIt-Anchor\" href=\"#redis-是什么\">#</a> Redis 是什么</h2>\n<p>Redis（Remote Dictionary Server）是一个开源的键值存储系统，以其高性能和低延迟著称。它最初由 Salvatore<br>\nSanfilippo 编写，并于 2009 年首次发布。Redis 不仅可以作为数据库使用，还可以作为缓存和消息代理。Redis 支持多种数据结构，如字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted<br>\nsets）等，这使得它非常适合用于多种应用场景</p>\n<h2 id=\"redis-的特点\"><a class=\"markdownIt-Anchor\" href=\"#redis-的特点\">#</a> Redis 的特点</h2>\n<ul>\n<li>内存存储：Redis 将所有数据都存储在内存中，这使得它能够提供非常高的读写速度，通常能够达到数十万次每秒的读写操作（QPS）。</li>\n<li>持久化：尽管 Redis 主要是一个内存数据库，但它也提供了数据持久化的机制，包括 RDB（Redis Database Backup）快照和 AOF（Append Only<br>\nFile）日志两种方式。</li>\n<li>数据结构丰富：除了基本的键值对存储之外，Redis 还支持多种复杂的数据结构，如列表、集合、有序集合等，这使得它非常适合用于构建复杂的数据模型。</li>\n<li>网络透明：Redis 使用 TCP 协议，客户端可以通过网络访问 Redis 服务器，支持跨平台部署。</li>\n<li>主从复制：Redis 支持主从复制机制，可以轻松地设置数据备份和读写分离。</li>\n<li>Lua 脚本：Redis 支持在服务器端执行 Lua 脚本，允许用户将复杂的操作封装成一个原子性的操作。</li>\n<li>事务：Redis 支持事务，允许用户将一系列操作打包成一个单独的命令序列执行。</li>\n<li>发布 / 订阅模式：Redis 支持发布 / 订阅模式，可以用于构建消息队列或事件驱动的应用程序。</li>\n<li>集群：Redis 3.0 之后版本支持官方的集群模式，可以实现数据的水平扩展。</li>\n<li>多线程：Redis 6.0 版本引入了多线程模型，用于异步处理 I/O 和其他耗时操作，进一步提升了性能。</li>\n</ul>\n<h2 id=\"redis-的应用场景\"><a class=\"markdownIt-Anchor\" href=\"#redis-的应用场景\">#</a> Redis 的应用场景</h2>\n<p>由于其高性能和灵活性，Redis 被广泛应用于多种场景中：</p>\n<ul>\n<li>缓存：由于 Redis 的高速读写能力，它经常被用作 Web 应用的缓存层，以减轻后端数据库的压力。</li>\n<li>会话存储：Redis 可以用来存储用户的会话信息，支持快速的读取和更新操作。</li>\n<li>排行榜：Redis 的有序集合非常适合用来构建排行榜，可以高效地进行排序和范围查询。</li>\n<li>消息队列：通过发布 / 订阅模式，Redis 可以作为一个轻量级的消息队列系统。</li>\n<li>实时数据分析：Redis 的数据结构非常适合用于处理实时数据流，如实时统计、监控等。</li>\n<li>分布式锁：Redis 可以用来实现简单的分布式锁机制，协调多个节点上的并发操作。</li>\n</ul>\n<h2 id=\"redis-的数据结构\"><a class=\"markdownIt-Anchor\" href=\"#redis-的数据结构\">#</a> Redis 的数据结构</h2>\n<h3 id=\"底层数据结构\"><a class=\"markdownIt-Anchor\" href=\"#底层数据结构\">#</a> 底层数据结构</h3>\n<h4 id=\"redisobject\"><a class=\"markdownIt-Anchor\" href=\"#redisobject\">#</a> redisObject</h4>\n<p>定义：redisObject（通常缩写为 robj）是 Redis 中用来表示数据库键值对的一个核心数据结构。每一个键值对在 Redis 内部都会被转化为一个 redisObject 实例进行管理。这个结构体不仅包含了键或值本身的数据，还提供了额外的信息来帮助 Redis 更好地管理和操作这些对象。</p>\n<p>用途：redisObject 是 Redis 中键值对存储的数据结构，它封装了键和值，并提供了额外的元数据，如引用计数、过期时间等。其主要作用在于：</p>\n<ul>\n<li>类型和编码：它使得 Redis 能够灵活地存储不同类型的数据，并且可以根据数据的特点选择最合适的编码方式来存储，从而优化内存使用和访问速度。</li>\n<li>内存管理：通过引用计数，redisObject 支持对象的共享和自动内存回收，减少了不必要的内存分配和释放操作。</li>\n<li>LRU 缓存淘汰：通过记录对象的最后访问时间，Redis 可以实现基于 LRU 算法的对象淘汰，从而在内存资源有限的情况下，优先保留最近使用的对象。</li>\n<li>共享对象：对于一些常用的简单对象（如数字 0 和 1，以及空字符串），Redis 会创建一次并复用，这减少了创建和销毁对象的开销。</li>\n</ul>\n<p>底层实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> lru:REDIS_LRU_BITS; <span class=\"comment\">/* LRU time (relative to server.lruclock) */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"type\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n<p>redisObject 的基本结构通常包含以下字段：</p>\n<ul>\n<li>type: 一个 4 位的无符号整数，用来标识对象的类型。Redis 支持多种数据类型，如字符串（string）、列表（list）、集合（set）、哈希（hash）、有序集合（sorted<br>\nset）等，每种类型都有一个对应的标识符。</li>\n<li>encoding: 另一个 4 位的无符号整数，表示对象的编码方式。不同的数据类型有不同的内部编码方式，例如字符串可以是普通的字符串，也可以是压缩后的字符串（embstr），列表可以是链表（list）或者快速列表（quicklist）等。</li>\n<li>lru: 一个时间戳，记录了对象最后一次被访问的时间（相对于服务器的 lruclock）。这个字段用于实现 Redis 的 LRU（Least Recently<br>\nUsed）缓存淘汰策略。</li>\n<li>refcount: 引用计数器，用来追踪有多少地方引用了这个对象。当一个对象不再被任何地方引用时，其引用计数器减至零，Redis 可以回收该对象占用的内存。</li>\n<li>ptr: 一个指向实际数据的指针。这个指针指向的具体内容依赖于对象的类型和编码方式。</li>\n</ul>\n<h4 id=\"动态字符串sds\"><a class=\"markdownIt-Anchor\" href=\"#动态字符串sds\">#</a> 动态字符串（SDS）</h4>\n<p>定义：SDS（Simple Dynamic String）是一种动态字符串，它使用一个结构体来保存字符串的指针、长度和未使用的空间。</p>\n<p>底层实现：使用简单动态字符串（SDS）来存储数据，SDS 是为了克服 C 字符串的一些不足而设计的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//记录buf数组中已使用字节的数量</span></span><br><span class=\"line\">    <span class=\"comment\">//等于 SDS 保存字符串的长度</span></span><br><span class=\"line\">    <span class=\"type\">int</span> len;</span><br><span class=\"line\">    <span class=\"comment\">//记录 buf 数组中未使用字节的数量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"built_in\">free</span>;</span><br><span class=\"line\">    <span class=\"comment\">//字节数组，用于保存字符串</span></span><br><span class=\"line\">    <span class=\"type\">char</span> buf[];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用 SDS 保存字符串 “Redis” 具体图示如下：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1120165-20180528075607627-218845583.png\" class=\"\" title=\"1120165-20180528075607627-218845583.png\">\n<p>图片来源：《Redis 设计与实现》</p>\n<p>我们看上面对于 SDS 数据类型的定义：</p>\n<ul>\n<li>len 保存了 SDS 保存字符串的长度</li>\n<li>buf [] 数组用来保存字符串的每个元素</li>\n<li>free j 记录了 buf 数组中未使用的字节数量</li>\n</ul>\n<p>上面的定义相对于 C 语言对于字符串的定义，有什么好处？</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1120165-20180527234349672-568401853.png\" class=\"\" title=\"1120165-20180528075607627-218845583.png\">\n<ol>\n<li>\n<p>常数复杂度获取字符串长度：由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O (1)。而对于 C<br>\n 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O (n)。通过 strlen key 命令可以获取 key 的字符串长度。</p>\n</li>\n<li>\n<p>杜绝缓冲区溢出：我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于<br>\n SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求。如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p>\n</li>\n<li>\n<p>减少修改字符串的内存重新分配次数:<br>\nC 语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p>\n<p>而对于 SDS，由于 len 属性和 free 属性的存在，对于修改字符串 SDS 实现了空间预分配和惰性空间释放两种策略：</p>\n<ol>\n<li>空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</li>\n<li>惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free<br>\n 属性将这些字节的数量记录下来，等待后续使用。（当然 SDS 也提供了相应的 API，当我们有需要时，也可以手动释放这些未使用的空间。）</li>\n</ol>\n</li>\n<li>\n<p>二进制安全</p>\n<p>因为 C 字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此 C 字符串无法正确存取；而所有<br>\n SDS 的 API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len<br>\n 属性表示的长度来判断字符串是否结束。</p>\n</li>\n<li>\n<p>兼容部分 C 字符串函数</p>\n<p>虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库 &lt;string.h&gt; 中的一部分函数。</p>\n</li>\n</ol>\n<p>一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）来使用。</p>\n<h4 id=\"压缩列表zip-list\"><a class=\"markdownIt-Anchor\" href=\"#压缩列表zip-list\">#</a> 压缩列表（Zip List）</h4>\n<p>定义：Ziplist 是一种特殊的内存紧凑型数据结构，用于存储多个相邻的元素。它主要用于实现 Redis 中的列表（List）和哈希（Hash）数据类型，当这些数据类型的数据量较小且元素较短时，使用 ziplist 可以节省内存空间。</p>\n<p>底层实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> header; <span class=\"comment\">// 标记ziplist的开始，通常是一个固定的字节（例如 0x01）</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> length; <span class=\"comment\">// 整个ziplist的长度，包括所有条目和前缀信息。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Entries</span></span><br><span class=\"line\">    <span class=\"comment\">// Each entry has a length prefix and content</span></span><br><span class=\"line\">    <span class=\"comment\">// The number of entries is determined by the length field</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Example entry structure:</span></span><br><span class=\"line\">    <span class=\"comment\">// Length prefix (1 or 5 bytes)</span></span><br><span class=\"line\">    <span class=\"comment\">// Content (variable length)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// End marker</span></span><br><span class=\"line\">    <span class=\"type\">char</span> end; <span class=\"comment\">// 标记ziplist的结束，通常是一个固定的字节（例如 0xff）。</span></span><br><span class=\"line\">&#125; <span class=\"type\">ziplist_t</span>;</span><br></pre></td></tr></table></figure>\n<p>实现细节：</p>\n<ul>\n<li>前缀：每个元素的前缀包含了元素的长度信息，以及元素的类型信息。</li>\n<li>长度编码：ziplist 使用可变长度编码来存储元素的长度，这样可以更高效地利用内存。</li>\n<li>内存紧凑：由于 ziplist 将所有元素存储在一个连续的内存区域中，因此它可以有效地减少内存碎片。</li>\n</ul>\n<p>特点</p>\n<ul>\n<li>连续存储：ziplist 将多个元素存储在一个连续的内存块中。</li>\n<li>元素和长度信息：每个元素的前面都会有一个前缀，这个前缀包含了元素的长度信息。</li>\n<li>支持多种类型：ziplist 可以存储整数或字符串，整数直接存储在前缀中，字符串则存储在前缀之后。</li>\n</ul>\n<h4 id=\"双向链表linkedlist\"><a class=\"markdownIt-Anchor\" href=\"#双向链表linkedlist\">#</a> 双向链表（linkedlist）</h4>\n<p>定义：在 Redis 中，linkedlist（通常指的是 Redis 内部实现的双向链表）是 Redis 用来存储 list 键值对的一种底层数据结构。它允许 Redis 从列表的两端高效地添加和移除元素，</p>\n<p>底层实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个双向链表节点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span>  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span>&#123;</span></span><br><span class=\"line\">       <span class=\"comment\">//前置节点</span></span><br><span class=\"line\">       <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\">       <span class=\"comment\">//后置节点</span></span><br><span class=\"line\">       <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">       <span class=\"comment\">//节点的值</span></span><br><span class=\"line\">       <span class=\"type\">void</span> *value;  </span><br><span class=\"line\">&#125;listNode</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个双向链表</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span>&#123;</span></span><br><span class=\"line\">     <span class=\"comment\">//表头节点</span></span><br><span class=\"line\">     listNode *head;</span><br><span class=\"line\">     <span class=\"comment\">//表尾节点</span></span><br><span class=\"line\">     listNode *tail;</span><br><span class=\"line\">     <span class=\"comment\">//链表所包含的节点数量</span></span><br><span class=\"line\">     <span class=\"type\">unsigned</span> <span class=\"type\">long</span> len;</span><br><span class=\"line\">     <span class=\"comment\">//节点值复制函数</span></span><br><span class=\"line\">     <span class=\"type\">void</span> (*<span class=\"built_in\">free</span>) (<span class=\"type\">void</span> *ptr);</span><br><span class=\"line\">     <span class=\"comment\">//节点值释放函数</span></span><br><span class=\"line\">     <span class=\"type\">void</span> (*<span class=\"built_in\">free</span>) (<span class=\"type\">void</span> *ptr);</span><br><span class=\"line\">     <span class=\"comment\">//节点值对比函数</span></span><br><span class=\"line\">     <span class=\"type\">int</span> (*match) (<span class=\"type\">void</span> *ptr,<span class=\"type\">void</span> *key);</span><br><span class=\"line\">&#125;<span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure>\n<p>数据结构如下图</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1120165-20180528074403440-111834793.png\" class=\"\" title=\"1120165-20180528074403440-111834793.png\">\n<p>Redis 的 linkedlist 是由一系列 listNode 节点构成的双向链表。</p>\n<p>每个 listNode 包含三个主要部分：</p>\n<ul>\n<li>prev：指向列表中前一个节点的指针。</li>\n<li>next：指向列表中后一个节点的指针。</li>\n<li>value：存储实际数据的字段，这个字段实际上是指向 redisObject 的指针，redisObject 包含了实际的数据和元数据（如类型、编码等）。</li>\n</ul>\n<p>每个 list 包含三个主要部分：</p>\n<ul>\n<li>head：指向链表的第一个节点。</li>\n<li>tail：指向链表的最后一个节点。</li>\n<li>len：链表的长度，即链表中节点的数量。</li>\n</ul>\n<p>特点</p>\n<ul>\n<li>双向链接：每个节点都包含前驱和后继指针，这使得可以从链表的任一端开始遍历整个链表。</li>\n<li>无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL, 对链表的访问都是以 NULL 结束。</li>\n<li>带链表长度计数器：通过 len 属性获取链表长度的时间复杂度为 O (1)。</li>\n<li>多态：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值。</li>\n<li>动态增长：随着元素的增加，链表可以动态增长。</li>\n</ul>\n<h4 id=\"哈希表hashtable\"><a class=\"markdownIt-Anchor\" href=\"#哈希表hashtable\">#</a> 哈希表（Hashtable）</h4>\n<p>定义：hashtable（哈希表）是一种用于存储键值对的数据结构，它在 Redis 内部用于实现哈希（hash）类型。哈希表允许快速地插入、查找和删除键值对，并且提供了良好的性能。</p>\n<p>底层实现：Redis 中的哈希表实现主要包括两个核心组件：一个数组和一个链表。数组中的每个槽（slot）都可以存储一个链表，链表中的每个节点代表一个键值对。这种设计允许哈希表处理哈希冲突，即多个键映射到同一个数组索引的情况。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    dictEntry **table; <span class=\"comment\">// 哈希桶数组</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> size; <span class=\"comment\">// 哈希桶数组大小</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> used; <span class=\"comment\">// 已使用的哈希桶数量</span></span><br><span class=\"line\">    dictResizeFunc *resize; <span class=\"comment\">// 重置哈希表大小的函数</span></span><br><span class=\"line\">    <span class=\"type\">void</span> (*rehashidx); <span class=\"comment\">// 当前正在进行的哈希表重置索引</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> states; <span class=\"comment\">// 哈希表状态标志</span></span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure>\n<p>Redis 中的哈希表结构定义通常包括以下几个部分：</p>\n<ul>\n<li>table：一个数组，数组的每个元素都是一个链表。</li>\n<li>size：数组的大小。</li>\n<li>used：已使用的槽的数量，即存储键值对的链表数量。</li>\n<li>resize_policy：在某些 Redis 版本中，可能还包括用于控制何时进行重新哈希（resizing）的策略。</li>\n</ul>\n<p>哈希表 table 中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *key; <span class=\"comment\">// 键</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"type\">void</span> *val; <span class=\"comment\">// 值</span></span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> ival; <span class=\"comment\">// 整数值</span></span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span> <span class=\"comment\">// 指向下一个同散列值的dictEntry</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure>\n<p>每个键值对存储在一个 dictEntry 结构体中，该结构体包含：</p>\n<ul>\n<li>key：键的指针，指向 redisObject。</li>\n<li>val：值的指针，同样指向 redisObject。</li>\n<li>next：指向链表中下一个节点的指针，用于处理哈希冲突。</li>\n</ul>\n<h5 id=\"哈希冲突的优化\"><a class=\"markdownIt-Anchor\" href=\"#哈希冲突的优化\">#</a> 哈希冲突的优化</h5>\n<p>我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过 next 这个指针可以将多个哈希值相同的键值对连接在一起，用来解决哈希冲突。</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1120165-20180528080655703-1600710948.png\" class=\"\" title=\"1120165-20180528080655703-1600710948.png\">\n<ol>\n<li>\n<p>哈希算法：Redis 计算哈希值和索引值方法如下：</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"number\">1</span>、使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class=\"line\">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class=\"line\">#<span class=\"number\">2</span>、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值</span><br><span class=\"line\">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>解决哈希冲突：这个问题上面我们介绍了，方法是链地址法。通过字典里面的 *next 指针指向下一个具有相同索引值的哈希表节点。</p>\n</li>\n<li>\n<p>扩容和收缩：当哈希表保存的键值对太多或者太少时，就要通过 rerehash (重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：</p>\n<ol>\n<li>如果执行扩展操作，会基于原哈希表创建一个大小等于 ht [0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。<br>\n相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。</li>\n<li>重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。</li>\n<li>所有键值对都迁徙完毕后，释放原哈希表的内存空间。</li>\n</ol>\n</li>\n<li>\n<p>触发扩容的条件：</p>\n<ol>\n<li>服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于 1。</li>\n<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于 5。</li>\n</ol>\n<p>ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。</p>\n</li>\n<li>\n<p>渐近式 rehash</p>\n<p>什么叫渐进式 rehash？ 也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在 Redis 中的键值对只有几个几十个，那么<br>\n rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行<br>\n rehash，势必会造成 Redis 一段时间内不能进行别的操作。所以 Redis 采用渐进式<br>\n rehash, 这样在进行渐进式 rehash 期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行<br>\n增加操作，一定是在新的哈希表上进行的。</p>\n</li>\n</ol>\n<h4 id=\"整数集合intset\"><a class=\"markdownIt-Anchor\" href=\"#整数集合intset\">#</a> 整数集合（intset）</h4>\n<p>定义：一种特殊的数据结构，主要用于存储整数类型的集合，并且这些整数集合不允许有重复的元素。</p>\n<p>底层实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">intset</span>&#123;</span></span><br><span class=\"line\">     <span class=\"comment\">//编码方式</span></span><br><span class=\"line\">     <span class=\"type\">uint32_t</span> encoding;</span><br><span class=\"line\">     <span class=\"comment\">//集合包含的元素数量</span></span><br><span class=\"line\">     <span class=\"type\">uint32_t</span> length;</span><br><span class=\"line\">     <span class=\"comment\">//保存元素的数组</span></span><br><span class=\"line\">     <span class=\"type\">int8_t</span> contents[];</span><br><span class=\"line\">&#125;intset;</span><br></pre></td></tr></table></figure>\n<p>intset 的数据结构定义通常包括以下几个部分：</p>\n<ul>\n<li>length：表示集合中元素的数量。</li>\n<li>encoding：表示集合中元素的类型，可以是 int16_t、int32_t 或 int64_t，具体取决于集合中最大的整数值所需的位数。</li>\n<li>contents：一个动态数组，用于存储实际的整数值。每个整数根据 encoding 字段指定的类型占用相应的字节数。</li>\n</ul>\n<p>动态升级</p>\n<p>当尝试向 intset 中添加一个超出当前整数类型范围的整数时，Redis 会执行一个称为 “编码升级” 的过程。这个过程会将 intset 中的所有元素转换为更大类型的整数，以适应新加入的元素。例如，如果 intset 当前使用的是 int32_t 类型，而尝试插入一个 int64_t 类型的值，则所有现有的 int32_t 值会被转换成 int64_t 类型。</p>\n<h4 id=\"跳表skip-list\"><a class=\"markdownIt-Anchor\" href=\"#跳表skip-list\">#</a> 跳表（Skip List）</h4>\n<p>定义：Skiplist 是一种线性数据结构，它提供了比传统平衡树更快的查找性能，同时实现相对简单。Redis 使用 skiplist 来实现有序集合（Sorted<br>\nSet）。</p>\n<p>底层实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplist</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">header</span>;</span> <span class=\"comment\">// 跳表头部</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">tail</span>;</span> <span class=\"comment\">// 跳表尾部</span></span><br><span class=\"line\">    <span class=\"type\">int</span> length; <span class=\"comment\">// 跳表长度</span></span><br><span class=\"line\">    <span class=\"type\">int</span> level; <span class=\"comment\">// 跳表层级</span></span><br><span class=\"line\">&#125; zskiplist;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">double</span> score; <span class=\"comment\">// 成员的分数</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *obj; <span class=\"comment\">// 成员对象</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">backward</span>;</span> <span class=\"comment\">// 指向前一个节点的指针</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistLevel</span> &#123;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">forward</span>;</span> <span class=\"comment\">// 指向后一个节点的指针</span></span><br><span class=\"line\">        <span class=\"type\">int</span> span; <span class=\"comment\">// 跨越的节点数量</span></span><br><span class=\"line\">    &#125; level[]; <span class=\"comment\">// 层级数组</span></span><br><span class=\"line\">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>\n<p>实现细节：</p>\n<ul>\n<li>节点结构：skiplist 中的每个节点包含一个元素、一个分数（用于排序）、一个指向前一个节点的指针以及一个或多个指向下一层节点的指针。</li>\n<li>层级：每个节点可以有多个层级，每个层级对应一个指针，指向下一个具有相同高度的节点。</li>\n<li>查找：查找时，从最高层开始，沿着指针前进直到找到目标元素或到达最低层。</li>\n</ul>\n<p>特点：</p>\n<ul>\n<li>多级索引：skiplist 通过构建多级索引来加速查找，每一级索引都是前一级索引的一个子集。</li>\n<li>随机高度：新插入的元素的高度是随机确定的，通常使用随机化算法来决定新节点的高度。</li>\n<li>高效插入和删除：由于 skiplist 的多级索引结构，插入和删除操作也相当高效。</li>\n</ul>\n<h3 id=\"数据结构的使用\"><a class=\"markdownIt-Anchor\" href=\"#数据结构的使用\">#</a> 数据结构的使用</h3>\n<h4 id=\"字符串string\"><a class=\"markdownIt-Anchor\" href=\"#字符串string\">#</a> 字符串（String）</h4>\n<p>用途：存储字符串数据，如文本、数字、日期等。</p>\n<p>实现：根据不同的情况下字符串对象的 encoding 有三种，分别是：int、raw、embstr。</p>\n<ol>\n<li>\n<p>如果一个字符串对象保存的是整数值，并且这个整数值可以用 long 类型标识，那么字符串对象会讲整数值保存在 ptr 属性中，并将<br>\n encoding 设置为 int。比如 set number 10086 命令。</p>\n</li>\n<li>\n<p>如果字符串对象保存的是一个字符串值，并且这个字符串的长度大于 44 字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为<br>\n raw。在这种情况下，ptr 字段指向一个 SDS（Simple Dynamic String）结构。S 在这种情况下，ptr 字段指向一个 SDS（Simple Dynamic<br>\nString）结构。</p>\n</li>\n<li>\n<p>如果字符串对象保存的是一个字符串值，并且这个字符串的长度小于等于 44 字节，那么字符串对象将使用 embstr<br>\n 编码的方式来保存这个字符串。embstr 同样基于 SDS，是一种将 RedisObject 对象头和 SDS 对象连续存在一起，使用 malloc<br>\n 方法一次分配内存的存储形式。 这种编码方式的一些优点：</p>\n<ol>\n<li>embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次。</li>\n<li>释放 embstr 编码的字符串对象只需要调用一次内存释放函数，而释放 raw 编码的字符串对象需要调用两次内存释放函数。</li>\n<li>因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起 raw<br>\n 编码的字符串对象能够更好地利用缓存带来的优势。</li>\n</ol>\n</li>\n</ol>\n<p>为什么分界线是 44 字节？</p>\n<p>Redis 的 embstr 编码的实现中，字符串对象头和字符串对象本身是连续的，因此需要一个字节来保存字符串的长度。<br>\nembstr 最小占用空间为 19（16+3），而 64-19-1（结尾的 \\0）=44，所以 embstr 只能容纳 44 字节。</p>\n<p>使用场景：</p>\n<ul>\n<li>计数器：例如网站的访问计数，可以使用 INCR 或 INCRBY 命令来递增计数器。</li>\n<li>会话存储：存储用户的登录状态或其他临时信息。</li>\n<li>消息队列：使用 LPUSH 和 BRPOP 命令实现简单的消息队列。</li>\n<li>缓存：存储经常访问的数据，减少数据库的访问压力。</li>\n</ul>\n<h4 id=\"列表list\"><a class=\"markdownIt-Anchor\" href=\"#列表list\">#</a> 列表（List）</h4>\n<p>用途：用于存储有序的元素列表，如队列、栈等。</p>\n<p>实现：列表对象的 encoding 有 ziplist 和 linkedlist 两种。</p>\n<ul>\n<li>当列表的长度小于 512，并且所有元素的长度都小于 64 字节时，使用压缩列表 (ziplist) 存储</li>\n<li>当列表的长度大于等于 512，或者有元素长度大于 64 字节时，使用链表 (linkedlist) 存储。</li>\n</ul>\n<p>使用场景：</p>\n<ul>\n<li>消息队列：使用 LPUSH 和 BRPOP 命令实现先进先出（FIFO）的消息队列。</li>\n<li>历史记录：保存用户的浏览历史或购买记录，可以使用 RPUSH 和 LPOP 命令。</li>\n<li>排行榜：使用列表存储排名信息，通过 LREM 命令可以移除特定成员。</li>\n</ul>\n<h4 id=\"哈希hash\"><a class=\"markdownIt-Anchor\" href=\"#哈希hash\">#</a> 哈希（Hash）</h4>\n<p>用途：存储键值对，其中键是唯一的，值可以重复。</p>\n<p>实现：哈希对象的 encoding 有 ziplist 和 hashtable 两种。</p>\n<ul>\n<li>当哈希对象保存的键值对数量小于 512，并且所有键值对的长度都小于 64 字节时，使用压缩列表存储；</li>\n<li>当哈希对象保存的键值对数量大于等于 512，或者有键值对长度大于 64 字节时，使用 hashtable 存储。</li>\n</ul>\n<p>使用场景：</p>\n<ul>\n<li>对象存储：存储复杂对象，如用户信息，每个字段对应用户的一个属性。</li>\n<li>购物车：每个用户有一个购物车，购物车中的商品信息可以用哈希表来存储。</li>\n<li>会话管理：存储用户的会话信息，每个会话 ID 对应一个哈希表。</li>\n</ul>\n<h4 id=\"集合set\"><a class=\"markdownIt-Anchor\" href=\"#集合set\">#</a> 集合（Set）</h4>\n<p>用途：存储不重复的元素集合，如集合、去重列表等。</p>\n<p>实现：集合对象的 encoding 有 intset 和 hashtable 两种。</p>\n<ul>\n<li>当集合中元素数量小于 512，并且所有元素的长度都小于 64 字节时，使用 intset 存储；</li>\n<li>当集合中元素数量大于等于 512，或者有元素长度大于 64 字节时，使用 hashtable 存储。</li>\n</ul>\n<p>使用场景：</p>\n<ul>\n<li>去重：例如在一个活动中，确保每个用户只能参与一次。</li>\n<li>标签系统：每个项目可以有多个标签，使用集合来存储项目的标签。</li>\n<li>好友关系：存储用户的好友列表，可以快速判断两个用户是否互为好友。</li>\n</ul>\n<h4 id=\"有序集合sorted-set\"><a class=\"markdownIt-Anchor\" href=\"#有序集合sorted-set\">#</a> 有序集合（Sorted Set）</h4>\n<p>用途：存储有序的元素集合，其中元素是唯一的，并且可以按照一定的顺序排列。</p>\n<p>实现：有序集合对象的 encoding 有 ziplist 和 skiplist 两种。</p>\n<ol>\n<li>当有序集合中的元素数量小于 512，并且所有元素的长度都小于 64 字节时，使用压缩列表 (ziplist) 存储；</li>\n<li>当有序集合中的元素数量大于等于 512，或者有元素长度大于 64 字节时，使用跳表 (skiplist) 存储。</li>\n</ol>\n<p>使用场景：</p>\n<ul>\n<li>排行榜：根据分数排序的排行榜，如游戏得分、用户贡献度等。</li>\n<li>优先级队列：每个元素都有一个优先级，可以按优先级取出元素。</li>\n<li>时间轴：按时间戳排序的消息或帖子显示，如微博、Facebook 的时间线。</li>\n<li>地理信息：存储地理位置信息，并使用 GEO 命令查询附近的地点。</li>\n</ul>\n<h4 id=\"其他数据结构\"><a class=\"markdownIt-Anchor\" href=\"#其他数据结构\">#</a> 其他数据结构</h4>\n<ul>\n<li>\n<p>Bitmaps：二进制位数组，适合用于存储大量稀疏数据，如用户访问记录、权限控制等。</p>\n<p>使用场景：</p>\n<ul>\n<li>统计分析：例如统计某一天有多少独立用户访问了网站，可以使用一个位图来表示每个用户是否访问过。</li>\n<li>权限管理：每个用户可以有多个权限位，使用位图来表示用户的权限。</li>\n</ul>\n</li>\n<li>\n<p>HyperLogLog：用于近似计算不重复元素的数量，非常适合处理大规模数据集。</p>\n<p>使用场景：</p>\n<ul>\n<li>近似计数：用于估算大量数据中的不重复元素数量，例如统计网站的独立访客数。</li>\n</ul>\n</li>\n<li>\n<p>Streams：类似于消息队列，用于处理异步消息传递，可以实现类似 Kafka 的功能。</p>\n<p>使用场景：</p>\n<ul>\n<li>事件日志：记录系统中的事件，如用户行为日志，可以使用 XADD 添加事件，XREAD 读取事件。</li>\n<li>异步处理：作为消息队列的一部分，将事件发布到流中，然后由消费者异步处理。</li>\n</ul>\n</li>\n<li>\n<p>Geo：用于存储地理位置信息，并提供基于地理位置的查询功能。</p>\n<p>使用场景：</p>\n<ul>\n<li>位置服务：存储地理位置信息，并支持基于地理位置的搜索，如查找附近的餐厅或酒店。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"redis-综合应用示例\"><a class=\"markdownIt-Anchor\" href=\"#redis-综合应用示例\">#</a> Redis 综合应用示例</h4>\n<p>假设我们要构建一个社交网络应用，可以使用 Redis 来实现以下功能：</p>\n<ul>\n<li>用户信息存储：使用 Hash 类型存储每个用户的个人信息，如用户名、头像、生日等。</li>\n<li>好友关系：使用 Set 类型存储每个用户的好友列表。</li>\n<li>动态时间线：使用 Sorted Set 类型存储用户的动态，根据发布时间排序。</li>\n<li>消息通知：使用 List 类型作为消息队列，存储用户收到的通知消息。</li>\n<li>在线状态：使用 BitMap 类型记录每天用户的在线状态。</li>\n<li>热门话题：使用 HyperLogLog 类型来估计参与某个话题讨论的独立用户数量。</li>\n</ul>\n<h2 id=\"redis-的持久化\"><a class=\"markdownIt-Anchor\" href=\"#redis-的持久化\">#</a> Redis 的持久化</h2>\n<p>redis 是一个内存数据库，数据保存在内存中，但是我们都知道内存的数据变化是很快的，也容易发生丢失。幸好 Redis 还为我们提供了持久化的机制，分别是 RDB (<br>\nRedis DataBase) 和 AOF (Append Only File)。</p>\n<h3 id=\"rdb机制\"><a class=\"markdownIt-Anchor\" href=\"#rdb机制\">#</a> RDB 机制</h3>\n<p>RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为 dump.rdb。</p>\n<p>Redis 提供了三种机制：save、bgsave、自动化来触发 RDB 持久化过程：</p>\n<ul>\n<li>\n<p>save 触发方式</p>\n<p>该命令会阻塞当前 Redis 服务器，执行 save 命令期间，Redis 不能处理其他命令，直到 RDB 过程完成为止。具体流程如下：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg\" class=\"\" title=\"e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg\">\n<p>执行完成时候如果存在老的 RDB 文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p>\n</li>\n<li>\n<p>bgsave 触发方式</p>\n<p>执行该命令时，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg\" class=\"\" title=\"023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg\">\n<p>具体操作是 Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短。基本上<br>\n Redis 内部所有的 RDB 操作都是采用 bgsave 命令。</p>\n</li>\n<li>\n<p>自动触发</p>\n<p>自动触发是由我们的配置文件来完成的。在 redis.conf 配置文件中，里面有如下配置，我们可以去设置：</p>\n<ol>\n<li>save：这里是用来配置触发 Redis 的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如 “save m<br>\nn”。表示 m 秒内数据集存在 n 次修改时，自动触发 bgsave。</li>\n<li>stop-writes-on-bgsave-error：默认值为 yes。<br>\n当启用了 RDB 且最后一次后台保存数据失败，Redis 是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果 Redis 重启了，那么又可以重新开始接收数据了</li>\n<li>rdbcompression；默认值是 yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</li>\n<li>rdbchecksum：默认值是 yes。在存储快照后，我们还可以让 redis 使用 CRC64 算法来进行数据校验，但是这样做会增加大约 10% 的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</li>\n<li>dbfilename：设置快照的文件名，默认是 dump.rdb</li>\n<li>dir：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</li>\n</ol>\n<p>我们可以修改这些配置来实现我们想要的效果。</p>\n</li>\n</ul>\n<p>因为第三种方式是配置的，所以我们对前两种进行一个对比：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1c950a7b02087bf43b4490d50ac25f2a11dfcf7e.jpeg\" class=\"\" title=\"1c950a7b02087bf43b4490d50ac25f2a11dfcf7e.jpeg\">\n<p>RDB 的优势和劣势</p>\n<ul>\n<li>\n<p>优势</p>\n<ul>\n<li>RDB 文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</li>\n<li>生成 RDB 文件的时候，redis 主进程会 fork () 一个子进程来处理所有保存工作，主进程不需要进行任何磁盘 IO 操作。</li>\n<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>\n</ul>\n</li>\n<li>\n<p>劣势</p>\n<ul>\n<li>RDB 快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。<br>\n当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"aof机制\"><a class=\"markdownIt-Anchor\" href=\"#aof机制\">#</a> AOF 机制</h3>\n<p>全量备份总是耗时的，Redis 提供一种更加高效的方式 AOF，工作机制很简单，Redis 会将每一个收到的写命令都通过 write 函数追加到文件中。通俗的理解就是日志记录。</p>\n<ol>\n<li>\n<p>持久化原理</p>\n<p>他的原理看下面这张图：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/32fa828ba61ea8d3c2502e396b1b3848251f58b0.jpeg\" class=\"\" title=\"32fa828ba61ea8d3c2502e396b1b3848251f58b0.jpeg\">\n<p>每当有一个写命令过来时，就直接保存在我们的 AOF 文件中。</p>\n</li>\n<li>\n<p>文件重写原理</p>\n<p>AOF 的方式也同时带来了另一个问题：持久化文件会变的越来越大。为了解决这个问题，redis 提供了 bgrewriteaof 命令用来压缩 aof 的持久化文件。这条命令会将内存中的数据以命令的方式保存到临时文件中，同时会 fork 出一条新进程来将文件重写。</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/09fa513d269759ee28454d2c4cea4b106c22dfd3.jpeg\" class=\"\" title=\"09fa513d269759ee28454d2c4cea4b106c22dfd3.jpeg\">\n<p>重写 aof 文件的操作，并没有读取旧的 aof 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 aof 文件，这点和快照有点类似。</p>\n</li>\n</ol>\n<p>AOF 也有三种触发机制</p>\n<ul>\n<li>每修改同步 always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</li>\n<li>每秒同步 everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失</li>\n<li>不同 no：从不同步</li>\n</ul>\n<p>三种触发机制的对比如下图</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/b17eca8065380cd7df69859ba056a5325982816c.jpeg\" class=\"\" title=\"b17eca8065380cd7df69859ba056a5325982816c.jpeg\">\n<p>AOF 的优势和劣势</p>\n<ul>\n<li>优势\n<ul>\n<li>AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次 fsync 操作，最多丢失 1 秒钟的数据。</li>\n<li>AOF 日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</li>\n<li>AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</li>\n<li>AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。<br>\n比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大</li>\n<li>AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"持久化机制的选择\"><a class=\"markdownIt-Anchor\" href=\"#持久化机制的选择\">#</a> 持久化机制的选择</h3>\n<p>通常情况下我们是二者结合使用的。</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>RDB</th>\n<th>AOF</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>启动优先级</td>\n<td>低</td>\n<td>高</td>\n</tr>\n<tr>\n<td>体积</td>\n<td>小</td>\n<td>大</td>\n</tr>\n<tr>\n<td>恢复速度</td>\n<td>快</td>\n<td>慢</td>\n</tr>\n<tr>\n<td>数据安全性</td>\n<td>丢数据</td>\n<td>取决于刷盘策略</td>\n</tr>\n<tr>\n<td>轻重</td>\n<td>重</td>\n<td>轻</td>\n</tr>\n</tbody>\n</table>\n<p>RDB 使用场景</p>\n<ul>\n<li>数据恢复要求不高：如果应用程序可以接受在两次快照之间数据丢失的风险，那么 RDB 是一个很好的选择。</li>\n<li>需要快速恢复大量数据：由于 RDB 文件是一个完整的数据库快照，因此在需要快速恢复大量数据时，RDB 提供了更快的恢复速度。</li>\n<li>定期备份：RDB 适用于需要定期进行完整备份的场景，比如每天一次的全量备份。</li>\n<li>数据归档：RDB 文件可以轻松地传输到远程服务器或存储设备上，用于长期的数据归档或灾难恢复。</li>\n</ul>\n<p>AOF 使用场景</p>\n<ul>\n<li>数据安全性要求高：如果应用程序不能容忍任何数据丢失，那么 AOF 是更好的选择，因为它可以保证数据的完整性。</li>\n<li>频繁写入操作：对于写密集型的应用场景，AOF 可以更好地保证数据的一致性。</li>\n<li>数据重放：AOF 文件可以用来重放数据，这对于调试和审计非常有用。</li>\n<li>自动修复：Redis 可以定期对 AOF 文件进行重写，以压缩文件大小并移除冗余命令。</li>\n</ul>\n<h2 id=\"redis-的内存调度\"><a class=\"markdownIt-Anchor\" href=\"#redis-的内存调度\">#</a> Redis 的内存调度</h2>\n<h3 id=\"redis-的过期策略\"><a class=\"markdownIt-Anchor\" href=\"#redis-的过期策略\">#</a> Redis 的过期策略</h3>\n<h4 id=\"设置过期时间\"><a class=\"markdownIt-Anchor\" href=\"#设置过期时间\">#</a> 设置过期时间</h4>\n<p>Redis 对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置 key 的有效时间。Expires 字典保存了所有键的过期时间，Expires 也被称为过期字段。</p>\n<p>一般主要包括 5 种处理过期方式，其中 expire 都是以秒为单位，pexpire 都是以毫秒为单位的。</p>\n<ul>\n<li><code>EXPIRE key seconds</code> ：将 key 的生存时间设置为 ttl 秒</li>\n<li><code>PEXPIRE key milliseconds</code> ：将 key 的生成时间设置为 ttl 毫秒</li>\n<li><code>EXPIREAT key timestamp</code> ：将 key 的过期时间设置为 timestamp 所代表的的秒数的时间戳</li>\n<li><code>PEXPIREAT key milliseconds-timestamp</code> ：将 key 的过期时间设置为 timestamp 所代表的的毫秒数的时间戳</li>\n<li><code>setex(String key, int seconds, String value)</code> ：字符串独有的方式，为指定的 key 设置值及其过期时间。如果 key 已经存在，<br>\nSETEX 命令将会替换旧的值。</li>\n</ul>\n<p>注：</p>\n<ul>\n<li>timestamp 为 unix 时间戳（例如：timestamp=1499788800 表示将在 2017.07.12 过期）</li>\n<li>1、2 两种方式是设置一个过期的时间段，就是咱们处理验证码最常用的策略，设置三分钟或五分钟后失效，把分钟数转换成秒或毫秒存储到 Redis 中。</li>\n<li>3、4 两种方式是指定一个过期的时间 ，比如优惠券的过期时间是某年某月某日，只是单位不一样。</li>\n<li>如果没有设置时间，那缓存就是永不过期</li>\n<li>如果设置了过期时间，之后又想让缓存永不过期，使用 persist key</li>\n</ul>\n<h4 id=\"过期策略\"><a class=\"markdownIt-Anchor\" href=\"#过期策略\">#</a> 过期策略</h4>\n<ul>\n<li>\n<p>定时过期（Active Expiration）</p>\n<p>含义：当一个键设置了过期时间时，Redis 会在键的过期时间到达时立即清除这个键。</p>\n<p>优点：这种方法可以保证内存被尽快释放，过期的键不会占用内存太久。</p>\n<p>缺点：定时过期需要为每个设置了过期时间的键创建一个定时器，这会占用大量的 CPU 资源来处理过期的数据，从而影响 Redis 的响应时间和吞吐量。</p>\n</li>\n<li>\n<p>被动过期（Lazy Expiration）</p>\n<p>含义：当访问一个键时，Redis 会检查这个键是否已经过期。如果过期，Redis 会删除这个键并返回相应的错误信息给客户端。</p>\n<p>优点：这种方法对 CPU 资源友好，因为它只在访问键时才会检查过期情况。</p>\n<p>缺点：如果过期的键没有被及时访问，那么它将继续占用内存，直到被访问或通过其他方式清理掉为止。</p>\n<p>流程：</p>\n<ol>\n<li>在进行 get 或 setnx 等操作时，先检查 key 是否过期，</li>\n<li>若过期，删除 key，然后执行相应操作；</li>\n<li>若没过期，直接执行相应操作</li>\n</ol>\n</li>\n<li>\n<p>定期过期（Periodic Reaping）</p>\n<p>含义：Redis 会周期性地检查过期的键，并删除一部分过期的键。这种策略试图在内存消耗和 CPU 使用之间找到一个平衡点，可以通过</p>\n<ul>\n<li>配置 redis.conf 的 hz 选项，默认为 10 （即 1 秒执行 10 次，100ms 一次，值越大说明刷新频率越快，对 Redis 性能损耗也越大）</li>\n<li>配置 redis.conf 的 maxmemory 最大值，当已用内存超过 maxmemory 限定时，就会触发主动清理策略。</li>\n</ul>\n<p>优点：通过周期性地检查和删除过期键，可以有效地减少内存浪费，同时通过限制删除操作的执行时长和频率来减少对 CPU 时间的影响。</p>\n<p>缺点：难以确定删除操作执行的时长和频率。如果删除操作执行得太频繁或执行的时间太长，定期删除策略就会退化成定时删除，导致占用太多的 CPU 执行时间。如果删除操作执行得太少或执行时间太短，定期删除策略又会类似于被动过期，导致内存浪费。</p>\n<p>流程：其核心是对指定个数个库的每一个库随机删除小于等于指定个数个过期 key：</p>\n<ol>\n<li>遍历每个数据库（就是 redis.conf 中配置的 “database” 数量，默认为 16）；\n<ol>\n<li>检查当前库中的指定个数个 key （默认是每个库检查 20 个，相当于该循环执行 20 次）：\n<ol>\n<li>如果当前库中没有一个 key 设置了过期时间，直接执行下一个库的遍历；</li>\n<li>随机获取一个设置了过期时间的 key，检查是否过期，如果过期则删除；</li>\n<li>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<p>综合策略</p>\n<p>在实际应用中，Redis 通常会结合使用上述三种策略来管理过期键。例如，Redis 可能会使用定期过期作为主要的过期策略，同时辅以被动过期来处理未被定期过期策略捕获的过期键。此外，对于一些关键操作，Redis 可能会采用定时过期来确保某些重要键在过期后能够立即被释放。</p>\n<h4 id=\"持久化中的过期\"><a class=\"markdownIt-Anchor\" href=\"#持久化中的过期\">#</a> 持久化中的过期</h4>\n<ul>\n<li>\n<p>RDB 对过期 key 的处理</p>\n<p>过期 key 对 RDB 没有任何影响</p>\n<ul>\n<li>从内存数据库持久化数据到 RDB 文件\n<ul>\n<li>持久化 key 之前，会检查是否过期，过期的 key 不进入 RDB 文件</li>\n</ul>\n</li>\n<li>从 RDB 文件恢复数据到内存数据库\n<ul>\n<li>数据载入数据库之前，会对 key 先进行过期检查，如果过期，不导入数据库（主库情况）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>AOF 对过期 key 的处理<br>\n过期 key 对 AOF 没有任何影响</p>\n<ul>\n<li>从内存数据库持久化数据到 AOF 文件：\n<ul>\n<li>当 key 过期后，还没有被删除，此时进行执行持久化操作（该 key 是不会进入 aof 文件的，因为没有发生修改命令）</li>\n<li>当 key 过期后，在发生删除操作时，程序会向 aof 文件追加一条 del 命令（在将来的以 aof 文件恢复数据的时候该过期的键就会被删掉）</li>\n</ul>\n</li>\n<li>AOF 重写\n<ul>\n<li>重写时，会先判断 key 是否过期，已过期的 key 不会重写到 aof 文件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"pipeline\"><a class=\"markdownIt-Anchor\" href=\"#pipeline\">#</a> Pipeline</h2>\n<p>Redis 的 Pipeline 功能允许客户端将多个命令打包成一个请求发送给 Redis 服务器，而不是逐个发送命令。这样做可以显著减少客户端与服务器之间的网络往返次数，从而提高<br>\n Redis 的性能和效率。下面详细介绍 Redis Pipeline 的工作原理、使用场景以及如何使用。</p>\n<p>Pipeline 的工作原理</p>\n<ol>\n<li>打包命令：客户端将多个 Redis 命令打包成一个请求，这个请求包含了所有命令的数据。</li>\n<li>发送请求：客户端一次性将打包好的请求发送给 Redis 服务器。</li>\n<li>执行命令：Redis 服务器接收到请求后，依次执行其中的所有命令。</li>\n<li>返回结果：Redis 服务器将各个命令的结果保存起来，并在所有命令执行完毕后，一次性将所有结果返回给客户端。</li>\n<li>处理结果：客户端接收到所有命令的结果后，按顺序处理这些结果。</li>\n</ol>\n<p>Pipeline 的优点</p>\n<ul>\n<li>减少网络延迟：通过减少客户端与服务器之间的网络往返次数，Pipeline 可以显著降低网络延迟，提高整体性能。</li>\n<li>提高吞吐量：由于减少了网络交互次数，客户端可以更快地处理更多的命令。</li>\n<li>事务性操作：虽然 Pipeline 不保证命令执行的原子性，但是它可以模拟事务的行为，即可以将一组命令作为一个整体发送和接收结果。</li>\n</ul>\n<p>使用场景</p>\n<ul>\n<li>批量操作：当你需要执行一系列相关联的命令时，使用 Pipeline 可以提高效率。</li>\n<li>性能优化：在需要频繁与 Redis 进行交互的应用场景中，使用 Pipeline 可以减少网络开销，提升性能。</li>\n<li>模拟事务：虽然 Redis 的 Pipeline 不保证命令的原子性，但是在不需要严格事务性的场景下，可以使用 Pipeline 来模拟事务行为。</li>\n</ul>\n<p>如何使用 Pipeline<br>\n 在不同的 Redis 客户端库中，使用 Pipeline 的方式略有不同。以下是在几种常见语言中使用 Pipeline 的示例：</p>\n<p>JavaScript (Node.js)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> redis = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;redis&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> client = redis.<span class=\"title function_\">createClient</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">client.<span class=\"title function_\">pipeline</span>()</span><br><span class=\"line\">    .<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;foo&#x27;</span>, <span class=\"string\">&#x27;bar&#x27;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">exec</span>(<span class=\"function\">(<span class=\"params\">err, replies</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(replies); <span class=\"comment\">// replies is an array of responses</span></span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>Python (redis-py)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const redis = require(<span class=\"string\">&quot;redis&quot;</span>);</span><br><span class=\"line\">const client = redis.createClient();</span><br><span class=\"line\"></span><br><span class=\"line\">client.pipeline()</span><br><span class=\"line\">  .<span class=\"built_in\">set</span>(<span class=\"string\">&#x27;foo&#x27;</span>, <span class=\"string\">&#x27;bar&#x27;</span>)</span><br><span class=\"line\">  .get(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"built_in\">exec</span>((err, replies) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) throw err;</span><br><span class=\"line\">    console.log(replies); // replies <span class=\"keyword\">is</span> an array of responses</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>java (jedis)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">Jedis jedis=<span class=\"keyword\">new</span> <span class=\"title class_\">Jedis</span>(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        Pipeline pipelined=jedis.pipelined();</span><br><span class=\"line\">        pipelined.set(<span class=\"string\">&quot;foo&quot;</span>,<span class=\"string\">&quot;bar&quot;</span>);</span><br><span class=\"line\">        pipelined.get(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">        List&lt;Object&gt; results=pipelined.syncAndReturnAll();</span><br><span class=\"line\">        System.out.println(results);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>注意事项</p>\n<ul>\n<li>命令数量：虽然 Pipeline 可以显著提高性能，但如果打包的命令数量过多，可能会导致单个请求的体积过大，增加客户端的等待时间，并可能导致网络阻塞。</li>\n<li>命令执行顺序：Pipeline 中的命令是按照发送顺序执行的，因此需要确保命令间的依赖关系不会导致错误。</li>\n<li>错误处理：如果 Pipeline 中的某条命令执行失败，整个 Pipeline 的结果都会受到影响。因此，在处理 Pipeline<br>\n 的结果时，需要注意检查每个命令的执行状态。</li>\n</ul>\n<p>原生批命令 (mset, mget) 与 Pipeline 对比</p>\n<ul>\n<li>原生批命令是原子性，pipeline 是非原子性</li>\n<li>原生批命令一命令多个 key, 但 pipeline 支持多命令（存在事务），非原子性</li>\n<li>原生批命令是服务端实现，而 pipeline 需要服务端与客户端共同完成</li>\n</ul>\n<h2 id=\"redis-事务\"><a class=\"markdownIt-Anchor\" href=\"#redis-事务\">#</a> Redis 事务</h2>\n<p>Redis 事务是 Redis 中的一个重要特性，它允许客户端在一个事务中执行多个命令，并确保这些命令要么全部执行成功，要么全部执行失败。在事务中，客户端可以提交或回滚整个事务，而不需要关心事务中的命令是否成功执行。尽管<br>\n Redis 事务并不提供传统意义上的 ACID 事务特性（原子性、一致性、隔离性、持久性），但它确实提供了一些基本的功能，使得开发者可以更方便地处理一系列相关的命令。</p>\n<p>Redis 事务的主要功能包括：</p>\n<ul>\n<li>命令队列：客户端可以将多个命令放入一个队列中，然后通过 EXEC 命令一次性发送给 Redis 服务器执行。</li>\n<li>监视（WATCH）：客户端可以监视一个或多个键，如果在执行 EXEC 命令之前这些键被其他客户端修改，则事务会被取消。</li>\n<li>取消（DISCARD）：如果在事务执行之前发现某些条件不满足，客户端可以选择取消事务。</li>\n</ul>\n<p>Redis 事务的实现分为几个步骤：</p>\n<ul>\n<li>事务开始：客户端通过 MULTI 命令开始一个事务。</li>\n<li>命令入队：在 MULTI 命令之后，客户端可以发送任意数量的命令，这些命令将被放入事务队列中，但不会立即执行。</li>\n<li>事务执行：通过 EXEC 命令，客户端可以执行事务队列中的所有命令。如果在此之前使用了 WATCH 命令监视的键被修改，则事务会被取消。</li>\n<li>取消事务：如果在执行 EXEC 命令之前，客户端想要取消事务，可以使用 DISCARD 命令。</li>\n</ul>\n<p>Redis 中事务的特性有：</p>\n<ul>\n<li>原子性：一旦事务开始执行，Redis 会保证事务中的所有命令要么全部执行成功，要么都不执行。然而，如果命令在执行过程中出现错误（如类型错误），Redis<br>\n 会继续执行后续命令。</li>\n<li>一致性：Redis 事务在一定程度上保证了一致性，特别是通过使用 WATCH 命令监视键的变化，可以防止脏读。</li>\n<li>隔离性：由于 Redis 是单线程的，事务中的命令会按顺序执行，因此不存在并发事务之间的隔离性问题。</li>\n<li>持久性：Redis 的持久化机制（如 RDB 或 AOF）保证了数据的持久性，但这与事务无关。</li>\n</ul>\n<p>Redis 事务的限制</p>\n<ul>\n<li>不支持回滚：如果事务中的某个命令失败，Redis 会继续执行剩余的命令，并不会回滚之前的命令。</li>\n<li>错误处理：如果事务中的命令出现错误，Redis 会记录错误并继续执行后续命令。客户端需要处理这些错误。</li>\n<li>性能考虑：虽然事务可以减少网络往返次数，但如果事务中的命令数量过多，可能会导致单个请求过大，反而影响性能。</li>\n</ul>\n<p>Redis 事务的使用场景</p>\n<ul>\n<li>批量操作：当需要执行一系列相关的命令时，可以使用事务来减少网络往返次数，提高性能。</li>\n<li>乐观锁：通过 WATCH 命令监视键的变化，可以实现乐观锁机制，确保在执行事务之前键没有被其他客户端修改。</li>\n<li>模拟事务：虽然 Redis 事务不提供严格的 ACID 特性，但在不需要强一致性的场景下，可以使用事务来模拟事务行为。</li>\n</ul>\n<h2 id=\"redis-多线程\"><a class=\"markdownIt-Anchor\" href=\"#redis-多线程\">#</a> Redis 多线程</h2>\n<p>Redis 作为一种高性能的键值存储系统，最初是单线程设计的，这意味着 Redis 在处理客户端的请求时，包括获取 (socket 读)<br>\n、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的单线程。但如果严格来讲从 Redis 4<br>\n 之后并不是单线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 key 的删除等等。<br>\n这样的设计保证了数据的一致性和简单性，但也限制了 Redis 在多核 CPU 环境下的性能潜力。从 Redis 6.0 开始，Redis<br>\n 引入了多线程的支持，以充分利用现代多核处理器的优势。</p>\n<p>Redis 6 为何引入多线程？</p>\n<p>随着目前行业内越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的<br>\n QPS。常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点，比如：</p>\n<ul>\n<li>\n<p>要管理的 Redis 服务器太多，维护代价大；</p>\n</li>\n<li>\n<p>某些适用于单个 Redis 服务器的命令不适用于数据分区；</p>\n</li>\n<li>\n<p>数据分区无法解决热点读 / 写问题；</p>\n</li>\n<li>\n<p>数据偏斜，重新分配和放大 / 缩小变得更加复杂等等。</p>\n</li>\n</ul>\n<p>从 Redis 自身角度来说，因为读写网络的 read/write 系统调用占用了 Redis 执行期间大部分 CPU 时间，瓶颈主要在于网络的 IO 消耗，<br>\n 优化主要有两个方向:</p>\n<ul>\n<li>\n<p>提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式；</p>\n</li>\n<li>\n<p>使用多线程充分利用多核，典型的实现比如 Memcached。</p>\n</li>\n</ul>\n<p>协议栈优化的这种方式跟 Redis 关系不大，支持多线程是一种最有效最便捷的操作方式。所以总结起来，Redis 支持多线程主要就是两个原因：</p>\n<ul>\n<li>可以充分利用服务器 CPU 资源，目前主线程只能利用一个核；</li>\n<li>多线程任务可以分摊 Redis 同步 IO 读写负荷。</li>\n</ul>\n<p>Redis 多线程的工作原理</p>\n<p>在 Redis 6.0 中，多线程主要用于处理客户端的网络 I/O 操作，包括读取客户端请求、解析请求以及将响应写回到客户端。具体来说：</p>\n<ul>\n<li>多线程 I/O：Redis 在主线程之外创建了若干个 I/O 子线程，这些子线程负责读取客户端的请求数据，并将其传递给主线程进行处理。主线程处理完请求后，子线程再负责将响应写回到客户端。</li>\n<li>命令执行：尽管引入了多线程，Redis 的命令执行仍然是单线程的。这意味着 Redis 仍然保证了数据的一致性，因为所有命令都在同一个线程中顺序执行。</li>\n</ul>\n<p>配置多线程</p>\n<p>Redis 6.0 中的多线程支持需要在 redis.conf 文件中进行配置。Redis 6 的多线程默认是禁用的，只使用主线程。可以通过设置<br>\n io-threads-do-reads 参数来启用多线程 I/O 支持，并指定子线程的数量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">io-threads 4  # 设置子线程的数量</span><br><span class=\"line\">io-threads-do-reads yes  # 启用子线程读取</span><br></pre></td></tr></table></figure>\n<p>官方建议线程数应小于机器的核数，并且给出了一个简单的指导原则：对于 4 核的机器，建议设置 2 或 3 个线程；对于 8 核的机器，建议设置<br>\n 6 个线程。线程数并不是越多越好，一般超过 8 个线程就没有太多的意义了。</p>\n<p>使用场景</p>\n<ul>\n<li>网络 I/O 密集型操作：当 Redis 实例面临大量的网络 I/O 负载时，多线程可以帮助减轻主线程的压力，提高系统的整体吞吐量。</li>\n<li>多核 CPU 利用率：在多核处理器环境下，多线程可以让 Redis 更好地利用硬件资源，特别是在处理高并发请求时。</li>\n</ul>\n<p>注意事项</p>\n<ul>\n<li>单线程命令执行：尽管 Redis 引入了多线程支持，但命令的执行仍然是单线程的。这意味着 Redis 依然保证了数据的一致性和事务的安全性。</li>\n<li>适用性：多线程功能最适合在网络 I/O 成为性能瓶颈的情况下使用。如果 Redis 实例的 CPU 占用率已经很高，那么开启多线程可能并不会带来显著的性能提升。</li>\n<li>兼容性：在 Redis 的其他模式（如集群模式）中，多线程功能可能不完全适用，因此在使用时需要谨慎。</li>\n</ul>\n<h2 id=\"redis-集群\"><a class=\"markdownIt-Anchor\" href=\"#redis-集群\">#</a> Redis 集群</h2>\n<h3 id=\"redis-主从\"><a class=\"markdownIt-Anchor\" href=\"#redis-主从\">#</a> Redis 主从</h3>\n<p>和 MySQL 需要主从复制的原因一样，Redis 虽然读取写入的速度都特别快，但是也会产生性能瓶颈，特别是在读压力上，为了分担压力，Redis 支持主从复制。<br>\nRedis 的主从结构包括一主一从，一主多从或级联结构，复制类型分为全量同步和增量同步。<br>\n下图为级联结构：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1557639147418-27b8b69d-f0a8-4ec0-a771-99c43783190d.png\" class=\"\" title=\"1557639147418-27b8b69d-f0a8-4ec0-a771-99c43783190d.png\">\n<h4 id=\"全量同步\"><a class=\"markdownIt-Anchor\" href=\"#全量同步\">#</a> 全量同步</h4>\n<p>Redis 全量复制一般发生在 slave 的初始阶段，这时 slave 需要将 master 上的数据都复制一份，具体步骤如下：</p>\n<ol>\n<li>slave 连接 master，发送 SYNC 命令；</li>\n<li>master 街道 SYNC 命令后，执行 BGSAVE 命令生产 RDB 文件并使用缓冲区记录此后执行的所有写命令；</li>\n<li>master 的 BGSAVE 执行完成后，向所有的 slave 发送快照文件，并在发送过程中继续记录执行的写命令；</li>\n<li>slave 收到快照后，丢弃所有的旧数据，载入收到的数据；</li>\n<li>master 快照发送完成后就会开始向 slave 发送缓冲区的写命令；</li>\n<li>slave 完成对快照的载入，并开始接受命令请求，执行来自 master 缓冲区的写命令；</li>\n<li>slave 完成上面的数据初始化后就可以开始接受用户的读请求了。</li>\n</ol>\n<p>大致流程图如下：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1557639652986-bfbcd0af-6688-4047-83df-8f3bea5d0875.png\" class=\"\" title=\"1557639652986-bfbcd0af-6688-4047-83df-8f3bea5d0875.png\">\n<h4 id=\"增量复制\"><a class=\"markdownIt-Anchor\" href=\"#增量复制\">#</a> 增量复制</h4>\n<p>增量复制实际上就是在 slave 初始化完成后开始正常工作时 master 发生写操作同步到 slave 的过程。增量复制的具体步骤如下：</p>\n<ol>\n<li>主节点记录复制偏移量：<br>\n在全量复制完成后，主节点开始记录其发送给从节点的所有写命令，并维护一个复制偏移量（replication<br>\noffset），这个偏移量表示了主节点已发送了多少字节的数据给从节点。</li>\n<li>从节点记录复制偏移量：<br>\n同时，从节点也会记录接收到的命令及其对应的偏移量。这使得从节点能够知道它已经处理了多少数据。</li>\n<li>主节点维护积压队列：<br>\n为了支持增量复制，主节点会维护一个 “积压队列”（backlog）。这是一个固定大小的环形缓冲区，用来存储最近的写入命令。这样即使从节点暂时断开连接，也能在重新连接后获取到断开期间丢失的数据。</li>\n<li>从节点请求增量数据：<br>\n当从节点重新连接到主节点时，它会发送一个 PSYNC 命令，附带它最后已知的复制偏移量和主节点的运行 ID（run<br>\nID）。主节点会检查这个信息，并决定是否进行增量复制。</li>\n<li>增量复制：\n<ul>\n<li>如果主节点发现从节点提供的偏移量在积压队列的有效范围内，则主节点会从该偏移量开始向从节点发送所有后续的写命令，这就是增量复制。</li>\n<li>如果偏移量不在有效范围内，或者从节点提供的运行 ID 与主节点当前的运行 ID 不符（可能是因为主节点重启过），那么主节点会选择进行一次全量复制。</li>\n</ul>\n</li>\n<li>从节点应用增量数据：<br>\n从节点接收到增量数据后，会将其应用到自己的数据集上，使自己的数据与主节点保持一致。</li>\n</ol>\n<p>Redis 主从同步的特点</p>\n<ol>\n<li>采用异步复制；</li>\n<li>可以一主多从；</li>\n<li>主从复制对于 master 来说是非阻塞的，也就是说 slave 在进行主从复制的过程中，master 依然可以处理请求；</li>\n<li>主从复制对于 slave 来说也是非阻塞的，也就是说 slave 在进行主从复制的过程中也可以接受外界的查询请求，只不过这时候返回的数据不一定是正确的。为了避免这种情况发生，可以在 slave 的配置文件中配置，在同步过程中阻止查询；</li>\n<li>每个 slave 可以接受来自其他 slave 的连接；</li>\n<li>主从复制提高了 Redis 服务的扩展性，避免单节点问题，另外也为数据备份冗余提供了一种解决方案；</li>\n</ol>\n<p>为了降低主 redis 服务器写磁盘压力带来的开销，可以配置让主 redis 不在将数据持久化到磁盘，而是通过连接让一个配置的从 redis 服务器及时的将相关数据持久化到磁盘，不过这样会存在一个问题，就是主 redis 服务器一旦重启，因为主 redis 服务器数据为空，这时候通过主从同步可能导致从 redis 服务器上的数据也被清空；</p>\n<h4 id=\"redis主从复制搭建\"><a class=\"markdownIt-Anchor\" href=\"#redis主从复制搭建\">#</a> Redis 主从复制搭建</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">下载软件包</span></span><br><span class=\"line\">wget http://download.redis.io/releases/redis-4.0.10.tar.gz</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">解压软件包，主从都需要做（本次是单机多实例来做主从）</span></span><br><span class=\"line\">tar xf redis-4.0.10.tar.gz -C /home/redis/6379/</span><br><span class=\"line\">tar xf redis-4.0.10.tar.gz -C /home/redis/6380/</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">编译安装</span></span><br><span class=\"line\">yum install -y gcc gcc++</span><br><span class=\"line\">make MALLOC=libc</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">启动Redis（修改了Redis运行方式为守护进程方式）</span></span><br><span class=\"line\">/home/redis/6379/redis-4.0.10/src/redis-server /home/redis/6379/redis-4.0.10/redis.conf</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">从库做相同的操作，由于是单机多实例，所以修改从库的port为6380，启动从库</span></span><br><span class=\"line\">/home/redis/6380/redis-4.0.10/src/redis-server /home/redis/6380/redis-4.0.10/redis.conf</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">Redis测试</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">master：</span></span><br><span class=\"line\">./src/redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; set name 111</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get name</span><br><span class=\"line\">&quot;111&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">slave：</span></span><br><span class=\"line\">./src/redis-cli -p 6380</span><br><span class=\"line\">127.0.0.1:6380&gt; set name slave</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6380&gt; get name</span><br><span class=\"line\">&quot;slave&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">主从搭建</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">1、只需要配置slave，指明master的IP地址和port就可以了，配置完后重启实例</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">slaveof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class=\"line\">slaveof 127.0.0.1 6379</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">测试：</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">master：</span></span><br><span class=\"line\">./src/redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; set password 123456</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get password</span><br><span class=\"line\">&quot;123456&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">slave：</span></span><br><span class=\"line\">./src/redis-cli -p 6380</span><br><span class=\"line\">127.0.0.1:6380&gt; get password</span><br><span class=\"line\">&quot;123456&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">在master上设定键值对，在slave上能够准确的查出来，主从配置成功</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"redis-哨兵\"><a class=\"markdownIt-Anchor\" href=\"#redis-哨兵\">#</a> Redis 哨兵</h3>\n<p>在主从复制实现之后，如果想对 master 进行监控，Redis 提供了一种哨兵机制，哨兵的含义就是监控 Redis 系统的运行状态，并做相应的响应。</p>\n<p>其主要的功能有以下两点：</p>\n<ol>\n<li>监控所有 Redis 节点是否正常运行；</li>\n<li>master 故障后可以通过投票机制，从 slave 中选举出新的 master，保证集群正常运行。</li>\n</ol>\n<p>在一个一主多从的集群中，可以启用多个哨兵进行监控以保证集群足够稳健，这种情况下，哨兵不仅监控主从服务，哨兵之间也会相互监控，建议哨兵至少 3 个并且是奇数。</p>\n<p>哨兵主要用于管理多个 Redis 服务器，主要有以下三个任务：</p>\n<ol>\n<li>监控：哨兵会不断的检测 master 和 slave 之间是否运行正常；</li>\n<li>提醒：当监控的某个 Redis 出现问题，哨兵可以通过 API 向管理员或其他应用程序发送通知；</li>\n<li>故障迁移：当一个 master 不能正常工作时，哨兵会开始一次自动故障迁移操作，它会将失效 master 的其中一个 slave 提升为 master，并让失效 master 和其他 slave 该为复制新的 master。<br>\n当客户端试图连接失效的 master 时，集群也会向客户端返回新的 master 地址，使得集群可以使用新的 master 代替失效的 master。</li>\n</ol>\n<h4 id=\"redis-哨兵的工作原理\"><a class=\"markdownIt-Anchor\" href=\"#redis-哨兵的工作原理\">#</a> Redis 哨兵的工作原理</h4>\n<p>Redis 哨兵（Sentinel）是一个分布式系统，用于监控 Redis 主节点和从节点的健康状况，并在主节点发生故障时自动进行故障转移。<br>\n哨兵系统由一组哨兵进程组成，它们相互协作来完成监控、通知、选举以及故障转移的任务。下面详细介绍哨兵的工作原理：</p>\n<ol>\n<li>监控（Monitoring）\n<ul>\n<li>心跳检测：每个哨兵（Sentinel）会定期向主节点、从节点以及其他哨兵发送心跳消息，以此来监控这些节点的健康状况。</li>\n<li>配置文件：哨兵的配置文件中定义了需要监控的主节点的信息，包括名称、IP 地址和端口号等。</li>\n</ul>\n</li>\n<li>选举（Election）\n<ul>\n<li>选举机制：当某个哨兵发现主节点不可用时，它会向其他哨兵发起询问，以确认主节点是否真的出现了故障。</li>\n<li>投票过程：每个哨兵都有机会投票选出一个领导者（leader），领导者负责执行实际的故障转移操作。</li>\n<li>多数原则：为了防止脑裂现象（Split-brain 指的是系统的一部分节点认为另一部分节点已经失败，而实际上那些被认为失败的节点仍在正常工作。），哨兵系统采用多数原则来决定是否进行故障转移。<br>\n只有当超过半数的哨兵同意主节点已经失效时，才会执行故障转移。</li>\n</ul>\n</li>\n<li>故障转移（Failover）\n<ul>\n<li>选择从节点：一旦确定主节点失效，领导者哨兵会选择一个合适的从节点来升级为主节点。</li>\n<li>数据同步：被选中的从节点会被提升为主节点，并且其他从节点会重新连接到新的主节点。</li>\n<li>客户端通知：完成故障转移后，哨兵会更新客户端的配置文件，使客户端能够连接到新的主节点。</li>\n</ul>\n</li>\n<li>配置更新（Configuration Updates）\n<ul>\n<li>自动配置更新：哨引不仅会更新客户端的配置文件，还会自动更新从节点的配置，使它们指向新的主节点。</li>\n<li>持续监控：故障转移完成后，哨兵将继续监控新的主节点和从节点的健康状况。</li>\n</ul>\n</li>\n<li>客户端通知\n<ul>\n<li>通知机制：哨兵会通知客户端新的主节点地址，以便客户端可以继续正常工作。</li>\n<li>透明切换：这一过程对客户端来说应该是透明的，即客户端不需要做任何额外的操作即可继续访问 Redis 服务。</li>\n</ul>\n</li>\n</ol>\n<p>实现细节如下：</p>\n<ul>\n<li>哨兵通信：哨兵之间通过发布 / 订阅模式进行通信，确保所有哨兵都能及时了解系统状态的变化。</li>\n<li>命令交互：哨兵使用特定的命令（如 SENTINEL 命令）来查询和管理哨兵系统。</li>\n</ul>\n<p>缺点</p>\n<ul>\n<li>主从服务器的数据要经常进行主从复制，这样会造成性能下降；</li>\n<li>当主服务器宕机后，从服务器切换成主服务器的那段时间，服务是不可用的。</li>\n</ul>\n<h4 id=\"redis哨兵模式搭建\"><a class=\"markdownIt-Anchor\" href=\"#redis哨兵模式搭建\">#</a> Redis 哨兵模式搭建</h4>\n<p>主从模式搭建看上面的步骤，以下主要是在主从搭建完的基础上搭建哨兵模式。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">配置sentinel.conf文件</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">工作路径，注意路径不要和主重复</span></span><br><span class=\"line\">dir &quot;/tmp/23679&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">哨兵监控的master，主从配置一样，这里只用输入redis主节点的ip/port和法定人数。</span></span><br><span class=\"line\">sentinel monitor mymaster 192.168.125.128 6379 1</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">master或slave多长时间（默认30秒）不能使用后标记为s_down状态。</span></span><br><span class=\"line\">sentinel down-after-milliseconds mymaster 5000</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">若sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换），则认为本次failover失败。</span></span><br><span class=\"line\">sentinel failover-timeout mymaster 18000</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步，有几个slave就设置几个</span></span><br><span class=\"line\">sentinel parallel-syncs mymaster 2</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">启动哨兵</span></span><br><span class=\"line\">/home/redis/26379/redis-4.0.10/src/redis-server /home/redis/26379/redis-4.0.10/sentinel.conf --sentinel</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">通过哨兵查看集群状态</span></span><br><span class=\"line\">./src/redis-cli -p 26379</span><br><span class=\"line\">127.0.0.1:26379&gt; sentinel master mymaster</span><br><span class=\"line\">1) &quot;name&quot;</span><br><span class=\"line\">2) &quot;mymaster&quot;</span><br><span class=\"line\">3) &quot;ip&quot;</span><br><span class=\"line\">4) &quot;172.16.0.169&quot;</span><br><span class=\"line\">5) &quot;port&quot;</span><br><span class=\"line\">6) &quot;6379&quot;</span><br><span class=\"line\">7) &quot;runid&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:26379&gt; sentinel slaves mymaster</span><br><span class=\"line\">1)  1) &quot;name&quot;                                           # slave 1</span><br><span class=\"line\">    2) &quot;127.0.0.1:6381&quot;</span><br><span class=\"line\">    3) &quot;ip&quot;</span><br><span class=\"line\">    4) &quot;127.0.0.1&quot;</span><br><span class=\"line\">    5) &quot;port&quot;</span><br><span class=\"line\">    6) &quot;6381&quot;</span><br><span class=\"line\">    7) &quot;runid&quot;</span><br><span class=\"line\">    8) &quot;0419f313098f6af1b4ccdb189d6beb22edf27a1c&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">2)  1) &quot;name&quot;                                            # slave2</span><br><span class=\"line\">    2) &quot;127.0.0.1:6380&quot;</span><br><span class=\"line\">    3) &quot;ip&quot;</span><br><span class=\"line\">    4) &quot;127.0.0.1&quot;</span><br><span class=\"line\">    5) &quot;port&quot;</span><br><span class=\"line\">    6) &quot;6380&quot;</span><br><span class=\"line\">    7) &quot;runid&quot;</span><br><span class=\"line\">    8) &quot;5b00b502a93245f7916efd1f564bd40b16aa7b22&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">模拟主down掉</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">观察sentinel的状态</span></span><br><span class=\"line\">127.0.0.1:26379&gt; sentinel master mymaster</span><br><span class=\"line\">1) &quot;name&quot;</span><br><span class=\"line\">2) &quot;mymaster&quot;</span><br><span class=\"line\">3) &quot;ip&quot;</span><br><span class=\"line\">4) &quot;127.0.0.1&quot;</span><br><span class=\"line\">5) &quot;port&quot;</span><br><span class=\"line\">6) &quot;6381&quot;                # 已经从6379切换到6381</span><br><span class=\"line\">7) &quot;runid&quot;</span><br><span class=\"line\">8) &quot;0419f313098f6af1b4ccdb189d6beb22edf27a1c&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">相应的slave也做了切换</span></span><br><span class=\"line\">127.0.0.1:26379&gt; sentinel slaves mymaster</span><br><span class=\"line\">1)  1) &quot;name&quot;</span><br><span class=\"line\">    2) &quot;127.0.0.1:6379&quot;</span><br><span class=\"line\">    3) &quot;ip&quot;</span><br><span class=\"line\">    4) &quot;127.0.0.1&quot;</span><br><span class=\"line\">    5) &quot;port&quot;</span><br><span class=\"line\">    6) &quot;6379&quot;</span><br><span class=\"line\">    7) &quot;runid&quot;</span><br><span class=\"line\">    8) &quot;&quot;</span><br><span class=\"line\">    9) &quot;flags&quot;</span><br><span class=\"line\">   10) &quot;s_down,slave,disconnected&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">2)  1) &quot;name&quot;</span><br><span class=\"line\">    2) &quot;127.0.0.1:6380&quot;</span><br><span class=\"line\">    3) &quot;ip&quot;</span><br><span class=\"line\">    4) &quot;127.0.0.1&quot;</span><br><span class=\"line\">    5) &quot;port&quot;</span><br><span class=\"line\">    6) &quot;6380&quot;</span><br><span class=\"line\">    7) &quot;runid&quot;</span><br><span class=\"line\">    8) &quot;5b00b502a93245f7916efd1f564bd40b16aa7b22&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"redis集群\"><a class=\"markdownIt-Anchor\" href=\"#redis集群\">#</a> Redis 集群</h3>\n<p>Redis 在 3.0 版本开始正式引入集群特性。Redis 集群是一个分布式，高容错的内存 K/V 系统，集群可以使用的功能是普通单机 Redis 所使用的功能的一个子集。比如，Redis 集群并不支持处理多个 keys 的命令，因为这需要在不同节点间移动数据，从而达不到像 Redis 那样的性能，在高负载的情况下可能会出现无法预估的错误。</p>\n<p>Redis 集群有以下几个重要的特征：</p>\n<ol>\n<li>Redis 集群的分片特征在于将空间拆分为 16384 个槽位，某一个节点负责其中一些槽位；</li>\n<li>Redis 集群提供一定程度的可用性，可以在某个节点宕机或者不可达的情况继续处理命令；</li>\n<li>Redis 集群不存在中心节点或代理节点，集群的其中一个最重要的设计目标是达到线性可扩展性；</li>\n</ol>\n<p>其架构如下：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1557644289413-437c9a81-dcb1-40bc-8549-2a4867b797c2.png\" class=\"\" title=\"1557644289413-437c9a81-dcb1-40bc-8549-2a4867b797c2.png\">\n<p>其中每一个圆代表一个节点，任何两个节点是互通的，可以归纳以下几点：</p>\n<ul>\n<li>所有的节点相互连接；</li>\n<li>集群消息通信通过集群总线通信，，集群总线端口大小为客户端服务端口 + 10000，这个 10000 是固定值；</li>\n<li>节点与节点之间通过二进制协议进行通信；</li>\n<li>客户端和集群节点之间通信和通常一样，通过文本协议进行；</li>\n<li>集群节点不会代理查询；</li>\n</ul>\n<h4 id=\"redis集群的原理\"><a class=\"markdownIt-Anchor\" href=\"#redis集群的原理\">#</a> Redis 集群的原理</h4>\n<p>Redis 集群是一种分布式存储解决方案，旨在通过数据分片和复制来实现高可用性和可扩展性。以下是 Redis 集群的详细运行原理：</p>\n<ol>\n<li>\n<p>哈希槽（Hash Slots）<br>\nRedis 集群中有一个长度为 16384 的哈希槽列表，编号为 0 到 16383。这些哈希槽是虚拟的，并不是真实存在的物理实体。</p>\n<ul>\n<li>哈希计算：当一个键（Key）被存储时，Redis 会计算该键的哈希值，并将哈希值映射到 0 到 16383 之间的某个哈希槽上。<br>\n具体映射公式为：slot = CRC16 (key) mod 16384，其中 CRC16 是一个循环冗余校验算法。</li>\n</ul>\n</li>\n<li>\n<p>数据分片</p>\n<ul>\n<li>槽分配：集群中的每个 Master 节点负责一部分哈希槽。例如，如果集群中有 3 个 Master 节点，它们可能会分别负责以下槽范围：\n<ul>\n<li>Master 1: 槽 0-5461</li>\n<li>Master 2: 槽 5462-10923</li>\n<li>Master 3: 槽 10924-16383</li>\n</ul>\n</li>\n<li>键的分配：每个键根据其哈希值被分配到相应的槽上，进而确定存储在哪个 Master 节点上。</li>\n</ul>\n<p>这里值得一提的是，在 Redis Cluster 中，只有 Master 才拥有槽的所有权。如果是某个 Master 的 slave，这个 slave 只负责槽的使用，但是没有所有权。<br>\n槽与节点结构如下所示：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1557644627263-0159f2b0-f9ff-46d6-acd3-abc6a22d8e87.png\" class=\"\" title=\"1557644627263-0159f2b0-f9ff-46d6-acd3-abc6a22d8e87.png\">\n</li>\n<li>\n<p>主从复制</p>\n<ul>\n<li>主节点（Master）：每个 Master 节点负责处理写操作，并拥有槽的所有权。</li>\n<li>从节点（Slave）：每个 Master 节点可以有多个从节点，从节点负责处理读操作，并作为 Master 节点的备份。</li>\n<li>数据同步：从节点通过复制机制与 Master 节点保持数据一致。</li>\n</ul>\n</li>\n<li>\n<p>故障转移</p>\n<ul>\n<li>自动故障转移：当一个 Master 节点失效时，集群会自动选择一个从节点提升为主节点，以保持集群的服务可用性。</li>\n<li>选举机制：集群中的其他节点会通过 Gossip 协议来协商并选举一个新的 Master 节点。</li>\n</ul>\n</li>\n<li>\n<p>集群间的通信</p>\n<ul>\n<li>Gossip 协议：Redis 集群使用 Gossip 协议来交换节点状态信息。每个节点周期性地与其他节点交换信息，以了解集群中其他节点的状态。</li>\n<li>状态同步：通过 Gossip 协议，节点可以得知集群中的其他节点是否在线、是否有新的节点加入等信息。</li>\n</ul>\n</li>\n<li>\n<p>命令路由</p>\n<ul>\n<li>客户端路由：客户端可以连接到任何一个节点，集群内部会根据键的哈希值来确定该键所在的节点，并将请求路由到正确的节点。</li>\n<li>命令转发：如果客户端请求的键不在当前节点上，那么该节点会将请求转发到正确的节点上。</li>\n</ul>\n</li>\n<li>\n<p>初始化与配置</p>\n<ul>\n<li>初始化脚本：使用 redis-trib.rb 脚本来初始化集群。该脚本会自动分配槽到各个 Master 节点，并配置从节点。</li>\n<li>配置文件：每个节点的配置文件中需要指定集群模式和其他相关参数。</li>\n</ul>\n</li>\n<li>\n<p>投票机制</p>\n<ul>\n<li>投票过程：集群中所有 Master 节点参与投票。如果超过半数的 Master 节点与某个 Master 节点通信超时（cluster-node-timeout），则认为该<br>\n Master 节点已挂掉。</li>\n<li>集群不可用状态：\n<ul>\n<li>单个 Master 挂掉：如果某个 Master 节点挂掉，并且没有从节点，集群进入 fail 状态。</li>\n<li>多数 Master 挂掉：如果超过半数的 Master 节点挂掉，无论是否有从节点，集群也进入 fail 状态。</li>\n</ul>\n</li>\n</ul>\n<p>投票机制原理图如下：</p>\n<img data-src=\"/joker.github.io/2024/09/13/%E3%80%90Redis%E3%80%91Redis%E8%AF%A6%E8%A7%A3/1557645005629-3f876a67-45ec-4285-8821-3ebf42dd4345.png\" class=\"\" title=\"1557645005629-3f876a67-45ec-4285-8821-3ebf42dd4345.png\">\n</li>\n</ol>\n<h4 id=\"redis集群搭建\"><a class=\"markdownIt-Anchor\" href=\"#redis集群搭建\">#</a> Redis 集群搭建</h4>\n<p>要求：至少 6 个节点，3 主 3 从。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">Redis.conf配置：大致如下</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">port 7000</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">cluster-enabled <span class=\"built_in\">yes</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">cluster-config-file nodes.conf</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">cluster-node-timeout 5000</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">appendonly <span class=\"built_in\">yes</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">创建集群</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">redis集群的命令工具redis-trib可以让我们创建集群变得非常简单。</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">redis-trib是一个用ruby写的脚本，用于给各节点发指令创建集群、检查集群状态或给集群重新分片等。</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">redis-trib在Redis源码的src目录下，需要gem redis来运行redis-trib。</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">安装ruby环境</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">yum install rubygems -y</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">1.安装curl</span></span><br><span class=\"line\">sudo yum install curl</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">2. 安装RVM</span></span><br><span class=\"line\">curl -L get.rvm.io | bash -s stable </span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">3.</span> </span><br><span class=\"line\">source /usr/local/rvm/scripts/rvm</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">4. 查看rvm库中已知的ruby版本</span></span><br><span class=\"line\">rvm list known</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">5. 安装一个ruby版本</span></span><br><span class=\"line\">rvm install 2.3.3</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">6. 使用一个ruby版本</span></span><br><span class=\"line\">rvm use 2.3.3</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">7. 设置默认版本</span></span><br><span class=\"line\">rvm remove 2.0.0</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">8. 卸载一个已知版本</span></span><br><span class=\"line\">ruby --version</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">9. 再安装redis就可以了</span></span><br><span class=\"line\">gem install redis</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">启动集群</span></span><br><span class=\"line\">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">测试集群</span></span><br><span class=\"line\">7000/redis-4.0.10/src/redis-cli -c -p 7000</span><br><span class=\"line\">127.0.0.1:7000&gt; set name alex</span><br><span class=\"line\"><span class=\"meta prompt_\">-&gt; </span><span class=\"language-bash\">Redirected to slot [5798] located at 127.0.0.1:7001</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:7001&gt; get name</span><br><span class=\"line\">&quot;alex&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"redis集群迁移\"><a class=\"markdownIt-Anchor\" href=\"#redis集群迁移\">#</a> Redis 集群迁移</h4>\n<p>Redis 集群迁移是指将现有的 Redis 集群中的数据移动到另一个集群或新的硬件环境中的过程。<br>\n这种迁移可能是因为需要扩大容量、更换硬件、迁移至新的数据中心或云平台等原因。迁移过程中需要考虑数据的一致性、服务的连续性以及最小化对现有业务的影响。<br>\n迁移方法</p>\n<ol>\n<li>\n<p>使用 RDB 或 AOF 文件进行离线迁移</p>\n<ul>\n<li>RDB 方式：停止集群服务，执行 bgsave 命令生成 RDB 快照文件，然后将 RDB 文件复制到新的集群中，并重启服务。</li>\n<li>AOF 方式：暂停写服务，将 AOF 文件导出到新的 Redis 集群中完成数据迁移。<br>\n这种方式简单直接，但会导致服务中断一段时间，并且适用于数据量不大或能接受短暂服务中断的情况。</li>\n</ul>\n</li>\n<li>\n<p>使用 Redis-Shake 进行在线迁移</p>\n<ul>\n<li>Redis-Shake：这是一个开源工具，专为在线迁移设计，可以在不停止服务的情况下迁移数据。<br>\nRedis-Shake 支持多种迁移场景，包括 Redis 集群之间的数据迁移。</li>\n<li>实时迁移：在迁移过程中，Redis-Shake 会持续同步源集群和目标集群之间的数据变化，以保证数据的一致性。</li>\n</ul>\n<p>这种方式可以减少服务中断的时间，适合于数据量大且要求服务连续性的场景。</p>\n</li>\n<li>\n<p>利用 Sentinel 或其他工具进行故障转移式迁移</p>\n<ul>\n<li>利用 Sentinel：如果当前集群启用了 Sentinel，可以先将数据复制到新集群中，然后通过 Sentinel 触发故障转移，将流量逐渐转移到新集群。</li>\n<li>逐步迁移：这种方式可以在不影响现有服务的情况下，逐步将数据和服务转移到新的集群中。</li>\n</ul>\n<p>这种方式适合于已经有 Sentinel 架构的场景，并且可以灵活控制迁移的节奏。</p>\n</li>\n</ol>\n<p>迁移步骤</p>\n<ol>\n<li>准备阶段\n<ol>\n<li>评估迁移需求：明确迁移的目的地、迁移的规模、时间窗口等。</li>\n<li>备份现有集群：在迁移前对现有集群进行全量备份，以防迁移失败需要回滚。</li>\n<li>准备新集群：搭建新集群环境，包括硬件准备、软件安装、网络配置等。</li>\n</ol>\n</li>\n<li>执行阶段\n<ol>\n<li>\n<p>数据同步：根据选择的方法，开始数据同步或迁移。</p>\n<ul>\n<li>如果使用 Redis-Shake，启动迁移工具并配置源集群和目标集群的信息。</li>\n<li>如果使用 RDB 或 AOF，执行必要的命令生成快照文件，并将其导入到新集群。</li>\n</ul>\n</li>\n<li>\n<p>验证数据一致性：在迁移完成后，检查新集群的数据完整性，确保没有数据丢失或损坏。</p>\n</li>\n<li>\n<p>切换流量：当数据迁移完成并且验证无误后，开始将客户端流量切换到新集群。</p>\n</li>\n</ol>\n</li>\n<li>后期阶段\n<ol>\n<li>监控与优化：迁移完成后，持续监控新集群的性能指标，确保一切正常。</li>\n<li>清理旧集群：如果不再需要旧集群，可以安全地卸载或关闭旧集群的相关资源。</li>\n</ol>\n</li>\n</ol>\n<p>注意事项</p>\n<ul>\n<li>迁移窗口：尽量选择业务低谷时段进行迁移，以减少对业务的影响。</li>\n<li>数据一致性：确保在整个迁移过程中数据的一致性，尤其是在实时迁移过程中。</li>\n<li>测试验证：在正式迁移之前，最好在一个测试环境中模拟迁移过程，确保迁移脚本和工具的正确性。</li>\n<li>回滚计划：准备好回滚计划，以便在迁移过程中出现问题时能够迅速恢复到迁移前的状态。</li>\n</ul>\n<h2 id=\"常见面试问题\"><a class=\"markdownIt-Anchor\" href=\"#常见面试问题\">#</a> 常见面试问题</h2>\n<h3 id=\"redis-为何这么快\"><a class=\"markdownIt-Anchor\" href=\"#redis-为何这么快\">#</a> Redis 为何这么快</h3>\n<ul>\n<li>内存存储：Redis 将所有数据存储在内存中，而不是磁盘上。内存的读写速度远超磁盘，这使得 Redis 能够实现极低的延迟和高吞吐量。内存中的数据访问速度几乎是瞬时的，而磁盘则需要等待机械臂移动到正确的位置才能开始读写，这大大降低了速度。</li>\n<li>高效的数据结构：Redis 提供了多种高效的数据结构，如跳跃表（skiplist）用于实现有序集合（Sorted<br>\nSet），压缩列表（ziplist）用于节省空间，哈希表（hashtable）用于实现散列（Hash）等。这些数据结构经过优化，能够在内存中高效地存储和检索数据。</li>\n<li>合理的数据编码：Redis 根据数据的不同类型和大小，使用不同的编码格式来存储数据。例如，短字符串可能会使用更为紧凑的编码方式，从而减少内存占用并加快处理速度。</li>\n<li>单线程模型：Redis 采用单线程模型来处理客户端的所有请求。这意味着在任何给定的时间内，只有一个客户端请求正在被执行。虽然这限制了并发处理能力，但也消除了多线程之间上下文切换和锁的竞争，从而减少了不必要的开销。</li>\n<li>非阻塞 I/O：Redis 使用事件驱动模型来处理客户端连接和请求。它使用了类似于 epoll 的 I/O 多路复用技术来监听多个客户端连接上的事件，<br>\n当有事件发生时（例如，客户端发送了一个命令），Redis 会立即处理这个事件。这种方式使得 Redis 可以同时处理大量的客户端连接，而不会因为一个客户端的阻塞而影响其他客户端的响应速度。</li>\n<li>异步持久化：为了防止持久化操作影响 Redis 的性能，Redis 提供了异步持久化选项。例如，RDB 快照和 AOF 日志都可以在后台进程执行，不会阻塞主线程处理客户端请求。</li>\n<li>线程分离：Redis 6.0 引入了多线程处理部分 I/O 密集型任务，如 AOF 重写和 RDB 持久化，这样可以进一步提高 Redis 的性能，因为这些任务不再完全阻塞单一线程。</li>\n</ul>\n<h3 id=\"redis为何使用单线程\"><a class=\"markdownIt-Anchor\" href=\"#redis为何使用单线程\">#</a> Redis 为何使用单线程</h3>\n<p>Redis 选择单线程模型的原因有以下几个方面：</p>\n<ul>\n<li>内存操作速度快：Redis 的所有数据都存储在内存中，内存的读写速度非常快。因此，对于基于内存的操作而言，CPU 并不是性能瓶颈。如果使用多线程，反而需要解决多线程同步的问题，这可能会增加额外的 CPU 负担。</li>\n<li>数据结构简单：Redis 中的数据结构相对简单，操作也较为迅速，这使得单线程就能够高效地处理大量的客户端请求。</li>\n<li>非阻塞 I/O 模型：Redis 使用了非阻塞的 I/O 模型，即多路复用 I/O 机制（如 epoll、select 等）。<br>\n这种机制使得单线程可以同时监听多个客户端连接的请求，并在有请求到达时异步地处理这些请求，从而有效地利用了单线程的能力来处理高并发连接。</li>\n<li>简化设计：单线程模型简化了 Redis 的设计和实现。由于不存在多线程间的竞争和同步问题，Redis 的代码更加简洁易懂，同时也减少了潜在的 bug。</li>\n<li>避免上下文切换开销：多线程模型会导致频繁的上下文切换，这会消耗大量的 CPU 资源。单线程模型避免了这种开销，使得 Redis 可以更加高效地使用 CPU 资源。</li>\n<li>易于实现高一致性：单线程模型下，数据的一致性更容易保证，因为不存在多线程并发修改同一份数据的问题。</li>\n<li>避免锁的竞争：在多线程环境下，为了避免数据冲突，通常需要使用锁机制。而锁的竞争会导致一部分线程处于等待状态，从而降低了系统的整体吞吐量。单线程模型避免了这种锁的竞争。</li>\n</ul>\n<p>然而，单线程模型也有其局限性。例如，对于 CPU 密集型的任务，单线程模型可能不是最佳选择，因为这样的任务会阻塞主线程，影响 Redis 处理其他请求的能力。为了解决这个问题，Redis 在后来的版本中引入了多线程来处理 I/O 密集型任务，如 AOF 重写和 RDB 持久化，以此来提升性能。</p>\n<h3 id=\"缓存三大问题以及解决方案\"><a class=\"markdownIt-Anchor\" href=\"#缓存三大问题以及解决方案\">#</a> 缓存三大问题以及解决方案？</h3>\n<ol>\n<li>\n<p>缓存击穿：指的是当某个 key 非常热点，在并发访问量大的情况下，如果这个 key 恰好在这个时刻失效了，那么所有请求都会落到数据库上，造成数据库瞬间压力过大。</p>\n<p>解决方案：</p>\n<ul>\n<li>设置热点数据永不过期：对于热点数据，可以将其设置为永不过期，或者设置一个较长的过期时间。\n<ul>\n<li>优点：\n<ol>\n<li>减少了因缓存失效导致的数据库压力。</li>\n<li>简单易实施。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>可能会导致缓存中的数据长时间不更新，影响数据的新鲜度。</li>\n<li>如果数据量很大，可能会占用较多的内存资源。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>数据更新频率较低，且数据新鲜度要求不高的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>互斥锁：使用互斥锁（Mutex）机制来控制缓存更新的过程。当缓存失效时，先获取锁，然后检查数据库中是否有数据，如果有则更新缓存，最后释放锁。\n<ul>\n<li>优点：\n<ol>\n<li>可以确保在缓存失效时，只有一部分请求会真正落到数据库上，减少了数据库的压力。</li>\n<li>数据更新及时。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>锁的使用会增加系统的复杂性。</li>\n<li>如果并发量极高，可能会出现锁竞争激烈的情况。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>数据更新频繁，且数据新鲜度要求较高的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>懒加载：当缓存失效后，可以先返回旧数据或占位符，然后异步加载最新数据并更新缓存。\n<ul>\n<li>优点：\n<ol>\n<li>用户体验较好，不会立即感知到数据陈旧。</li>\n<li>减少了数据库的瞬时压力。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>数据更新可能有延迟。</li>\n<li>实现复杂度较高。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>数据更新频率适中，对用户体验有一定要求的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>缓存穿透：是指查询一个一定不存在的数据，这个数据在缓存中不存在，同时在数据库中也不存在，每次请求都会直接穿透缓存去查询数据库，造成数据库压力巨大。</p>\n<p>解决方案：</p>\n<ul>\n<li>设置空值缓存：当查询到数据库中不存在的数据时，可以将这个查询结果（通常是 null 或特殊标识）缓存起来，设置一定的过期时间。\n<ul>\n<li>优点：\n<ol>\n<li>直接解决了缓存穿透问题，减少了对数据库的无效请求。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>如果恶意攻击者利用不存在的 key 频繁请求，可能会导致缓存中存储大量无效数据。</li>\n<li>需要合理设置过期时间，避免长期占用缓存空间。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于存在大量无效查询请求的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>布隆过滤器（Bloom Filter）：使用布隆过滤器来判断数据是否存在，可以有效地拦截那些一定不存在的数据查询。\n<ul>\n<li>优点：\n<ol>\n<li>有效拦截不存在的数据查询，减少无效请求。</li>\n<li>占用空间小，查询速度快。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>存在一定的误判率，即可能存在少量的假阳性（False Positive）。</li>\n<li>需要合理设计布隆过滤器的容量和哈希函数数量。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于数据量大且对数据精确性有一定容忍度的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>API 层面的验证：在业务逻辑层面增加对输入数据的校验，提前过滤掉非法或无效的查询请求。\n<ul>\n<li>优点：\n<ol>\n<li>从源头上过滤掉非法请求，减轻后续处理层的压力。</li>\n<li>提升系统的安全性。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>需要在业务逻辑中增加额外的验证步骤，增加了开发工作量。</li>\n<li>可能需要维护一份合法 key 的列表或规则。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于存在非法请求可能性的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>缓存雪崩：是指当缓存中的数据集中过期，导致大量请求同时穿透缓存去查询数据库，造成数据库压力剧增甚至崩溃。</p>\n<p>解决方案：</p>\n<ul>\n<li>分散缓存过期时间：避免大量数据同时过期，可以通过随机化设置过期时间来分散数据的过期时间。\n<ul>\n<li>优点：\n<ol>\n<li>有效避免了大量数据同时过期的情况，降低了数据库的压力。</li>\n<li>实现简单。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>需要合理设置随机过期时间，以确保数据分布均匀。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于数据量较大且有过期时间一致性的风险的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>限流降级：在缓存失效前，通过限流算法来控制请求的流量，一旦超过阈值则进行降级处理，返回默认值或缓存中的旧数据。\n<ul>\n<li>优点：\n<ol>\n<li>通过限流机制保护了后端系统，避免了突发流量的影响。</li>\n<li>可以根据实际情况调整限流策略。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>需要设计合理的降级策略，以确保用户体验不受太大影响。</li>\n<li>实现复杂度较高。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于流量波动较大的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>备用缓存：准备一个备用缓存系统，当主缓存系统出现故障或过载时，可以切换到备用缓存继续服务。\n<ul>\n<li>优点：\n<ol>\n<li>提供了冗余保障，增强了系统的可用性。</li>\n<li>可以平滑地切换到备用系统，减少服务中断时间。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>需要维护两套缓存系统，增加了运维成本。</li>\n<li>切换逻辑需要考虑数据同步问题。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于对系统可用性要求较高的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>异步更新：当缓存失效时，可以先返回旧数据或占位符，然后异步加载最新数据并更新缓存。\n<ul>\n<li>优点：\n<ol>\n<li>用户体验较好，不会立即感知到数据陈旧。</li>\n<li>减少了数据库的瞬时压力。</li>\n</ol>\n</li>\n<li>缺点：\n<ol>\n<li>数据更新可能有延迟。</li>\n<li>实现复杂度较高。</li>\n</ol>\n</li>\n<li>适用场景：\n<ol>\n<li>适用于数据更新频率适中，对用户体验有一定要求的场景。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"如何保证数据库和redis缓存一致性\"><a class=\"markdownIt-Anchor\" href=\"#如何保证数据库和redis缓存一致性\">#</a> 如何保证数据库和 Redis 缓存一致性？</h3>\n<ol>\n<li>\n<p>最终一致性（Eventual Consistency）</p>\n<p>在分布式系统中，通常追求的是最终一致性而非强一致性。最终一致性意味着在一段时间后，所有数据副本将收敛到同一个状态。对于缓存和数据库来说，这意味着在数据更新后，缓存最终会反映数据库中的最新状态。</p>\n</li>\n<li>\n<p>双写策略</p>\n<ol>\n<li>\n<p>先更新数据库，再删除缓存（Update Database First, Invalidate Cache）</p>\n<p>原理：当数据发生变化时，首先更新数据库中的数据，然后再删除缓存中的对应条目。当下次请求该数据时，由于缓存中没有该数据，所以会重新从数据库中读取并更新缓存。</p>\n<ul>\n<li>优点：\n<ul>\n<li>简单易实现。</li>\n<li>可以避免数据不一致的问题。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>如果删除缓存失败，则可能导致缓存中的数据比数据库中的数据旧。</li>\n<li>删除缓存操作可能会失败，需要有重试机制。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>更新操作较少，且对数据一致性要求较高的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>先删除缓存，再更新数据库（Invalidate Cache First, Update Database）</p>\n<p>原理：当数据发生变化时，先删除缓存中的数据，然后再更新数据库中的数据。</p>\n<ul>\n<li>优点：\n<ul>\n<li>可以避免缓存击穿问题。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>如果更新数据库失败，而缓存已经被删除，那么这段时间内将无法从缓存中获取数据，导致请求直接访问数据库，增加数据库压力。</li>\n<li>如果删除缓存和更新数据库之间有延迟，可能会导致短暂的数据不一致。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>更新操作频繁，但对数据一致性要求稍低的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>延迟双删策略（Double Eviction with Delay）</p>\n<p>原理：当数据更新时，先删除缓存中的数据，然后立即设置一个临时缓存项（如使用 Redis 的 EXPIRE 命令设置一个很短的过期时间），再更新数据库。当临时缓存项过期后，真正的更新操作完成。</p>\n<ul>\n<li>优点：\n<ul>\n<li>减少了直接访问数据库的概率。</li>\n<li>通过设置临时缓存项，可以减少更新数据库失败导致的数据不一致问题。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>实现相对复杂。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>高并发场景下，对数据一致性要求较高的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>使用消息队列</p>\n<p>原理：当数据在数据库中更新后，发送一个消息到消息队列中，由另一个消费者监听消息队列并更新缓存。</p>\n<ul>\n<li>优点：\n<ul>\n<li>解耦数据库和缓存更新操作。</li>\n<li>可以异步处理缓存更新，减少数据库更新时的延迟。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>增加了系统的复杂性。</li>\n<li>需要处理消息队列的可靠性和消息重复消费问题。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>高并发、大数据量的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>缓存预热</p>\n<p>原理：在系统启动或数据更新后，主动将数据加载到缓存中。</p>\n<ul>\n<li>优点：\n<ul>\n<li>避免冷启动时大量请求直接访问数据库。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>需要额外的机制来触发预热操作。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>系统启动或数据更新后，希望尽快恢复服务的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>乐观锁或版本号</p>\n<p>原理：在数据库中为数据添加一个版本号字段，每次更新时都需要检查版本号是否匹配。如果不匹配，则说明数据已被其他操作更新，需要重新获取最新数据并再次尝试更新。</p>\n<ul>\n<li>优点：\n<ul>\n<li>保证了数据的一致性。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>可能会出现更新冲突，需要重试机制。</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>对数据一致性要求极高的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"如何保证-redis-的高并发\"><a class=\"markdownIt-Anchor\" href=\"#如何保证-redis-的高并发\">#</a> 如何保证 Redis 的高并发？</h3>\n<ol>\n<li>单机优化\n<ul>\n<li>硬件优化：选择高性能的硬件设备，如 SSD 硬盘、高速网络接口卡以及足够的内存。</li>\n<li>内存管理：合理设置 Redis 的最大内存限制，避免内存溢出导致的服务不可用。</li>\n<li>持久化策略：选择合适的持久化方式（RDB 或 AOF），并调整相关的配置，以减少对性能的影响。</li>\n<li>数据结构选择：根据应用场景选择合适的数据结构，以减少内存使用并提高访问效率。</li>\n</ul>\n</li>\n<li>主从复制\n<ul>\n<li>读写分离：通过主从复制实现读写分离，主节点负责写操作，从节点负责读操作，可以显著提高并发处理能力。</li>\n<li>自动故障转移：使用 Redis Sentinel（哨兵）机制来监控主从节点的状态，并在主节点发生故障时自动进行故障转移，保证高可用性。</li>\n</ul>\n</li>\n<li>分布式集群\n<ul>\n<li>Redis Cluster：使用 Redis 集群来水平扩展 Redis，集群可以自动将数据分片存储在不同的节点上，并提供数据复制功能。这样可以支持更高的并发量和更大的数据集。</li>\n<li>数据分片：手动将数据分片存储在不同的 Redis 实例上，可以减轻单个节点的压力。</li>\n</ul>\n</li>\n<li>客户端优化\n<ul>\n<li>连接池：使用连接池来复用客户端连接，减少建立和销毁连接的开销。</li>\n<li>批处理：批量处理请求，例如使用 MGET、MSET 等命令来一次处理多个键值对，减少网络往返次数。</li>\n<li>命令管道：使用 Redis 的命令管道（pipelining）特性，将多个命令一次性发送给 Redis 服务器，减少网络延迟。</li>\n</ul>\n</li>\n<li>调整配置\n<ul>\n<li>网络配置：优化网络配置，例如调整 TCP 缓冲区大小、禁用 Nagle 算法等，以提高网络传输效率。</li>\n<li>I/O 多路复用：Redis 使用事件驱动模型来处理客户端请求，可以处理大量的并发连接。确保操作系统和 Redis 的事件处理机制配置得当。</li>\n</ul>\n</li>\n<li>监控与调优\n<ul>\n<li>性能监控：定期监控 Redis 的性能指标，如 CPU 使用率、内存使用情况、网络延迟等，以便及时发现性能瓶颈。</li>\n<li>负载均衡：使用负载均衡器来分配客户端请求，确保各个 Redis 节点的负载均衡。</li>\n</ul>\n</li>\n<li>避免热点 Key\n<ul>\n<li>Key 的设计：合理设计 Key，避免热点 Key 的产生，例如使用哈希分片（Hash Ring）来分散请求。</li>\n<li>过期时间：为热点 Key 设置合理的过期时间，并且可以使用随机化过期时间来避免雪崩效应。</li>\n</ul>\n</li>\n<li>异步处理\n<ul>\n<li>异步持久化：使用异步的方式进行持久化操作，避免阻塞主线程。</li>\n<li>多线程处理：Redis 6.0 引入了多线程模型来处理部分 I/O 密集型任务，如 AOF 重写和 RDB 持久化，可以进一步提升性能。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"redis-如何保证原子性\"><a class=\"markdownIt-Anchor\" href=\"#redis-如何保证原子性\">#</a> Redis 如何保证原子性？</h3>\n<ol>\n<li>单线程模型: Redis 采用单线程模型来处理所有的客户端请求。这意味着在同一时间内，只有一个客户端请求被处理，因此消除了并发竞争条件，保证了命令执行的顺序性和原子性。</li>\n<li>命令级别的原子性: Redis 中的大多数命令都是原子性的，这意味着它们在执行过程中不会被其他操作打断。例如，SET, GET, INCR,<br>\nDECR, HSET, HGET 等命令在执行时，整个操作过程不会被中断，从而保证了操作的完整性。</li>\n<li>事务机制: Redis 提供了事务机制，允许用户将多个命令打包成一个事务，通过 MULTI 命令开启事务，然后执行一系列命令，最后通过 EXEC 命令提交事务。<br>\n在事务中，Redis 会将这些命令放入队列中，等到事务提交时，这些命令会按照顺序依次执行，从而保证了事务内的操作的原子性。</li>\n<li>WATCH 命令: WATCH 命令可以监视一个或多个键，如果监视的键在执行 EXEC 之前被其他客户端修改了，那么事务会被取消。这实际上是一种乐观锁机制，用来保证在某些特定场景下的数据一致性。</li>\n<li>Lua 脚本: Redis 允许在服务器端执行 Lua 脚本来处理复杂的操作。Lua 脚本在执行时具有原子性，即整个脚本作为一个整体执行，期间不会被打断。<br>\n这意味着脚本中的多个 Redis 命令会被作为一个单独的操作来执行，从而保证了操作的原子性。</li>\n<li>数据结构的设计: Redis 内部的数据结构设计也是为了支持高效的原子操作。例如，对于有序集合（Sorted<br>\nSets），Redis 使用了跳跃表（Skiplist），这是一种支持快速插入、删除和查找操作的数据结构，可以高效地支持原子性操作。</li>\n</ol>\n<h2 id=\"常用命令\"><a class=\"markdownIt-Anchor\" href=\"#常用命令\">#</a> 常用命令</h2>\n<h3 id=\"cmd访问redis\"><a class=\"markdownIt-Anchor\" href=\"#cmd访问redis\">#</a> cmd 访问 redis</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli.exe -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串string相关命令\"><a class=\"markdownIt-Anchor\" href=\"#字符串string相关命令\">#</a> 字符串 (String) 相关命令</h3>\n<ul>\n<li>SET key value：设置键 key 的值为 value。</li>\n<li>GET key：获取键 key 的值。</li>\n<li>GETSET key value：设置键 key 的值为 value，并返回键 key 的旧值。</li>\n<li>INCR key：将键 key 的值加一，仅支持整数值。</li>\n<li>INCRBY key increment：将键 key 的值加上指定的增量 increment。</li>\n<li>DECR key：将键 key 的值减一。</li>\n<li>DECRBY key decrement：将键 key 的值减去指定的减量 decrement。</li>\n<li>APPEND key value：将 value 追加到键 key 的值后面。</li>\n<li>STRLEN key：返回键 key 的值的长度。</li>\n</ul>\n<h3 id=\"列表list相关命令\"><a class=\"markdownIt-Anchor\" href=\"#列表list相关命令\">#</a> 列表 (List) 相关命令</h3>\n<ul>\n<li>LPUSH key value [value …]：将一个或多个值 value 插入到键 key 的列表头部。</li>\n<li>RPUSH key value [value …]：将一个或多个值 value 插入到键 key 的列表尾部。</li>\n<li>LPOP key：移除并返回键 key 的列表的第一个元素。</li>\n<li>RPOP key：移除并返回键 key 的列表的最后一个元素。</li>\n<li>LRANGE key start stop：返回键 key 的列表中指定范围内的元素。</li>\n<li>LREM key count value：移除键 key 的列表中等于 value 的元素，count 参数决定了移除的数量。</li>\n<li>LSET key index value：将键 key 的列表中的指定位置 index 的值设为 value。</li>\n<li>LLEN key：返回键 key 的列表的长度。</li>\n</ul>\n<h3 id=\"哈希hash相关命令\"><a class=\"markdownIt-Anchor\" href=\"#哈希hash相关命令\">#</a> 哈希 (Hash) 相关命令</h3>\n<ul>\n<li>HSET key field value：将哈希表 key 中的域 field 的值设为 value。</li>\n<li>HGET key field：返回哈希表 key 中域 field 的值。</li>\n<li>HGETALL key：返回哈希表 key 中所有域的值。</li>\n<li>HDEL key field [field …]：删除一个或多个哈希表 key 中的域 field。</li>\n<li>HEXISTS key field：查看哈希表 key 中指定域 field 是否存在。</li>\n<li>HLEN key：返回哈希表 key 中域的数量。</li>\n<li>HKEYS key：返回哈希表 key 中所有域的列表。</li>\n<li>HVALS key：返回哈希表 key 中所有值的列表。</li>\n</ul>\n<h3 id=\"集合set相关命令\"><a class=\"markdownIt-Anchor\" href=\"#集合set相关命令\">#</a> 集合 (Set) 相关命令</h3>\n<ul>\n<li>SADD key member [member …]：将一个或多个成员 member 加入到集合 key 中。</li>\n<li>SMEMBERS key：返回集合 key 中的所有成员。</li>\n<li>SCARD key：返回集合 key 中的成员数。</li>\n<li>SREM key member [member …]：将一个或多个成员 member 从集合 key 中移除。</li>\n<li>SISMEMBER key member：判断成员 member 是否是集合 key 的成员。</li>\n<li>SINTER key [key …]：返回给定多个集合的交集成员。</li>\n<li>SUNION key [key …]：返回给定多个集合的并集成员。</li>\n<li>SDIFF key [key …]：返回给定多个集合的差集成员。</li>\n</ul>\n<h3 id=\"有序集合sorted-set相关命令\"><a class=\"markdownIt-Anchor\" href=\"#有序集合sorted-set相关命令\">#</a> 有序集合 (Sorted Set) 相关命令</h3>\n<ul>\n<li>ZADD key score member [score member …]：将一个或多个成员 member 及其分数 score 加入到有序集合 key 中。</li>\n<li>ZRANGE key start stop [WITHSCORES]：返回有序集合 key 中指定范围内的成员。</li>\n<li>ZREVRANGE key start stop [WITHSCORES]：返回有序集合 key 中指定范围内的成员，成员按分数值递减排列。</li>\n<li>ZREM key member [member …]：将一个或多个成员 member 从有序集合 key 中移除。</li>\n<li>ZCARD key：返回有序集合 key 中的成员数。</li>\n<li>ZSCORE key member：返回有序集合 key 中成员 member 的分数值。</li>\n<li>ZCOUNT key min max：计算在有序集合 key 中指定区间分数的成员数。</li>\n</ul>\n<h3 id=\"通用命令\"><a class=\"markdownIt-Anchor\" href=\"#通用命令\">#</a> 通用命令</h3>\n<ul>\n<li>EXPIRE key seconds：为键 key 设置生存时间。</li>\n<li>TTL key：返回键 key 剩余的生存时间。</li>\n<li>DEL key [key …]：删除一个或多个键 key。</li>\n<li>SELECT index：选择编号为 index 的数据库。</li>\n<li>FLUSHDB：清除当前数据库中的所有数据。</li>\n<li>FLUSHALL：清除所有数据库中的所有数据。</li>\n<li>KEYS pattern：返回匹配 pattern 的所有键。</li>\n<li>TYPE key：返回键 key 的类型。</li>\n</ul>\n",
            "tags": [
                "后端",
                "数据库",
                "NoSQL",
                "缓存",
                "Redis"
            ]
        },
        {
            "id": "https://silvercrow42.github.io/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/",
            "url": "https://silvercrow42.github.io/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/",
            "title": "【分布式】通过Zookeeper与Redisson实现Spring注解式分布式锁",
            "date_published": "2024-09-10T02:00:01.000Z",
            "content_html": "<p>在分布式系统中，由于服务部署在多个节点中，在运行时数据层面上天生无法互通，因此在处理多线程敏感的数据时，无法像单机应用开发一样通过 java 内部实现的多线程方案来解决。此时我们就需要通过分布式锁的方式来处理数据。</p>\n<p>本文将提供一个在 spring-cloud 基础上通过 ZooKeeper 或者 Redisson 实现的注解式的加锁方案。需要使用到 Spring<br>\nAOP，通过 ZooKeeper 加锁时需要 ZooKeeper 服务，使用 Redisson 加锁时需要使用 Redis 数据库。</p>\n<h2 id=\"依赖\"><a class=\"markdownIt-Anchor\" href=\"#依赖\">#</a> 依赖</h2>\n<p>当使用 Redisson 方式时需要引入 Redisson 依赖，版本号自行匹配替换。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/org.redisson/redisson --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.redisson<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>redisson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;redisson.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当使用 ZooKeeper 方式时需要引入连接 ZooKeeper 的依赖，版本号自行匹配替换。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-recipes --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;curator-recipes.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"配置访问锁服务的组件\"><a class=\"markdownIt-Anchor\" href=\"#配置访问锁服务的组件\">#</a> 配置访问锁服务的组件</h2>\n<h3 id=\"redisson\"><a class=\"markdownIt-Anchor\" href=\"#redisson\">#</a> Redisson</h3>\n<p>使用 redisson 作为锁服务的实现时，需要如下配置类配置 RedissonClient 组件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedissonLockConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.redis.url:redis://localhost:6379&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String redisUrl;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.redis.password:&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String redisPassword;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RedissonClient <span class=\"title function_\">redissonClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Config</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Config</span>();</span><br><span class=\"line\">        <span class=\"type\">SingleServerConfig</span> <span class=\"variable\">singleServerConfig</span> <span class=\"operator\">=</span> config.useSingleServer();</span><br><span class=\"line\">        singleServerConfig.setAddress(redisUrl);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isNotEmpty(redisPassword)) &#123;</span><br><span class=\"line\">            singleServerConfig.setPassword(redisPassword);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Redisson.create(config);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 redisUrl 为 Redis 服务的地址，redisPassword 为 Redis 服务的密码。</p>\n<p>RedissonClient 连接配置可以按需进行调整。</p>\n<h3 id=\"zookeeper\"><a class=\"markdownIt-Anchor\" href=\"#zookeeper\">#</a> ZooKeeper</h3>\n<p>使用 ZooKeeper 作为锁服务的实现时，需要如下配置类配置 CuratorFramework 组件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZooKeeperLockConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.url:localhost:2181&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.timeout:1000&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> timeout;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.retry:3&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> retry;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CuratorFramework <span class=\"title function_\">zkClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ExponentialBackoffRetry</span> <span class=\"variable\">exponentialBackoffRetry</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExponentialBackoffRetry</span>(timeout, retry);</span><br><span class=\"line\">        <span class=\"type\">CuratorFramework</span> <span class=\"variable\">curatorFramework</span> <span class=\"operator\">=</span> CuratorFrameworkFactory.newClient(url, exponentialBackoffRetry);</span><br><span class=\"line\">        curatorFramework.start();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> curatorFramework;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 url 是 ZooKeeper 服务地址，timeout 是连接超时时间，retry 是连接失败重试次数。</p>\n<p>CuratorFramework 连接配置可以按需进行调整。</p>\n<h2 id=\"加锁逻辑\"><a class=\"markdownIt-Anchor\" href=\"#加锁逻辑\">#</a> 加锁逻辑</h2>\n<p>在分布式系统中，多系统之间的数据很可能不互通，因此加锁肯定不是通过原始数据进行加锁。</p>\n<p>在加锁时，我们应该对应原始数据，生成唯一的对应该数据的 token 作为加锁依据的 key，同时该 key 在无论何时对于该原始数据而言生成的都是这个 key。这样一来，通过该 key 明确地指向原始数据进行加锁与解锁。</p>\n<p>例如在系统中，存在张 User 表，该表中 id 列为其主键。那么在进行数据加锁时，则可以考虑以如下格式：“User-[id 数据]” 来进行加锁解锁操作。</p>\n<h3 id=\"redisson-2\"><a class=\"markdownIt-Anchor\" href=\"#redisson-2\">#</a> Redisson</h3>\n<p>Redisson 的 “红锁”（Red Lock）是一种基于 Redis 的分布式锁实现，它提供了高可用性和一致性保证。红锁的设计目的是为了克服单点故障问题，通过在多个<br>\n Redis 实例上实现分布式锁来提高系统的可靠性和可用性。</p>\n<p>红锁的基本原理<br>\n红锁的核心思想是在多个 Redis 实例上分别尝试获取锁，只有当大多数实例成功获取锁时，才认为整个分布式锁成功获取。具体步骤如下：</p>\n<ol>\n<li>尝试获取锁：在多个 Redis 实例上尝试获取锁。</li>\n<li>判断是否成功：只有当大多数 Redis 实例成功获取锁时，才认为整个分布式锁成功获取。</li>\n<li>释放锁：在所有成功获取锁的 Redis 实例上释放锁。</li>\n</ol>\n<p>实现步骤</p>\n<ol>\n<li>首先需要创建一个或多个 Redis 客户端，并初始化 Redisson 框架。</li>\n<li>使用 Redisson 框架创建红锁。</li>\n<li>尝试在多个 Redis 实例上获取锁。</li>\n<li>在所有成功获取锁的 Redis 实例上释放锁。</li>\n</ol>\n<h3 id=\"zookeeper-2\"><a class=\"markdownIt-Anchor\" href=\"#zookeeper-2\">#</a> ZooKeeper</h3>\n<p>ZooKeeper 分布式锁是一种常用的分布式协调机制，用于解决多个进程或服务之间的互斥访问问题。<br>\n在分布式系统中，多个节点可能需要同时访问共享资源，而分布式锁可以确保这些访问是互斥的，从而避免数据不一致的问题。<br>\n同时 ZooKeeper 集群化部署的高可用性和一致性使得它可以可靠地处理高并发加锁场景。</p>\n<p>分布式锁的基本原理<br>\n分布式锁的基本原理是在 ZooKeeper 中创建一个临时有序节点（ephemeral sequential node），每个客户端通过创建这样的节点来表示自己持有锁的状态。具体步骤如下：</p>\n<ol>\n<li>创建临时有序节点：客户端在 ZooKeeper 中创建一个临时有序节点。</li>\n<li>判断是否是最小节点：客户端检查自己创建的节点是否是最小的节点。</li>\n<li>加锁与释放锁：如果是最小节点，则客户端获得锁；否则，客户端等待前一个节点释放锁。</li>\n</ol>\n<p>实现步骤</p>\n<ol>\n<li>创建锁节点\n<ol>\n<li>定义锁路径：\n<ol>\n<li>选择一个固定的路径作为锁的根节点，例如 /distributed-lock。</li>\n<li>客户端在该路径下创建一个临时有序节点。</li>\n</ol>\n</li>\n<li>创建临时有序节点：\n<ol>\n<li>使用 create API 创建临时有序节点，例如 /distributed-lock/lock-0000000001。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>判断是否是最小节点\n<ol>\n<li>获取所有子节点：\n<ol>\n<li>客户端获取锁路径下的所有子节点，例如 /distributed-lock 下的所有子节点。</li>\n</ol>\n</li>\n<li>比较节点序号：\n<ol>\n<li>客户端将自己的节点序号与其他节点的序号进行比较。</li>\n<li>如果当前节点序号是最小的，则获得锁；否则，等待前一个节点释放锁。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>加锁与释放锁\n<ol>\n<li>加锁：\n<ol>\n<li>如果当前节点序号是最小的，则获得锁。</li>\n<li>否则，等待前一个节点释放锁。</li>\n</ol>\n</li>\n<li>释放锁：\n<ol>\n<li>当客户端不再需要锁时，删除自己创建的临时有序节点。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"加锁实现\"><a class=\"markdownIt-Anchor\" href=\"#加锁实现\">#</a> 加锁实现</h2>\n<p>在进行实现时，首先考虑到一次加锁时可能涉及到多个数据，因此使用 key 集合来进行加锁，timeout 与 timeunit 用于指代锁的超时时长。</p>\n<p>抽象出如下方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(List&lt;String&gt; keys,Long timeout,TimeUnit unit)</span><span class=\"keyword\">throws</span> Exception;</span><br></pre></td></tr></table></figure>\n<p>LockEntity 为锁实例，用于进行解锁操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockEntity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object lock;</span><br><span class=\"line\"></span><br><span class=\"line\">    LockEntity(Object lock) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.lock = lock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lock <span class=\"keyword\">instanceof</span> RLock rLock) &#123;</span><br><span class=\"line\">            rLock.unlock();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lock <span class=\"keyword\">instanceof</span> InterProcessLock interProcessLock) &#123;</span><br><span class=\"line\">            interProcessLock.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>针对不同的锁类型，采取不同的解锁方法</p>\n<h3 id=\"redisson-3\"><a class=\"markdownIt-Anchor\" href=\"#redisson-3\">#</a> Redisson</h3>\n<p>逻辑：先通过 RedissonClient 组件遍历 keys 集合获取所有锁实例，再将以这些锁实例来获取一个 MultiLock 实例，来进行多锁的统一加锁解锁，再根据提供的 timeout 和 unit 加锁并返回 LockEntity 对象用来操作解锁。</p>\n<p>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys,Long timeout,TimeUnit unit)</span>&#123;</span><br><span class=\"line\">        ArrayList&lt;RLock&gt; rLocks=<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(keys.size());</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String key:keys)&#123;</span><br><span class=\"line\">        rLocks.add(redissonClient.getLock(key));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        RLock multiLock=redissonClient.getMultiLock(rLocks.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">RLock</span>[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(timeout!=<span class=\"literal\">null</span>&amp;&amp;timeout&gt;<span class=\"number\">0</span>&amp;&amp;unit!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">        multiLock.lock(timeout,unit);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        multiLock.lock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"zookeeper-3\"><a class=\"markdownIt-Anchor\" href=\"#zookeeper-3\">#</a> ZooKeeper</h3>\n<p>逻辑：同 Redisson 类似，先构造多锁对象，然后使用该对象进行加锁并返回</p>\n<p>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; lockKeys,Long timeout,TimeUnit unit)</span><span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">        InterProcessMultiLock multiLock=<span class=\"keyword\">new</span> <span class=\"title class_\">InterProcessMultiLock</span>(zkClient,lockKeys.stream().toList());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(timeout!=<span class=\"literal\">null</span>&amp;&amp;timeout&gt;<span class=\"number\">0</span>&amp;&amp;unit!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">        multiLock.acquire(timeout,unit);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        multiLock.acquire();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现通过注解加锁\"><a class=\"markdownIt-Anchor\" href=\"#实现通过注解加锁\">#</a> 实现通过注解加锁</h2>\n<h3 id=\"定义注解\"><a class=\"markdownIt-Anchor\" href=\"#定义注解\">#</a> 定义注解</h3>\n<ol>\n<li>\n<p>首先针对锁的实现方式，定义区分注解：</p>\n<ul>\n<li>\n<p>@RedisLock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RedisLock &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">timeout</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimeUnit <span class=\"title function_\">unit</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> TimeUnit.SECONDS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>@ZkLock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ZkLock &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">timeout</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimeUnit <span class=\"title function_\">unit</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> TimeUnit.SECONDS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这两个注解作用于方法上，用于表明当前方法需要使用到分布式锁，以及需要使用到哪种分布式锁，并提供锁的超时时间。</p>\n</li>\n<li>\n<p>其次针对方法参数中的的同步参数，提供一个注解 @SyncArg。</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.PARAMETER&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SyncArg &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 加锁依据，填入Spel表达式，用于生成锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * 应该确保每一个加锁对象能够生成一个固定的且独立的key</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用时可用上下文包括 arg：当前参数，method：当前运行的方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    String <span class=\"title function_\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"string\">&quot;#arg.hashCode()&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 是否采用多对象解析方式，多对象时将产生多个锁并同步加锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 当传入对象实现了 Iterable时，将遍历每一个子项，并且生成key时arg为当前遍历到的对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 当传入对象实现了Map时，将遍历每个Entry，生成key时arg为当前Entry</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">isMulti</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该注解作用于方法参数，表明该参数需要参照 value 值生成 key 来加锁，isMulti 用于标识当前参数是否是多对象参数。</p>\n</li>\n</ol>\n<h3 id=\"处理注解\"><a class=\"markdownIt-Anchor\" href=\"#处理注解\">#</a> 处理注解</h3>\n<p>首先，通过一个上下文对象用来自动生成加锁的 key。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockContext</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 被加锁的参数对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object arg;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成key的Spel表达式</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String keyExpression;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 是否为多对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> multi;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Getter(AccessLevel.PACKAGE)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; params;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(SyncArg syncArg, Object arg)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(arg, syncArg.value(), syncArg.isMulti());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(Object arg, String keyExpression, <span class=\"type\">boolean</span> multi)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(arg, keyExpression, multi, <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(Object arg, String keyExpression, <span class=\"type\">boolean</span> multi, Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.arg = arg;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.keyExpression = keyExpression;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.multi = multi;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.params = params;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key   key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 用于链式调用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockContext <span class=\"title function_\">addParam</span><span class=\"params\">(String key, Object value)</span> &#123;</span><br><span class=\"line\">        params.put(key, value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 用于链式调用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockContext <span class=\"title function_\">removeParam</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        params.remove(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getKey(<span class=\"keyword\">new</span> <span class=\"title class_\">SpelExpressionParser</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成key</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> parser Spel表达式解析器</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getKey</span><span class=\"params\">(SpelExpressionParser parser)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StandardEvaluationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StandardEvaluationContext</span>();</span><br><span class=\"line\">        HashMap&lt;String, Object&gt; contextMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(params);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!contextMap.containsKey(<span class=\"string\">&quot;arg&quot;</span>)) &#123;</span><br><span class=\"line\">            contextMap.put(<span class=\"string\">&quot;arg&quot;</span>, arg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        context.setVariables(contextMap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parser.parseExpression(keyExpression).getValue(context, String.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里通过继承抽象类的方式在抽象类中提供一些公共方法，由子类进行加锁的实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 格式化生成的key，在生成加锁key时会经过该方法，并以返回的key作为最终加锁时的key</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> generatedKey 通过上下文对象自动生成的key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 格式化后的key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过LockContext的形式生成锁key再加锁</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockContexts 用于生成锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeout      锁超时时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit         时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 锁对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> LockEntity <span class=\"title function_\">doLockByContext</span><span class=\"params\">(List&lt;LockContext&gt; lockContexts, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> doLock(getLockKeys(lockContexts), timeout, unit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> doLock(keys, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过锁keys进行加锁，由子类实现</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> keys    锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeout 超时时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit    时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 锁对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据方法及入参解析出LockContext列表</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method 加锁的方法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args   入参</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> LockContext列表</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> List&lt;LockContext&gt; <span class=\"title function_\">getLockContexts</span><span class=\"params\">(Method method, Object[] args)</span> &#123;</span><br><span class=\"line\">        Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class=\"line\">        ArrayList&lt;LockContext&gt; lockContexts = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; parameterAnnotations.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取参数注解，与参数一一对应</span></span><br><span class=\"line\">            Annotation[] annotations = parameterAnnotations[i];</span><br><span class=\"line\">            <span class=\"comment\">//找到@SyncArg注解</span></span><br><span class=\"line\">            <span class=\"type\">SyncArg</span> <span class=\"variable\">syncArg</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Annotation annotation : annotations) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (annotation <span class=\"keyword\">instanceof</span> SyncArg syncArgA) &#123;</span><br><span class=\"line\">                    syncArg = syncArgA;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (syncArg != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//注解存在则通过注解构造上下文对象</span></span><br><span class=\"line\">                <span class=\"type\">LockContext</span> <span class=\"variable\">lockContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(syncArg, args[i]);</span><br><span class=\"line\">                lockContext.addParam(<span class=\"string\">&quot;method&quot;</span>, method);</span><br><span class=\"line\">                lockContexts.add(lockContext);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lockContexts;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过上下文对象列表生成key集合</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockContexts 上下文对象列表</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> key集合</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> HashSet&lt;String&gt; <span class=\"title function_\">getLockKeys</span><span class=\"params\">(List&lt;LockContext&gt; lockContexts)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//解析上下文列表，生成key</span></span><br><span class=\"line\">        HashSet&lt;String&gt; keys = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">SpelExpressionParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SpelExpressionParser</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (LockContext lockContext : lockContexts) &#123;</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">multi</span> <span class=\"operator\">=</span> lockContext.isMulti();</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">arg</span> <span class=\"operator\">=</span> lockContext.getArg();</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">keyExpression</span> <span class=\"operator\">=</span> lockContext.getKeyExpression();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (multi &amp;&amp; arg <span class=\"keyword\">instanceof</span> Iterable&lt;?&gt; iterable) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//多对象模式且参数对象为Iterable时</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Object o : iterable) &#123;</span><br><span class=\"line\">                    <span class=\"type\">LockContext</span> <span class=\"variable\">singleContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(o, keyExpression, <span class=\"literal\">false</span>, lockContext.getParams());</span><br><span class=\"line\">                    keys.add(formatKey(singleContext.getKey(parser)));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (multi &amp;&amp; arg <span class=\"keyword\">instanceof</span> Map&lt;?, ?&gt; map) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//多对象模式且参数对象为map时</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Map.Entry&lt;?, ?&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">LockContext</span> <span class=\"variable\">singleContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(entry, keyExpression, <span class=\"literal\">false</span>, lockContext.getParams());</span><br><span class=\"line\">                    keys.add(formatKey(singleContext.getKey(parser)));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                keys.add(formatKey(lockContext.getKey(parser)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> keys;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"redisson实现\"><a class=\"markdownIt-Anchor\" href=\"#redisson实现\">#</a> Redisson 实现</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedissonLockService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RedissonClient redissonClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedissonLockService</span><span class=\"params\">(RedissonClient redissonClient)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redissonClient = redissonClient;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;@annotation(org.joker.commons.cloud.lock.annotation.RedisLock)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doLockByContext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;doLockByContext()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint point)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取方法对象</span></span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) point.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        <span class=\"comment\">//解析用于生成锁的上下文</span></span><br><span class=\"line\">        List&lt;LockContext&gt; lockContexts = getLockContexts(method, point.getArgs());</span><br><span class=\"line\">        <span class=\"comment\">//加锁并执行</span></span><br><span class=\"line\">        <span class=\"type\">RedisLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> method.getAnnotation(RedisLock.class);</span><br><span class=\"line\">        <span class=\"type\">LockEntity</span> <span class=\"variable\">lockEntity</span> <span class=\"operator\">=</span> doLockByContext(lockContexts, lock.timeout(), lock.unit());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> point.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lockEntity.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;cloud:lock:&quot;</span> + generatedKey;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys, Long timeout, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;RLock&gt; rLocks = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(keys.size());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">            rLocks.add(redissonClient.getLock(key));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">RLock</span> <span class=\"variable\">multiLock</span> <span class=\"operator\">=</span> redissonClient.getMultiLock(rLocks.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">RLock</span>[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timeout != <span class=\"literal\">null</span> &amp;&amp; timeout &gt; <span class=\"number\">0</span> &amp;&amp; unit != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            multiLock.lock(timeout, unit);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            multiLock.lock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 AOP 的方法，在 @RedisLock 注解处创建切面，在执行该方法之前先对该方法的参数进行处理，产生上下文列表，并依据该列表生成对应的 key 集合，再通过该 key 集合尝试获取锁。在获取锁成功后再执行对应的方法，在 finally 代码块中释放锁。</p>\n<h5 id=\"zookeeper实现\"><a class=\"markdownIt-Anchor\" href=\"#zookeeper实现\">#</a> ZooKeeper 实现</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZooKeeperLockService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CuratorFramework zkClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ZooKeeperLockService</span><span class=\"params\">(CuratorFramework zkClient)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.zkClient = zkClient;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;@annotation(org.joker.commons.cloud.lock.annotation.ZkLock)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doLockByContext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;doLockByContext()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint point)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取方法对象</span></span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) point.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        <span class=\"comment\">//解析用于生成锁的上下文</span></span><br><span class=\"line\">        List&lt;LockContext&gt; lockContexts = getLockContexts(method, point.getArgs());</span><br><span class=\"line\">        <span class=\"comment\">//加锁并执行</span></span><br><span class=\"line\">        <span class=\"type\">ZkLock</span> <span class=\"variable\">zkLock</span> <span class=\"operator\">=</span> method.getAnnotation(ZkLock.class);</span><br><span class=\"line\">        <span class=\"type\">LockEntity</span> <span class=\"variable\">lockEntity</span> <span class=\"operator\">=</span> doLockByContext(lockContexts, zkLock.timeout(), zkLock.unit());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> point.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lockEntity.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;/cloud/lock/&quot;</span> + generatedKey;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; lockKeys, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">InterProcessMultiLock</span> <span class=\"variable\">multiLock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InterProcessMultiLock</span>(zkClient, lockKeys.stream().toList());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timeout != <span class=\"literal\">null</span> &amp;&amp; timeout &gt; <span class=\"number\">0</span> &amp;&amp; unit != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            multiLock.acquire(timeout, unit);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            multiLock.acquire();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同 Redisson 类似，在 ZkLock 处创建切面，先根据注解解析对应参数的锁 key 后，再获取锁，然后执行方法并释放锁。</p>\n<h2 id=\"完整代码\"><a class=\"markdownIt-Anchor\" href=\"#完整代码\">#</a> 完整代码</h2>\n<p>以下按照包结构排列</p>\n<ul>\n<li>\n<p>…</p>\n<ul>\n<li>\n<p>lock</p>\n<ul>\n<li>\n<p>annotation</p>\n<ul>\n<li>\n<p>RedisLock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RedisLock &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">timeout</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimeUnit <span class=\"title function_\">unit</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> TimeUnit.SECONDS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>SyncArg</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.PARAMETER&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SyncArg &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 加锁依据，填入Spel表达式，用于生成锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * 应该确保每一个加锁对象能够生成一个固定的且独立的key</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用时可用上下文包括 arg：当前参数，method：当前运行的方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    String <span class=\"title function_\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"string\">&quot;#arg.hashCode()&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 是否采用多对象解析方式，多对象时将产生多个锁并同步加锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 当传入对象实现了 Iterable时，将遍历每一个子项，并且生成key时arg为当前遍历到的对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 当传入对象实现了Map时，将遍历每个Entry，生成key时arg为当前Entry</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">isMulti</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>ZkLock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ZkLock &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">timeout</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimeUnit <span class=\"title function_\">unit</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> TimeUnit.SECONDS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>config</p>\n<ul>\n<li>\n<p>RedissonLockConfig</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedissonLockConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.redis.url:redis://localhost:6379&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String redisUrl;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.redis.password:&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String redisPassword;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RedissonClient <span class=\"title function_\">redissonClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Config</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Config</span>();</span><br><span class=\"line\">        <span class=\"type\">SingleServerConfig</span> <span class=\"variable\">singleServerConfig</span> <span class=\"operator\">=</span> config.useSingleServer();</span><br><span class=\"line\">        singleServerConfig.setAddress(redisUrl);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isNotEmpty(redisPassword)) &#123;</span><br><span class=\"line\">            singleServerConfig.setPassword(redisPassword);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Redisson.create(config);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>ZooKeeperLockConfig</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZooKeeperLockConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.url:localhost:2181&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.timeout:1000&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> timeout;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;cloud.lock.zookeeper.retry:3&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> retry;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CuratorFramework <span class=\"title function_\">zkClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ExponentialBackoffRetry</span> <span class=\"variable\">exponentialBackoffRetry</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExponentialBackoffRetry</span>(timeout, retry);</span><br><span class=\"line\">        <span class=\"type\">CuratorFramework</span> <span class=\"variable\">curatorFramework</span> <span class=\"operator\">=</span> CuratorFrameworkFactory.newClient(url, exponentialBackoffRetry);</span><br><span class=\"line\">        curatorFramework.start();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> curatorFramework;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>AbstractLockService</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 格式化生成的key，在生成加锁key时会经过该方法，并以返回的key作为最终加锁时的key</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> generatedKey 通过上下文对象自动生成的key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 格式化后的key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过LockContext的形式生成锁key再加锁</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockContexts 用于生成锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeout      锁超时时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit         时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 锁对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> LockEntity <span class=\"title function_\">doLockByContext</span><span class=\"params\">(List&lt;LockContext&gt; lockContexts, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> doLock(getLockKeys(lockContexts), timeout, unit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> doLock(keys, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过锁keys进行加锁，由子类实现</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> keys    锁key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeout 超时时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit    时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 锁对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据方法及入参解析出LockContext列表</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method 加锁的方法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args   入参</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> LockContext列表</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> List&lt;LockContext&gt; <span class=\"title function_\">getLockContexts</span><span class=\"params\">(Method method, Object[] args)</span> &#123;</span><br><span class=\"line\">        Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class=\"line\">        ArrayList&lt;LockContext&gt; lockContexts = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; parameterAnnotations.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取参数注解，与参数一一对应</span></span><br><span class=\"line\">            Annotation[] annotations = parameterAnnotations[i];</span><br><span class=\"line\">            <span class=\"comment\">//找到@SyncArg注解</span></span><br><span class=\"line\">            <span class=\"type\">SyncArg</span> <span class=\"variable\">syncArg</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Annotation annotation : annotations) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (annotation <span class=\"keyword\">instanceof</span> SyncArg syncArgA) &#123;</span><br><span class=\"line\">                    syncArg = syncArgA;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (syncArg != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//注解存在则通过注解构造上下文对象</span></span><br><span class=\"line\">                <span class=\"type\">LockContext</span> <span class=\"variable\">lockContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(syncArg, args[i]);</span><br><span class=\"line\">                lockContext.addParam(<span class=\"string\">&quot;method&quot;</span>, method);</span><br><span class=\"line\">                lockContexts.add(lockContext);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lockContexts;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过上下文对象列表生成key集合</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockContexts 上下文对象列表</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> key集合</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> HashSet&lt;String&gt; <span class=\"title function_\">getLockKeys</span><span class=\"params\">(List&lt;LockContext&gt; lockContexts)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//解析上下文列表，生成key</span></span><br><span class=\"line\">        HashSet&lt;String&gt; keys = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">SpelExpressionParser</span> <span class=\"variable\">parser</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SpelExpressionParser</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (LockContext lockContext : lockContexts) &#123;</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">multi</span> <span class=\"operator\">=</span> lockContext.isMulti();</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">arg</span> <span class=\"operator\">=</span> lockContext.getArg();</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">keyExpression</span> <span class=\"operator\">=</span> lockContext.getKeyExpression();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (multi &amp;&amp; arg <span class=\"keyword\">instanceof</span> Iterable&lt;?&gt; iterable) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//多对象模式且参数对象为Iterable时</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Object o : iterable) &#123;</span><br><span class=\"line\">                    <span class=\"type\">LockContext</span> <span class=\"variable\">singleContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(o, keyExpression, <span class=\"literal\">false</span>, lockContext.getParams());</span><br><span class=\"line\">                    keys.add(formatKey(singleContext.getKey(parser)));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (multi &amp;&amp; arg <span class=\"keyword\">instanceof</span> Map&lt;?, ?&gt; map) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//多对象模式且参数对象为map时</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Map.Entry&lt;?, ?&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">LockContext</span> <span class=\"variable\">singleContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockContext</span>(entry, keyExpression, <span class=\"literal\">false</span>, lockContext.getParams());</span><br><span class=\"line\">                    keys.add(formatKey(singleContext.getKey(parser)));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                keys.add(formatKey(lockContext.getKey(parser)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> keys;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>LockContext</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockContext</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 被加锁的参数对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object arg;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成key的Spel表达式</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String keyExpression;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 是否为多对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> multi;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Getter(AccessLevel.PACKAGE)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; params;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(SyncArg syncArg, Object arg)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(arg, syncArg.value(), syncArg.isMulti());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(Object arg, String keyExpression, <span class=\"type\">boolean</span> multi)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(arg, keyExpression, multi, <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LockContext</span><span class=\"params\">(Object arg, String keyExpression, <span class=\"type\">boolean</span> multi, Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.arg = arg;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.keyExpression = keyExpression;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.multi = multi;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.params = params;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key   key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 用于链式调用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockContext <span class=\"title function_\">addParam</span><span class=\"params\">(String key, Object value)</span> &#123;</span><br><span class=\"line\">        params.put(key, value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除上下文参数</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 用于链式调用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockContext <span class=\"title function_\">removeParam</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        params.remove(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getKey(<span class=\"keyword\">new</span> <span class=\"title class_\">SpelExpressionParser</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成key</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> parser Spel表达式解析器</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getKey</span><span class=\"params\">(SpelExpressionParser parser)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StandardEvaluationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StandardEvaluationContext</span>();</span><br><span class=\"line\">        HashMap&lt;String, Object&gt; contextMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(params);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!contextMap.containsKey(<span class=\"string\">&quot;arg&quot;</span>)) &#123;</span><br><span class=\"line\">            contextMap.put(<span class=\"string\">&quot;arg&quot;</span>, arg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        context.setVariables(contextMap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parser.parseExpression(keyExpression).getValue(String.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>LockEntity</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockEntity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object lock;</span><br><span class=\"line\"></span><br><span class=\"line\">    LockEntity(Object lock) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.lock = lock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lock <span class=\"keyword\">instanceof</span> RLock rLock) &#123;</span><br><span class=\"line\">            rLock.unlock();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lock <span class=\"keyword\">instanceof</span> InterProcessLock interProcessLock) &#123;</span><br><span class=\"line\">            interProcessLock.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>RedissonLockService</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedissonLockService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RedissonClient redissonClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedissonLockService</span><span class=\"params\">(RedissonClient redissonClient)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.redissonClient = redissonClient;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;@annotation(org.joker.commons.cloud.lock.annotation.RedisLock)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doLockByContext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;doLockByContext()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint point)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取方法对象</span></span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) point.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        <span class=\"comment\">//解析用于生成锁的上下文</span></span><br><span class=\"line\">        List&lt;LockContext&gt; lockContexts = getLockContexts(method, point.getArgs());</span><br><span class=\"line\">        <span class=\"comment\">//加锁并执行</span></span><br><span class=\"line\">        <span class=\"type\">RedisLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> method.getAnnotation(RedisLock.class);</span><br><span class=\"line\">        <span class=\"type\">LockEntity</span> <span class=\"variable\">lockEntity</span> <span class=\"operator\">=</span> doLockByContext(lockContexts, lock.timeout(), lock.unit());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> point.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lockEntity.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;cloud:lock:&quot;</span> + generatedKey;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; keys, Long timeout, TimeUnit unit)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;RLock&gt; rLocks = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(keys.size());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">            rLocks.add(redissonClient.getLock(key));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">RLock</span> <span class=\"variable\">multiLock</span> <span class=\"operator\">=</span> redissonClient.getMultiLock(rLocks.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">RLock</span>[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timeout != <span class=\"literal\">null</span> &amp;&amp; timeout &gt; <span class=\"number\">0</span> &amp;&amp; unit != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            multiLock.lock(timeout, unit);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            multiLock.lock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>ZooKeeper</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZooKeeperLockService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLockService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CuratorFramework zkClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ZooKeeperLockService</span><span class=\"params\">(CuratorFramework zkClient)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.zkClient = zkClient;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;@annotation(org.joker.commons.cloud.lock.annotation.ZkLock)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doLockByContext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;doLockByContext()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint point)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取方法对象</span></span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) point.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        <span class=\"comment\">//解析用于生成锁的上下文</span></span><br><span class=\"line\">        List&lt;LockContext&gt; lockContexts = getLockContexts(method, point.getArgs());</span><br><span class=\"line\">        <span class=\"comment\">//加锁并执行</span></span><br><span class=\"line\">        <span class=\"type\">ZkLock</span> <span class=\"variable\">zkLock</span> <span class=\"operator\">=</span> method.getAnnotation(ZkLock.class);</span><br><span class=\"line\">        <span class=\"type\">LockEntity</span> <span class=\"variable\">lockEntity</span> <span class=\"operator\">=</span> doLockByContext(lockContexts, zkLock.timeout(), zkLock.unit());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> point.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lockEntity.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">formatKey</span><span class=\"params\">(String generatedKey)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;/cloud/lock/&quot;</span> + generatedKey;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LockEntity <span class=\"title function_\">doLock</span><span class=\"params\">(Set&lt;String&gt; lockKeys, Long timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">InterProcessMultiLock</span> <span class=\"variable\">multiLock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InterProcessMultiLock</span>(zkClient, lockKeys.stream().toList());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timeout != <span class=\"literal\">null</span> &amp;&amp; timeout &gt; <span class=\"number\">0</span> &amp;&amp; unit != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            multiLock.acquire(timeout, unit);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            multiLock.acquire();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockEntity</span>(multiLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"测试效果\"><a class=\"markdownIt-Anchor\" href=\"#测试效果\">#</a> 测试效果</h2>\n<p>采用如下 Spring 服务类进行效果测试，其中 run 中为测试代码，表达式 “#arg.getClass ().getSimpleName ()+#arg.getId ()<br>\n” 以 id 作为唯一主键生成 key，当前示例下生成的 key 为 Usertest01。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Getter</span></span><br><span class=\"line\">    <span class=\"meta\">@Setter</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;test01&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;测试用户&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">(User user)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        log.info(user.getName());</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">//模拟业务过程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RedisLock</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testRedisSync</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">            <span class=\"meta\">@SyncArg(&quot;#arg.getClass().getSimpleName()+#arg.getId()&quot;)</span> User user</span></span><br><span class=\"line\"><span class=\"params\">    )</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        test(user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ZkLock</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testZooKeeperSync</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">            <span class=\"meta\">@SyncArg(&quot;#arg.getClass().getSimpleName()+#arg.getId()&quot;)</span> User user</span></span><br><span class=\"line\"><span class=\"params\">    )</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        test(user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"不加锁\"><a class=\"markdownIt-Anchor\" href=\"#不加锁\">#</a> 不加锁</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestRunner</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestService testService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        TestService.<span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TestService</span>.User();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            testService.test(user);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>服务一：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/378a9d360acf6a6c560d3c2e9f68be60.png\" class=\"\" title=\"不加锁服务1log\">\n<p>服务二：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/248294a19780cc9e924184e26670a0c3.png\" class=\"\" title=\"不加锁服务2log\">\n<p>根据时间可以看到两个服务几乎同时在进行，如果存在变更数据的情况则可能存在出现数据不一致情况的风险。</p>\n<h3 id=\"使用redis锁\"><a class=\"markdownIt-Anchor\" href=\"#使用redis锁\">#</a> 使用 Redis 锁</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestRunner</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestService testService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        TestService.<span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TestService</span>.User();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            testService.testRedisSync(user);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>服务一：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/4507c4421a934baec554f92cea7b0038.png\" class=\"\" title=\"Redis锁服务1log\">\n<p>服务二：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/9158b26eab49184d53d500eb7c0e07b6.png\" class=\"\" title=\"Redis锁服务2log\">\n<p>根据时间可以看到两个服务在逐一有序地进行，能够实现锁的效果。</p>\n<h3 id=\"使用zookeeper锁\"><a class=\"markdownIt-Anchor\" href=\"#使用zookeeper锁\">#</a> 使用 ZooKeeper 锁</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestRunner</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestService testService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        TestService.<span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TestService</span>.User();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            testService.testZooKeeperSync(user);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>服务一：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/7ed3a36d886af2366487ddf9e679c224.png\" class=\"\" title=\"ZooKeeper服务1log\">\n<p>服务二：</p>\n<img data-src=\"/joker.github.io/2024/09/10/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%91%E9%80%9A%E8%BF%87Zookeeper%E4%B8%8ERedisson%E5%AE%9E%E7%8E%B0Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/b00b26556a04f89fc3e1224726755a96.png\" class=\"\" title=\"ZooKeeper服务2log\">\n<p>同样能够实现锁的效果。</p>\n",
            "tags": [
                "后端",
                "Zookeeper",
                "Redis",
                "Redisson",
                "分布式锁"
            ]
        }
    ]
}