<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://silvercrow42.github.io/joker.github.io</id>
    <title>Joker • Posts by &#34;java&#34; tag</title>
    <link href="https://silvercrow42.github.io/joker.github.io" />
    <updated>2024-11-01T07:56:08.000Z</updated>
    <category term="后端" />
    <category term="数据库" />
    <category term="关系型数据库" />
    <category term="Mysql" />
    <category term="MQ" />
    <category term="RocketMQ" />
    <category term="操作系统" />
    <category term="Linux" />
    <category term="java" />
    <category term="多线程" />
    <category term="NoSQL" />
    <category term="缓存" />
    <category term="Redis" />
    <category term="Zookeeper" />
    <category term="spring" />
    <category term="Redisson" />
    <category term="分布式锁" />
    <entry>
        <id>https://silvercrow42.github.io/joker.github.io/2024/11/01/%E3%80%90java%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
        <title>【java】多线程详解</title>
        <link rel="alternate" href="https://silvercrow42.github.io/joker.github.io/2024/11/01/%E3%80%90java%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
        <content type="html">&lt;h2 id=&#34;并发基础&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#并发基础&#34;&gt;#&lt;/a&gt; 并发基础&lt;/h2&gt;
&lt;h3 id=&#34;什么是并发&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#什么是并发&#34;&gt;#&lt;/a&gt; 什么是并发&lt;/h3&gt;
&lt;p&gt;并发是指多个任务在同一时间段内交错执行的能力。虽然这些任务可能不是真正的同时执行，但它们在时间上被快速交替调度，从而给人一种同时进行的错觉。并发可以显著提高程序的效率和响应性。以下是并发的几个关键点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务切换：操作系统通过快速切换任务来实现并发，每个任务在一段时间内获得 CPU 时间片。&lt;/li&gt;
&lt;li&gt;资源共享：并发任务通常共享某些资源，如内存、文件句柄等，因此需要适当的同步机制来避免冲突。&lt;/li&gt;
&lt;li&gt;提高资源利用率：通过并发，可以更充分地利用系统资源，尤其是多核处理器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;并发的使用场景&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#并发的使用场景&#34;&gt;#&lt;/a&gt; 并发的使用场景&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Web 服务器
&lt;ul&gt;
&lt;li&gt;处理多个请求：Web 服务器需要同时处理来自多个客户端的请求。通过并发，服务器可以创建多个线程或进程来处理这些请求，提高响应速度和吞吐量。&lt;/li&gt;
&lt;li&gt;异步 IO 操作：处理网络请求和文件读写等 IO 操作时，使用异步 IO 可以避免阻塞主线程，提高整体性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据库系统
&lt;ul&gt;
&lt;li&gt;并行查询：数据库系统可以并行执行多个查询，特别是在处理大数据集时，可以显著提高查询效率。&lt;/li&gt;
&lt;li&gt;事务管理：并发控制机制（如锁和事务隔离级别）确保多个事务可以安全地并行执行，避免数据不一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;图形用户界面（GUI）应用程序
&lt;ul&gt;
&lt;li&gt;响应用户输入：主线程负责处理用户输入和更新界面，后台线程处理耗时任务（如数据加载、计算等），保持界面的响应性。&lt;/li&gt;
&lt;li&gt;动画和渲染：并行处理动画和渲染任务，提高视觉效果的流畅度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;大数据分析
&lt;ul&gt;
&lt;li&gt;并行数据处理：使用 MapReduce 等并行计算框架，将大数据集分成多个部分，由多个节点并行处理，加快数据处理速度。&lt;/li&gt;
&lt;li&gt;分布式存储：并行读取和写入分布式存储系统中的数据，提高数据访问效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;游戏开发
&lt;ul&gt;
&lt;li&gt;物理模拟：并行处理复杂的物理模拟计算，提高游戏的真实感和性能。&lt;/li&gt;
&lt;li&gt;AI 计算：并行处理游戏中的 AI 逻辑，使 NPC（非玩家角色）的行为更加智能和多样化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件和数据处理
&lt;ul&gt;
&lt;li&gt;并行文件处理：并行读取和处理多个文件，加快数据处理速度。&lt;/li&gt;
&lt;li&gt;批处理任务：并行执行批处理任务，如日志分析、数据转换等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络爬虫
&lt;ul&gt;
&lt;li&gt;并行抓取：同时从多个网站抓取数据，提高抓取速度。&lt;/li&gt;
&lt;li&gt;数据处理：并行处理抓取到的数据，加快数据清洗和分析过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;机器学习和深度学习
&lt;ul&gt;
&lt;li&gt;模型训练：并行训练模型，特别是在使用 GPU 加速时，可以显著缩短训练时间。&lt;/li&gt;
&lt;li&gt;数据预处理：并行处理大量训练数据，提高数据准备效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实时系统
&lt;ul&gt;
&lt;li&gt;实时数据处理：并行处理实时数据流，如传感器数据、股票市场数据等，确保低延迟和高吞吐量。&lt;/li&gt;
&lt;li&gt;任务调度：并行调度和执行多个实时任务，确保系统的响应性和可靠性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;云计算和虚拟化
&lt;ul&gt;
&lt;li&gt;资源分配：并行管理和分配计算资源，提高资源利用率。&lt;/li&gt;
&lt;li&gt;虚拟机管理：并行处理虚拟机的创建、启动和停止等操作，提高管理效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;高并发情况下可能出现的问题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#高并发情况下可能出现的问题&#34;&gt;#&lt;/a&gt; 高并发情况下可能出现的问题&lt;/h3&gt;
&lt;p&gt;在并发场景下，可能会面临多种问题，这些问题如果不妥善处理，会影响系统的稳定性和性能。以下是一些常见的并发问题及其简要说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;死锁（Deadlock）
&lt;ul&gt;
&lt;li&gt;定义：多个线程或进程互相等待对方持有的资源，导致所有线程或进程都无法继续执行。&lt;/li&gt;
&lt;li&gt;原因：资源分配不当、循环等待、缺乏超时机制等。&lt;/li&gt;
&lt;li&gt;示例：线程 A 持有资源 X 并请求资源 Y，而线程 B 持有资源 Y 并请求资源 X。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;竞态条件（Race Condition）
&lt;ul&gt;
&lt;li&gt;定义：多个线程或进程以不可预测的顺序访问和修改共享资源，导致不一致的状态。&lt;/li&gt;
&lt;li&gt;原因：缺乏适当的同步机制、线程间通信不正确等。&lt;/li&gt;
&lt;li&gt;示例：多个线程同时读取和修改同一个变量，导致最终结果不确定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上下文切换开销（Context Switching Overhead）
&lt;ul&gt;
&lt;li&gt;定义：操作系统在不同线程或进程之间切换时，需要保存和恢复当前线程的上下文，这会消耗时间和资源。&lt;/li&gt;
&lt;li&gt;原因：频繁的上下文切换。&lt;/li&gt;
&lt;li&gt;示例：在高并发环境下，频繁的线程切换会导致 CPU 利用率下降。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;资源竞争（Resource Contention）
&lt;ul&gt;
&lt;li&gt;定义：多个线程或进程竞争有限的资源，导致性能下降或资源浪费。&lt;/li&gt;
&lt;li&gt;原因：资源不足、同步机制不当等。&lt;/li&gt;
&lt;li&gt;示例：多个线程同时访问同一个文件或数据库连接池。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;饥饿（Starvation）
&lt;ul&gt;
&lt;li&gt;定义：某个线程或进程由于长时间无法获得所需的资源而无法继续执行。&lt;/li&gt;
&lt;li&gt;原因：优先级调度不当、资源分配不公平等。&lt;/li&gt;
&lt;li&gt;示例：低优先级线程长时间无法获得 CPU 时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;活锁（Livelock）
&lt;ul&gt;
&lt;li&gt;定义：多个线程或进程不断重复相同的操作，试图避免冲突，但最终无法取得进展。&lt;/li&gt;
&lt;li&gt;原因：缺乏有效的冲突解决机制。&lt;/li&gt;
&lt;li&gt;示例：两个线程在尝试获取同一个资源时，不断退让，导致两者都无法成功获取资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存泄漏（Memory Leak）
&lt;ul&gt;
&lt;li&gt;定义：程序在运行过程中未能释放不再使用的内存，导致内存占用逐渐增加。&lt;/li&gt;
&lt;li&gt;原因：未正确管理内存分配和释放、对象引用未解除等。&lt;/li&gt;
&lt;li&gt;示例：线程创建的对象未被及时回收，导致内存占用不断增加。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不一致状态（Inconsistent State）
&lt;ul&gt;
&lt;li&gt;定义：由于并发操作导致数据状态不一致，影响程序的正确性。&lt;/li&gt;
&lt;li&gt;原因：缺乏原子操作、同步机制不当等。&lt;/li&gt;
&lt;li&gt;示例：多个线程同时修改同一个数据结构，导致数据结构损坏。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;性能瓶颈（Performance Bottleneck）
&lt;ul&gt;
&lt;li&gt;定义：系统在高并发情况下，由于某个组件的性能限制，导致整体性能下降。&lt;/li&gt;
&lt;li&gt;原因：单点故障、资源限制、设计不合理等。&lt;/li&gt;
&lt;li&gt;示例：数据库连接池大小限制导致请求排队，影响整体性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解决方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步机制：使用锁（如互斥锁、信号量）、条件变量等同步机制来协调线程之间的访问。&lt;/li&gt;
&lt;li&gt;原子操作：使用原子操作来确保操作的不可分割性。&lt;/li&gt;
&lt;li&gt;线程池：使用线程池来管理线程，减少上下文切换开销。&lt;/li&gt;
&lt;li&gt;资源管理：合理分配和管理资源，避免资源竞争和饥饿。&lt;/li&gt;
&lt;li&gt;超时机制：设置超时机制，防止死锁和活锁。&lt;/li&gt;
&lt;li&gt;内存管理：及时释放不再使用的内存，避免内存泄漏。&lt;/li&gt;
&lt;li&gt;性能优化：识别和优化性能瓶颈，提高系统整体性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;happen-before-原则&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#happen-before-原则&#34;&gt;#&lt;/a&gt; Happen-before 原则&lt;/h3&gt;
&lt;p&gt;Happen-before 原则是 Java 内存模型（Java Memory Model, JMM）中的一个重要概念，用于保证多线程环境下的内存可见性和操作顺序。Happen-before&lt;br&gt;
 原则定义了两个操作之间的顺序关系，确保一个操作的结果对另一个操作是可见的。&lt;/p&gt;
&lt;p&gt;如果一个操作 A happen-before 另一个操作 B，那么 A 的结果对 B 是可见的，且 A 的动作在 B 之前完成。&lt;/p&gt;
&lt;p&gt;Happen-before 原则包括以下几个具体规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序顺序规则（Program Order Rule）
&lt;ul&gt;
&lt;li&gt;在一个线程中，按照程序代码的顺序，前面的操作 happen-before 后面的操作。&lt;/li&gt;
&lt;li&gt;示例：在同一个线程中，x = 1; y = x + 1;，x = 1 happen-before y = x + 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;监视器锁规则（Monitor Lock Rule）
&lt;ul&gt;
&lt;li&gt;对同一个锁的解锁操作 happen-before 后面对该锁的加锁操作。&lt;/li&gt;
&lt;li&gt;示例：线程 A 解锁一个对象的监视器，然后线程 B 加锁同一个对象的监视器，A 的解锁操作 happen-before B 的加锁操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;volatile 变量规则（Volatile Variable Rule）
&lt;ul&gt;
&lt;li&gt;对一个 volatile 变量的写操作 happen-before 后面对该变量的读操作。&lt;/li&gt;
&lt;li&gt;示例：线程 A 写入一个 volatile 变量 x，然后线程 B 读取同一个 volatile 变量 x，A 的写操作 happen-before B 的读操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程启动规则（Thread Start Rule）
&lt;ul&gt;
&lt;li&gt;线程的启动操作 happen-before 线程中的任何操作。&lt;/li&gt;
&lt;li&gt;示例：线程 A 启动线程 B，A 的启动操作 happen-before B 中的任何操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程终止规则（Thread Termination Rule）
&lt;ul&gt;
&lt;li&gt;线程中的任何操作 happen-before 线程的终止检测。&lt;/li&gt;
&lt;li&gt;示例：线程 A 终止，线程 B 检测到 A 已经终止，A 中的任何操作 happen-before B 检测到 A 的终止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中断规则（Interrupt Rule）
&lt;ul&gt;
&lt;li&gt;对线程的中断操作 happen-before 被中断线程检测到中断。&lt;/li&gt;
&lt;li&gt;示例：线程 A 中断线程 B，A 的中断操作 happen-before B 检测到中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;传递性（Transitivity）
&lt;ul&gt;
&lt;li&gt;如果 A happen-before B，且 B happen-before C，则 A happen-before C。&lt;/li&gt;
&lt;li&gt;示例：A happen-before B，B happen-before C，因此 A happen-before C。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;java-中的线程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#java-中的线程&#34;&gt;#&lt;/a&gt; Java 中的线程&lt;/h2&gt;
&lt;h3 id=&#34;线程的生命周期&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#线程的生命周期&#34;&gt;#&lt;/a&gt; 线程的生命周期&lt;/h3&gt;
&lt;p&gt;Java 线程有六种状态，这些状态反映了线程在其生命周期中的不同阶段。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新建（New）：线程被创建但尚未启动。&lt;/p&gt;
&lt;p&gt;前置条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当调用 Thread 对象的 start 方法时，线程从新建状态切换到就绪状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;就绪（Runnable）线程已经准备好运行，等待 CPU 分配时间片。&lt;/p&gt;
&lt;p&gt;前置条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从新建状态调用 start 方法后进入就绪状态。&lt;/li&gt;
&lt;li&gt;从阻塞、等待或定时等待状态返回后进入就绪状态。&lt;/li&gt;
&lt;li&gt;从运行状态因时间片用完或更高优先级线程抢占 CPU 而进入就绪状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行（Running）：Java 线程中将就绪（ready）和运行中（running）两种状态笼统的称为 “运行”，以下为两种状态的区分情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;就绪（Ready）：线程已经准备好运行，等待 CPU 分配时间片。&lt;/p&gt;
&lt;p&gt;前置条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从新建状态调用 start 方法后进入就绪状态。&lt;/li&gt;
&lt;li&gt;从阻塞、等待或定时等待状态返回后进入就绪状态。&lt;/li&gt;
&lt;li&gt;从运行状态因时间片用完或更高优先级线程抢占 CPU 而进入就绪状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行（Running）：线程正在 CPU 上执行。&lt;/p&gt;
&lt;p&gt;前置条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从就绪状态获得 CPU 时间片后进入运行状态。&lt;/li&gt;
&lt;li&gt;从运行状态因时间片用完或更高优先级线程抢占 CPU 而进入就绪状态。&lt;/li&gt;
&lt;li&gt;从运行状态因调用 wait、join、sleep 等方法进入等待或定时等待状态。&lt;/li&gt;
&lt;li&gt;从运行状态因调用 Object 的 wait 方法进入等待状态。&lt;/li&gt;
&lt;li&gt;从运行状态因调用 Thread 的 join 方法进入等待状态。&lt;/li&gt;
&lt;li&gt;从运行状态因调用 Thread 的 sleep 方法进入定时等待状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻塞（Blocked）：线程被阻塞，等待获取监视器锁。&lt;/p&gt;
&lt;p&gt;前置条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从运行状态因尝试获取已被其他线程持有的锁而进入阻塞状态。&lt;/li&gt;
&lt;li&gt;从阻塞状态因获得锁后进入就绪状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待（Waiting）：线程无限期等待其他线程执行特定操作。&lt;/p&gt;
&lt;p&gt;前置条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从运行状态因调用 Object 的 wait 方法进入等待状态。&lt;/li&gt;
&lt;li&gt;从运行状态因调用 Thread 的 join 方法进入等待状态。&lt;/li&gt;
&lt;li&gt;从运行状态因调用 LockSupport 的 park 方法进入等待状态。&lt;/li&gt;
&lt;li&gt;从等待状态因调用 Object 的 notify 或 notifyAll 方法进入就绪状态。&lt;/li&gt;
&lt;li&gt;从等待状态因调用 Thread 的 interrupt 方法进入就绪状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定时等待（Timed Waiting）：线程在指定时间内等待其他线程执行特定操作。&lt;/p&gt;
&lt;p&gt;前置条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从运行状态因调用 Thread 的 sleep 方法进入定时等待状态。&lt;/li&gt;
&lt;li&gt;从运行状态因调用 Object 的 wait 方法并指定超时时间进入定时等待状态。&lt;/li&gt;
&lt;li&gt;从运行状态因调用 Thread 的 join 方法并指定超时时间进入定时等待状态。&lt;/li&gt;
&lt;li&gt;从运行状态因调用 LockSupport 的 parkNanos 或 parkUntil 方法进入定时等待状态。&lt;/li&gt;
&lt;li&gt;从定时等待状态因超时或调用 Thread 的 interrupt 方法进入就绪状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;终止（Terminated）：线程已经退出，不再活动。&lt;/p&gt;
&lt;p&gt;前置条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从运行状态因 run 方法执行完毕或抛出未捕获的异常而进入终止状态。&lt;/li&gt;
&lt;li&gt;从等待或定时等待状态因调用 Thread 的 interrupt 方法并抛出 InterruptedException 而进入终止状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="后端" />
        <category term="java" />
        <category term="多线程" />
        <updated>2024-11-01T07:56:08.000Z</updated>
    </entry>
    <entry>
        <id>https://silvercrow42.github.io/joker.github.io/2024/09/24/%E3%80%90Zookeeper%E3%80%91Zookeeper%E8%AF%A6%E8%A7%A3/</id>
        <title>【Zookeeper】Zookeeper详解</title>
        <link rel="alternate" href="https://silvercrow42.github.io/joker.github.io/2024/09/24/%E3%80%90Zookeeper%E3%80%91Zookeeper%E8%AF%A6%E8%A7%A3/"/>
        <content type="html">&lt;h2 id=&#34;什么是zookeeper&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#什么是zookeeper&#34;&gt;#&lt;/a&gt; 什么是 Zookeeper&lt;/h2&gt;
&lt;p&gt;Zookeeper 是一个开源的主动协调服务，用于分布式应用程序，提供了诸如配置维护、域名服务、分布式同步、组服务等功能。它是一个为分布式应用提供一致性服务的软件，其内部使用了一种称为&lt;br&gt;
 Zab 的协议（在选举过程中使用 Paxos 协议）来保证分布式环境中不同节点之间的数据一致性。&lt;/p&gt;
&lt;p&gt;Zookeeper 的主要特点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高可用性：Zookeeper 可以构建为集群模式，通过多数派存活原则来保证服务的高可用性。&lt;/li&gt;
&lt;li&gt;顺序一致性：客户端请求按照发起顺序进行处理。&lt;/li&gt;
&lt;li&gt;原子性：所有事务要么全部成功，要么全部失败。&lt;/li&gt;
&lt;li&gt;单一视图：无论客户端连接到集群中的哪个服务器，看到的服务视图都是一样的。&lt;/li&gt;
&lt;li&gt;可靠性：一旦一个更新被应用并确认，该更新将一直有效，即使此时 Zookeeper 发生故障。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Zookeeper 的应用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据发布与订阅&lt;/p&gt;
&lt;p&gt;顾名思义就是将数据发布到 ZooKeeper 节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，地址列表等就非常适合使用。&lt;br&gt;
数据发布 / 订阅的一个常见的场景是配置中心，发布者把数据发布到 ZooKeeper 的一个或一系列的节点上，供订阅者进行数据订阅，达到动态获取数据的目的。&lt;br&gt;
配置信息一般有几个特点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据量小的 KV&lt;/li&gt;
&lt;li&gt;数据内容在运行时会发生动态变化&lt;/li&gt;
&lt;li&gt;集群机器共享，配置一致&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ZooKeeper 采用的是推拉结合的方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;推：服务端会推给注册了监控节点的客户端 Wathcer 事件通知&lt;/li&gt;
&lt;li&gt;拉：客户端获得通知后，然后主动到服务端拉取最新的数据&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命名服务&lt;/p&gt;
&lt;p&gt;作为分布式命名服务，命名服务是指通过指定的名字来获取资源或者服务的地址，利用 ZooKeeper 创建一个全局的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。统一命名服务的命名结构图如下所示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在分布式环境下，经常需要对应用 / 服务进行统一命名，便于识别不同服务。类似于域名与 IP 之间对应关系，IP 不容易记住，而域名容易记住。通过名称来获取资源或服务的地址，提供者等信息。&lt;/li&gt;
&lt;li&gt;按照层次结构组织服务 / 应用名称。可将服务名称以及地址信息写到 ZooKeeper 上，客户端通过 ZooKeeper 获取可用服务列表类。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分布式锁&lt;/p&gt;
&lt;p&gt;处于不同节点上不同的服务，它们可能需要顺序的访问一些资源，这里需要一把分布式的锁。&lt;br&gt;
分布式锁具有以下特性：写锁、读锁、时序锁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写锁：在 zk 上创建的一个临时的无编号的节点。由于是无序编号，在创建时不会自动编号，导致只能客户端有一个客户端得到锁，然后进行写入。&lt;/li&gt;
&lt;li&gt;读锁：在 zk 上创建一个临时的有编号的节点，这样即使下次有客户端加入是同时创建相同的节点时，他也会自动编号，也可以获得锁对象，然后对其进行读取。&lt;/li&gt;
&lt;li&gt;时序锁：在 zk 上创建的一个临时的有编号的节点根据编号的大小控制锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集群管理&lt;/p&gt;
&lt;p&gt;所谓集群管理就是：是否有机器退出和加入、选举 master。&lt;br&gt;
集群管理主要指集群监控和集群控制两个方面。前者侧重于集群运行时的状态的收集，后者则是对集群进行操作与控制。开发和运维中，面对集群，经常有如下需求:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;希望知道集群中究竟有多少机器在工作&lt;/li&gt;
&lt;li&gt;对集群中的每台机器的运行时状态进行数据收集&lt;/li&gt;
&lt;li&gt;对集群中机器进行上下线的操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;集群管理结构如下所示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;分布式环境中，实时掌握每个节点的状态是必要的，可根据节点实时状态做出一些调整。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可交由 ZooKeeper 实现。&lt;br&gt;
可将节点信息写入 ZooKeeper 上的一个 Znode。&lt;br&gt;
监听这个 Znode 可获取它的实时状态变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;典型应用&lt;/p&gt;
&lt;p&gt;Hbase 中 Master 状态监控与选举。&lt;br&gt;
利用 ZooKeeper 的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建&lt;br&gt;
 /currentMaster&lt;br&gt;
 节点，最终一定只有一个客户端请求能够创建成功&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分布式通知与协调&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分布式环境中，经常存在一个服务需要知道它所管理的子服务的状态。
&lt;ol&gt;
&lt;li&gt;NameNode 需知道各个 Datanode 的状态。&lt;/li&gt;
&lt;li&gt;JobTracker 需知道各个 TaskTracker 的状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;心跳检测机制可通过 ZooKeeper 来实现。&lt;/li&gt;
&lt;li&gt;信息推送可由 ZooKeeper 来实现，ZooKeeper 相当于一个发布 / 订阅系统。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分布式队列管理&lt;/p&gt;
&lt;p&gt;分布式队列分为两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。
&lt;ol&gt;
&lt;li&gt;一个 job 由多个 task 组成，只有所有任务完成后，job 才运行完成。&lt;/li&gt;
&lt;li&gt;可为 job 创建一个 /job 目录，然后在该目录下，为每个完成的 task 创建一个临时的 Znode，一旦临时节点数目达到 task 总数，则表明 job 运行完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;znode&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#znode&#34;&gt;#&lt;/a&gt; Znode&lt;/h2&gt;
&lt;p&gt;Znode 是 Zookeeper 中的基本数据结构，用于存储数据和组织数据结构。&lt;br&gt;
每个 Znode 都有一个唯一的路径，路径类似于文件系统的路径，以 / 开头。&lt;/p&gt;
&lt;p&gt;Znode 的属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据内容：
&lt;ul&gt;
&lt;li&gt;data：Znode 存储的数据内容，最大为 1MB。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ACL（Access Control List）：
&lt;ul&gt;
&lt;li&gt;权限控制列表：定义了对 Znode 的访问权限，包括读、写、创建子节点等权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;版本信息：
&lt;ul&gt;
&lt;li&gt;version：Znode 的版本号，用于数据一致性检查。&lt;/li&gt;
&lt;li&gt;cversion：子节点的版本号。&lt;/li&gt;
&lt;li&gt;aversion：ACL 的版本号。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间戳：
&lt;ul&gt;
&lt;li&gt;ctime：创建时间。&lt;/li&gt;
&lt;li&gt;mtime：最后修改时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;子节点：
&lt;ul&gt;
&lt;li&gt;children：Znode 可以拥有子节点，形成树状结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Znode 的类型包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;持久节点（Persistent）：持久节点在 ZooKeeper 服务器重启后不会丢失，除非显式删除。Java 创建示例如下：&lt;/p&gt;
 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;zookeeper.create(&lt;span class=&#34;string&#34;&gt;&amp;quot;/path&amp;quot;&lt;/span&gt;, data, acl, CreateMode.PERSISTENT);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;临时节点（Ephemeral）：创建后，如果创建该节点的客户端会话断开，则自动删除。且其不能有子节点。Java 创建示例如下：&lt;/p&gt;
 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;zookeeper.create(&lt;span class=&#34;string&#34;&gt;&amp;quot;/path&amp;quot;&lt;/span&gt;, data, acl, CreateMode.EPHEMERAL);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;顺序节点（Sequential）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;顺序节点在创建时自动获得一个唯一的序号，用于排序。例如，如果路径为 /path，创建的第一个顺序节点可能是&lt;br&gt;
 /path00000001。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;顺序节点也包含持久节点和临时节点两种持久化类型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 Java 创建一个路径为 &amp;quot;/path&amp;quot; 的持久顺序节点示例如下：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;zookeeper.create(&lt;span class=&#34;string&#34;&gt;&amp;quot;/path&amp;quot;&lt;/span&gt;, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;默认情况下创建的 Znode 为持久节点类型。&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建节点时，必须要带上全路径。&lt;/li&gt;
&lt;li&gt;创建节点时，如果父节点不存在，ZooKeeper 会自动创建父节点。&lt;/li&gt;
&lt;li&gt;同一级节点 key 名称是唯一的。&lt;/li&gt;
&lt;li&gt;delete 命令只能一层一层删除，不能删除一个节点下的所有子节点。新版本可以通过 deleteall 命令递归删除。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;watch机制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#watch机制&#34;&gt;#&lt;/a&gt; Watch 机制&lt;/h2&gt;
&lt;h3 id=&#34;概述&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#概述&#34;&gt;#&lt;/a&gt; 概述&lt;/h3&gt;
&lt;p&gt;ZooKeeper 的 watch 机制是一种非常重要的特性，用于实现实时监控 ZooKeeper 中的数据变化。&lt;br&gt;
在 Spring Cloud 应用中，可以通过 Curator 框架结合 Spring Boot 来实现对 ZooKeeper 数据的监控。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本概念&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Watch：一种一次性触发的通知机制。&lt;/li&gt;
&lt;li&gt;Watcher：客户端注册的监听器，用于接收 ZooKeeper 的通知。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;工作原理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注册 Watcher：客户端在执行某些操作（如获取节点数据、获取子节点列表等）时，可以注册一个 Watcher。&lt;/li&gt;
&lt;li&gt;触发 Watcher：当节点数据或子节点列表发生变化时，ZooKeeper 会触发相应的 Watcher。&lt;/li&gt;
&lt;li&gt;处理事件：客户端在收到 Watcher 触发的通知后，可以处理相应的事件，并重新注册 Watcher。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;事件类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NodeCreatedEvent：节点创建事件。&lt;/li&gt;
&lt;li&gt;NodeDeletedEvent：节点删除事件。&lt;/li&gt;
&lt;li&gt;NodeDataChangedEvent：节点数据变化事件。&lt;/li&gt;
&lt;li&gt;NodeChildrenChangedEvent：子节点列表变化事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置管理：在分布式系统中，配置管理需要实时监控配置的变化，以保持配置的实时一致性。&lt;/li&gt;
&lt;li&gt;监控服务：在分布式系统中，需要实时监控服务的状态，以确定服务的可用性。&lt;/li&gt;
&lt;li&gt;负载均衡：在分布式系统中，需要根据负载情况动态调整服务实例的数量，以实现负载均衡。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;在-spring-cloud-应用中的使用方法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#在-spring-cloud-应用中的使用方法&#34;&gt;#&lt;/a&gt; 在 Spring Cloud 应用中的使用方法&lt;/h3&gt;
&lt;h4 id=&#34;curator&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#curator&#34;&gt;#&lt;/a&gt; Curator&lt;/h4&gt;
&lt;p&gt;Curator 框架提供了简化 ZooKeeper 使用的 API，使得注册和处理 Watcher 更加方便。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 Curator 客户端&lt;/p&gt;
&lt;p&gt;在 Spring Boot 应用中，可以通过配置 Curator 客户端来管理 ZooKeeper 连接。&lt;/p&gt;
 &lt;figure class=&#34;highlight yaml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;attr&#34;&gt;spring:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;attr&#34;&gt;curator:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;attr&#34;&gt;connect-string:&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;localhost:2181&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;attr&#34;&gt;session-timeout-ms:&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;5000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;attr&#34;&gt;connection-timeout-ms:&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;3000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;attr&#34;&gt;retry-policy:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;attr&#34;&gt;base-sleep-time-ms:&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;1000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;attr&#34;&gt;max-retries:&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置 Curator 客户端&lt;/p&gt;
&lt;p&gt;在 Spring Boot 应用中，可以通过 @Configuration 类来配置 Curator 客户端。&lt;/p&gt;
 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.apache.curator.RetryPolicy;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.apache.curator.framework.CuratorFramework;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.apache.curator.framework.CuratorFrameworkFactory;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.apache.curator.retry.ExponentialBackoffRetry;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.springframework.context.annotation.Bean;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.springframework.context.annotation.Configuration;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;CuratorConfig&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; CuratorFramework &lt;span class=&#34;title function_&#34;&gt;curatorFramework&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;RetryPolicy&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;retryPolicy&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ExponentialBackoffRetry&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;1000&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;CuratorFramework&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; CuratorFrameworkFactory.builder()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                .connectString(&lt;span class=&#34;string&#34;&gt;&amp;quot;localhost:2181&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                .sessionTimeoutMs(&lt;span class=&#34;number&#34;&gt;5000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                .connectionTimeoutMs(&lt;span class=&#34;number&#34;&gt;3000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                .retryPolicy(retryPolicy)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                .build();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        client.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; client;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注册 Watcher&lt;/p&gt;
&lt;p&gt;在 Spring Boot 应用中，可以通过 Curator 框架提供的 NodeCache 和 PathChildrenCache 来注册 Watcher。&lt;/p&gt;
 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;58&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.apache.curator.framework.CuratorFramework;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.apache.curator.framework.api.ACLProvider;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.apache.curator.framework.recipes.cache.ChildData;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.apache.curator.framework.recipes.cache.NodeCache;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.apache.curator.framework.recipes.cache.NodeCacheListener;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.apache.curator.framework.recipes.cache.PathChildrenCache;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.apache.curator.utils.CloseableUtils;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.apache.zookeeper.CreateMode;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.apache.zookeeper.WatchedEvent;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.apache.zookeeper.Watcher;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.springframework.beans.factory.annotation.Autowired;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.springframework.stereotype.Component;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Component&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;WatcherService&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; CuratorFramework curatorFramework;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;watchNodeData&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;throws&lt;/span&gt; Exception &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;NodeCache&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;nodeCache&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;NodeCache&lt;/span&gt;(curatorFramework, &lt;span class=&#34;string&#34;&gt;&amp;quot;/testNode&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        nodeCache.getListenable().addListener(&lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;NodeCacheListener&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;meta&#34;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;nodeChanged&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;throws&lt;/span&gt; Exception &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;type&#34;&gt;ChildData&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;currentData&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; nodeCache.getCurrentData();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (currentData != &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Node data changed: &amp;quot;&lt;/span&gt; + &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;String&lt;/span&gt;(currentData.getData()));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        nodeCache.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;watchChildrenChanges&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;throws&lt;/span&gt; Exception &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;PathChildrenCache&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;childrenCache&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;PathChildrenCache&lt;/span&gt;(curatorFramework, &lt;span class=&#34;string&#34;&gt;&amp;quot;/testNode&amp;quot;&lt;/span&gt;, &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        childrenCache.getListenable().addListener(&lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;PathChildrenCacheListener&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;meta&#34;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;childEvent&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(CuratorFramework client, PathChildrenCacheEvent event)&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;throws&lt;/span&gt; Exception &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;switch&lt;/span&gt; (event.getType()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;keyword&#34;&gt;case&lt;/span&gt; CHILD_ADDED:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Child added: &amp;quot;&lt;/span&gt; + event.getData().getPath());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                        &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;keyword&#34;&gt;case&lt;/span&gt; CHILD_UPDATED:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Child updated: &amp;quot;&lt;/span&gt; + event.getData().getPath());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                        &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;keyword&#34;&gt;case&lt;/span&gt; CHILD_REMOVED:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Child removed: &amp;quot;&lt;/span&gt; + event.getData().getPath());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                        &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;keyword&#34;&gt;default&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Unknown event type: &amp;quot;&lt;/span&gt; + event.getType());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        childrenCache.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;zookeeper-命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#zookeeper-命令&#34;&gt;#&lt;/a&gt; Zookeeper 命令&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;ls: 列出指定节点下的所有子节点。 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;ls /path/to/node&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;get: 获取指定节点的数据以及其状态信息。 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;get /path/to/node&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;set: 设置指定节点的数据。 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;set /path/to/node new_data&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;create: 创建一个新的节点，并可以设置节点的权限和类型（持久化或临时）。 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;create /path/to/new_node data [acl] [flags]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
其中 [acl] 表示访问控制列表，[flags] 可以是 0（持久化节点）或 1（临时节点）。&lt;/li&gt;
&lt;li&gt;delete: 删除指定的节点。 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;delete /path/to/node&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;stat: 获取指定节点的状态信息。 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;ls /path/to/node&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;rmr: 递归删除一个节点及其所有的子节点。 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;rmr /path/to/node&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;sync: 强制同步节点到所有服务器。 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sync /path/to/node&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;close: 关闭当前客户端连接。 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;close&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;zookeeper集群&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#zookeeper集群&#34;&gt;#&lt;/a&gt; Zookeeper 集群&lt;/h2&gt;
&lt;p&gt;Zookeeper 集群是一种分布式协调服务，主要用于解决分布式系统中的一致性问题。它通过一组服务器组成集群，共同维护一个高度一致的状态。&lt;/p&gt;
&lt;p&gt;Zookeeper 集群的组成和角色如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;领导者（Leader）：&lt;/p&gt;
&lt;p&gt;Leader 是 Zookeeper 集群中的核心角色，负责处理客户端请求并协调其他服务器的状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理客户端请求：
&lt;ul&gt;
&lt;li&gt;Leader 负责接收客户端的所有读写请求，并处理这些请求。&lt;/li&gt;
&lt;li&gt;对于读请求，Leader 可以直接返回结果。&lt;/li&gt;
&lt;li&gt;对于写请求，Leader 会广播给所有 Follower 和 Observer。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据同步：
&lt;ul&gt;
&lt;li&gt;Leader 负责将写请求广播给所有的 Follower，并确保所有 Follower 都正确地执行了写操作。&lt;/li&gt;
&lt;li&gt;Leader 通过事务日志（transaction log）和快照（snapshot）来保证数据的一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选举协调：
&lt;ul&gt;
&lt;li&gt;当集群中出现故障或需要重新选举时，Leader 负责协调选举过程。&lt;/li&gt;
&lt;li&gt;Leader 通过投票机制来确定新的 Leader。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跟随者（Follower）：&lt;/p&gt;
&lt;p&gt;Follower 是 Zookeeper 集群中的重要角色之一，负责接收客户端请求并将请求转发给 Leader。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收客户端请求：
&lt;ul&gt;
&lt;li&gt;Follower 可以接收客户端的请求，并将请求转发给 Leader。&lt;/li&gt;
&lt;li&gt;Follower 也可以直接处理客户端的读请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据同步：
&lt;ul&gt;
&lt;li&gt;Follower 负责同步 Leader 的状态。&lt;/li&gt;
&lt;li&gt;当 Leader 发送写请求时，Follower 会执行相同的写操作，并确认操作完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选举参与：
&lt;ul&gt;
&lt;li&gt;Follower 参与选举过程，通过投票机制选举新的 Leader。&lt;/li&gt;
&lt;li&gt;当集群中出现故障时，Follower 会参与重新选举。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;观察者（Observer）：&lt;/p&gt;
&lt;p&gt;Observer 是 Zookeeper 集群中的辅助角色，主要用于提高集群的吞吐量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收客户端请求：
&lt;ul&gt;
&lt;li&gt;Observer 可以接收客户端的请求，并将请求转发给 Leader。&lt;/li&gt;
&lt;li&gt;Observer 不参与选举过程，因此不会影响选举的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据同步：
&lt;ul&gt;
&lt;li&gt;Observer 负责同步 Leader 的状态。&lt;/li&gt;
&lt;li&gt;当 Leader 发送写请求时，Observer 会执行相同的写操作，并确认操作完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提高吞吐量：
&lt;ul&gt;
&lt;li&gt;Observer 可以接收更多的客户端请求，从而提高集群的整体吞吐量。&lt;/li&gt;
&lt;li&gt;Observer 不参与选举过程，因此不会增加选举的复杂度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据一致性：Zookeeper 通过 ZAB 算法保证数据的一致性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务日志：
&lt;ul&gt;
&lt;li&gt;每个服务器都会记录事务日志（transaction log），确保数据的一致性。&lt;/li&gt;
&lt;li&gt;在选举过程中，Leader 会根据事务日志同步其他服务器的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;快照：
&lt;ul&gt;
&lt;li&gt;定期生成快照（snapshot），减少事务日志的大小，提高性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;zookeeper集群的读写流程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#zookeeper集群的读写流程&#34;&gt;#&lt;/a&gt; Zookeeper 集群的读写流程&lt;/h3&gt;
&lt;p&gt;Zookeeper 单机均遵循先写磁盘后写内存的写入模式，能够确保数据一致性。&lt;br&gt;
在集群模式下，当客户端向 Zookeeper 发送一个数据变更请求时，请求首先到达 Leader 节点。以下是详细的流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写入事务日志
&lt;ol&gt;
&lt;li&gt;Leader 收到变更请求：
&lt;ul&gt;
&lt;li&gt;Leader 节点首先接收到客户端发送的数据变更请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生成事务记录：
&lt;ul&gt;
&lt;li&gt;Leader 节点生成一条事务记录，这条记录包含了变更请求的所有细节，例如操作类型（创建、删除、更新）、节点路径、数据等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;写入事务日志：
&lt;ul&gt;
&lt;li&gt;Leader 节点将这条事务记录写入事务日志文件中。事务日志文件通常位于磁盘上，以确保数据的持久性。&lt;/li&gt;
&lt;li&gt;事务日志文件通常以 .log 或 .txn 结尾。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;写入内存
&lt;ol&gt;
&lt;li&gt;应用变更到内存：
&lt;ul&gt;
&lt;li&gt;在事务日志写入完成后，Leader 节点将变更请求应用到内存中的数据树。&lt;/li&gt;
&lt;li&gt;这一步确保了数据的一致性和实时性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;广播变更请求
&lt;ol&gt;
&lt;li&gt;广播变更请求：
&lt;ul&gt;
&lt;li&gt;Leader 节点将变更请求广播给所有 Follower 节点。&lt;/li&gt;
&lt;li&gt;Follower 节点接收到变更请求后，同样先写入事务日志，再写入内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;确认变更
&lt;ol&gt;
&lt;li&gt;Follower 处理变更：
&lt;ul&gt;
&lt;li&gt;每个 Follower 节点接收到变更请求后，先将其写入自己的事务日志文件中，然后再应用到内存中的数据树。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多数确认：
&lt;ul&gt;
&lt;li&gt;当大多数 Follower 节点确认收到并处理完变更请求后，Leader 节点认为变更成功。&lt;/li&gt;
&lt;li&gt;这一步确保了数据的一致性和可靠性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;返回结果：
&lt;ul&gt;
&lt;li&gt;Leader 节点将变更成功的消息返回给客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;zookeeper集群的选举机制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#zookeeper集群的选举机制&#34;&gt;#&lt;/a&gt; Zookeeper 集群的选举机制&lt;/h3&gt;
&lt;p&gt;Zookeeper 的选举机制基于 Fast Leader Election (FLE) 算法，确保在一个分布式环境中快速且正确地选出领导者。&lt;/p&gt;
&lt;p&gt;Zookeeper 集群中的选举机制通常在以下几种情况下被触发：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始启动：当集群中的所有服务器首次启动时，它们需要选举出一个 Leader。&lt;/li&gt;
&lt;li&gt;Leader 故障：当当前的 Leader 发生故障（如宕机或网络分区）时，需要重新选举新的 Leader。&lt;/li&gt;
&lt;li&gt;Leader 步骤落后：当 Leader 的步骤落后于其他服务器时，可能需要重新选举新的 Leader。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在进行 Zookeeper 集群中，进行选举的节点具有以下状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LOOKING
&lt;ul&gt;
&lt;li&gt;定义：节点处于寻找领导者的状态。&lt;/li&gt;
&lt;li&gt;行为：节点会发起投票，并接收来自其他节点的投票信息。一旦收集到足够的投票信息，它会尝试成为领导者或者选择一个合适的领导者。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LEADING
&lt;ul&gt;
&lt;li&gt;定义：节点成为领导者。&lt;/li&gt;
&lt;li&gt;行为：负责协调集群中的所有事务操作，并向其他节点发送心跳信息以维持集群的一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FOLLOWING
&lt;ul&gt;
&lt;li&gt;定义：节点作为跟随者。&lt;/li&gt;
&lt;li&gt;行为：接收领导者的心跳信息和指令，并执行相应的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OBSERVING
&lt;ul&gt;
&lt;li&gt;定义：节点作为观察者。&lt;/li&gt;
&lt;li&gt;行为：观察者可以参与投票过程，但不参与决策制定。观察者主要用于扩展集群的读取能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 ZooKeeper 的选举过程中，投票信息通常包含一个五元组，用于描述候选节点的状态和其他相关信息。这个五元组包括以下五个元素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;epoch（纪元号）
&lt;ul&gt;
&lt;li&gt;定义：纪元号（epoch）是一个整数，用于标识选举周期。每次选举都会有一个新的纪元号。&lt;/li&gt;
&lt;li&gt;作用：纪元号用于区分不同的选举周期，防止旧的投票信息影响新的选举。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;zxid（事务 ID）
&lt;ul&gt;
&lt;li&gt;定义：事务 ID（zxid）是一个 64 位的整数，用于标识事务的唯一性。&lt;/li&gt;
&lt;li&gt;组成：zxid 由两部分组成：高 32 位是纪元号（epoch），低 32 位是事务编号（transaction number）。&lt;/li&gt;
&lt;li&gt;作用：用于确定哪个节点具有最新的事务信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;peerId（节点 ID）
&lt;ul&gt;
&lt;li&gt;定义：节点 ID（peerId）是一个唯一的标识符，用于标识集群中的每个节点。&lt;/li&gt;
&lt;li&gt;作用：用于识别投票来自哪个节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;leaderId（Leader ID）
&lt;ul&gt;
&lt;li&gt;定义：Leader ID（leaderId）是一个标识符，用于标识当前投票支持的候选 Leader。&lt;/li&gt;
&lt;li&gt;作用：用于确定哪个节点被投票支持作为新的 Leader。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;type（投票类型）
&lt;ul&gt;
&lt;li&gt;定义：投票类型（type）是一个标识符，用于描述当前投票的类型。&lt;/li&gt;
&lt;li&gt;作用：用于区分不同类型的投票，如 LOOKING、LEADING 或 LEADER。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参与运算的关键变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;myid
&lt;ul&gt;
&lt;li&gt;定义：每个节点的唯一标识符。&lt;/li&gt;
&lt;li&gt;作用：用于区分不同的节点，在选举过程中用于投票。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;zxid
&lt;ul&gt;
&lt;li&gt;定义：事务 ID，表示最后一次提交的事务编号。&lt;/li&gt;
&lt;li&gt;作用：用于判断节点的状态是否最新。具有更大 zxid 的节点被认为是更 “新” 的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;epoch
&lt;ul&gt;
&lt;li&gt;定义：选举轮次。&lt;/li&gt;
&lt;li&gt;作用：防止过期的投票信息干扰当前的选举过程。每次选举开始时，epoch 增加。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;peerState
&lt;ul&gt;
&lt;li&gt;定义：节点的当前状态。&lt;/li&gt;
&lt;li&gt;作用：记录节点当前处于哪种状态（LOOKING, LEADING, FOLLOWING, OBSERVING）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;votesReceived
&lt;ul&gt;
&lt;li&gt;定义：节点接收到的投票数量。&lt;/li&gt;
&lt;li&gt;作用：用于统计当前节点是否获得了大多数投票。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;lastVote
&lt;ul&gt;
&lt;li&gt;定义：节点上一次投票的对象。&lt;/li&gt;
&lt;li&gt;作用：记录上一次投票的对象，避免重复投票。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;electionType
&lt;ul&gt;
&lt;li&gt;定义：选举类型（例如普通选举或重新选举）。&lt;/li&gt;
&lt;li&gt;作用：用于区分不同类型的选举过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细流程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化状态：当一个节点启动时，它会进入 LOOKING 状态。这意味着它正在寻找或试图成为领导者。&lt;/li&gt;
&lt;li&gt;初始化投票：每个节点在启动时会给自己投一票，并将投票信息（包括 myid 和 zxid）发送给集群中的其他节点。&lt;/li&gt;
&lt;li&gt;接收投票信息：节点会接收到其他节点的投票信息。&lt;/li&gt;
&lt;li&gt;比较和更新投票
&lt;ol&gt;
&lt;li&gt;比较 epoch：节点会比较接收到的投票信息中的 epoch 和自己的 epoch。
&lt;ul&gt;
&lt;li&gt;当接收到的 epoch 大于自己的 epoch，则更新自己的 epoch，并将新的投票信息再次发送给集群中的所有节点，防止投票过期。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;比较 zxid：节点会比较接收到的投票信息中的 zxid 和自己的 zxid。
&lt;ul&gt;
&lt;li&gt;如果接收到的投票信息中的 zxid 大于自己的 zxid，则更新自己的投票信息，并将新的投票信息再次发送给集群中的所有节点。&lt;/li&gt;
&lt;li&gt;如果接收到的投票信息中的 zxid 等于自己的 zxid，则比较 myid。
&lt;ul&gt;
&lt;li&gt;如果接收到的投票信息中的 myid 大于自己的 myid，则更新自己的投票信息，并将新的投票信息再次发送给集群中的所有节点。&lt;/li&gt;
&lt;li&gt;如果接收到的投票信息中的 myid 小于自己的 myid，则保持当前的投票信息不变。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果接收到的投票信息中的 zxid 小于自己的 zxid，则保持当前的投票信息不变。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;统计投票结果：每个节点会统计接收到的投票信息。如果一个特定的节点得到了大多数（超过半数）的投票，那么这个节点就被认为是领导者。
&lt;ul&gt;
&lt;li&gt;大多数投票：对于奇数个节点的集群，大多数意味着 (N + 1) / 2；对于偶数个节点，则需要 N / 2 + 1 才能构成大多数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;领导者确认：成功获得大多数投票的节点会向集群广播它的领导者身份。&lt;br&gt;
其他节点接收到这条消息后，会切换到 FOLLOWING 状态，并开始跟随新的领导者。&lt;/li&gt;
&lt;li&gt;故障转移：如果当前的领导者失效了，跟随者会重新进入 LOOKING 状态并开始新一轮的选举。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例流程&lt;/p&gt;
&lt;p&gt;假设有一个 Zookeeper 集群，包含三个节点 A、B 和 C：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化状态：A、B 和 C 都进入 LOOKING 状态。&lt;/li&gt;
&lt;li&gt;投票：A、B 和 C 各自给自己投一票，并将投票信息发送给其他节点。假设
&lt;ul&gt;
&lt;li&gt;A 的 zxid 是 100。&lt;/li&gt;
&lt;li&gt;B 的 zxid 是 90。&lt;/li&gt;
&lt;li&gt;C 的 zxid 是 110。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接收投票：
&lt;ul&gt;
&lt;li&gt;A 收到 B 和 C 的投票信息。&lt;/li&gt;
&lt;li&gt;B 收到 A 和 C 的投票信息。&lt;/li&gt;
&lt;li&gt;C 收到 A 和 B 的投票信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;比较和更新投票：
&lt;ul&gt;
&lt;li&gt;A 发现 C 的 zxid 更大，更新自己的投票信息，并重新发送投票给 B 和 C。&lt;/li&gt;
&lt;li&gt;B 发现 C 的 zxid 更大，更新自己的投票信息，并重新发送投票给 A 和 C。&lt;/li&gt;
&lt;li&gt;C 发现自己的 zxid 最大，保持投票信息不变。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;统计投票结果：C 收到 A 和 B 的投票，统计后发现自己的投票数达到 2（超过半数）。&lt;/li&gt;
&lt;li&gt;领导者确认：
&lt;ul&gt;
&lt;li&gt;C 向 A 和 B 广播自己成为领导者的信息。&lt;/li&gt;
&lt;li&gt;A 和 B 收到消息后，切换到 FOLLOWING 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;故障转移：如果 C 故障，A 和 B 重新进入 LOOKING 状态，重复上述流程。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;zookeeper的数据同步机制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#zookeeper的数据同步机制&#34;&gt;#&lt;/a&gt; Zookeeper 的数据同步机制&lt;/h3&gt;
&lt;p&gt;Zookeeper 使用 ZAB（Zookeeper Atomic Broadcast）协议来保证数据的一致性和高可用性。&lt;/p&gt;
&lt;p&gt;在集群中已经选举出 Leader 后，集群中的其他服务器会通过以下步骤与 Leader 保持同步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;状态同步&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新领导者确定事务状态：新领导者需要确定哪些事务应该保留，哪些事务应该撤销。&lt;/li&gt;
&lt;li&gt;事务日志检查：新领导者检查所有节点的事务日志，找出最新的事务状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;冲突解决&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;冲突检测：新领导者检查事务日志，找出冲突的事务。&lt;/li&gt;
&lt;li&gt;冲突解决策略：
&lt;ul&gt;
&lt;li&gt;基于事务编号（ZXID）：保留编号较大的事务。&lt;/li&gt;
&lt;li&gt;基于事务时间戳：保留时间戳较新的事务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leader 同步&lt;/p&gt;
&lt;p&gt;选举出新的 Leader 后，Leader 会开始与其他 Follower 进行数据同步。具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Leader 发送事务日志：
&lt;ul&gt;
&lt;li&gt;Leader 将最新的事务日志（transaction log）发送给所有 Follower。&lt;/li&gt;
&lt;li&gt;事务日志包含了所有未提交的事务记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Follower 接收事务日志：
&lt;ul&gt;
&lt;li&gt;Follower 接收到事务日志后，会将其应用到本地状态上。&lt;/li&gt;
&lt;li&gt;Follower 会确认事务日志的正确性，并将确认信息发送回 Leader。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Leader 确认同步：
&lt;ul&gt;
&lt;li&gt;Leader 收到所有 Follower 的确认信息后，会确认数据同步完成。&lt;/li&gt;
&lt;li&gt;Leader 会发送确认信息给所有 Follower，表明数据同步完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Follower 同步&lt;/p&gt;
&lt;p&gt;Follower 在同步过程中需要确保与 Leader 的状态一致。具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Leader 发送写请求：
&lt;ul&gt;
&lt;li&gt;当 Leader 收到客户端的写请求时，会将写请求广播给所有 Follower。&lt;/li&gt;
&lt;li&gt;写请求包含具体的写操作和事务 ID（zxid）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Follower 执行写操作：
&lt;ul&gt;
&lt;li&gt;Follower 接收到写请求后，会执行相同的写操作，并记录事务日志。&lt;/li&gt;
&lt;li&gt;Follower 会将确认信息发送回 Leader，表明写操作已完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Leader 确认写操作：
&lt;ul&gt;
&lt;li&gt;Leader 收到所有 Follower 的确认信息后，会确认写操作完成。&lt;/li&gt;
&lt;li&gt;Leader 会发送确认信息给所有 Follower，表明写操作完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Observer 同步&lt;/p&gt;
&lt;p&gt;Observer 不参与选举过程，但需要同步 Leader 的数据以保持最新状态。具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Observer 同步数据：
&lt;ul&gt;
&lt;li&gt;Observer 从 Leader 获取最新的数据。&lt;/li&gt;
&lt;li&gt;Leader 将最新的事务日志发送给 Observer。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Observer 应用事务日志：
&lt;ul&gt;
&lt;li&gt;Observer 接收到事务日志后，会将其应用到本地状态上。&lt;/li&gt;
&lt;li&gt;Observer 会确认事务日志的正确性，并将确认信息发送回 Leader。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Leader 确认同步：
&lt;ul&gt;
&lt;li&gt;Leader 收到 Observer 的确认信息后，会确认数据同步完成。&lt;/li&gt;
&lt;li&gt;Leader 会发送确认信息给 Observer，表明数据同步完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;详细流程示例&lt;/p&gt;
&lt;p&gt;假设集群中有三个服务器：Server A、Server B 和 Server C。Server A 成为 Leader，Server B 和 Server C 作为 Follower。此外，还有一个&lt;br&gt;
 Observer 服务器 Server D。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Leader 同步：
&lt;ul&gt;
&lt;li&gt;Server A 发送最新的事务日志给 Server B 和 Server C。&lt;/li&gt;
&lt;li&gt;Server B 和 Server C 接收到事务日志后，应用到本地状态，并发送确认信息给 Server A。&lt;/li&gt;
&lt;li&gt;Server A 收到所有 Follower 的确认信息后，确认数据同步完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Follower 同步：
&lt;ul&gt;
&lt;li&gt;当 Server A 收到客户端的写请求时，将写请求广播给 Server B 和 Server C。&lt;/li&gt;
&lt;li&gt;Server B 和 Server C 执行相同的写操作，并记录事务日志。&lt;/li&gt;
&lt;li&gt;Server B 和 Server C 发送确认信息给 Server A。&lt;/li&gt;
&lt;li&gt;Server A 收到所有 Follower 的确认信息后，确认写操作完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Observer 同步：
&lt;ul&gt;
&lt;li&gt;Server D 从 Server A 获取最新的事务日志。&lt;/li&gt;
&lt;li&gt;Server A 发送最新的事务日志给 Server D。&lt;/li&gt;
&lt;li&gt;Server D 接收到事务日志后，应用到本地状态，并发送确认信息给 Server A。&lt;/li&gt;
&lt;li&gt;Server A 收到 Observer 的确认信息后，确认数据同步完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;zookeeper的持久化机制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#zookeeper的持久化机制&#34;&gt;#&lt;/a&gt; Zookeeper 的持久化机制&lt;/h3&gt;
&lt;p&gt;Zookeeper 的数据持久化机制是其可靠性的关键组成部分之一。为了确保数据在系统崩溃或重启后仍然可用，Zookeeper 采用了多种机制来实现数据持久化。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;事务日志（Transaction Log）&lt;/p&gt;
&lt;p&gt;事务日志记录了所有对 Zookeeper 数据树的操作。每次写操作都会被记录在事务日志中，以便在系统崩溃后能够恢复数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务日志的作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录所有写操作：每次写操作（如创建节点、删除节点、更新节点数据等）都会被记录在事务日志中。&lt;/li&gt;
&lt;li&gt;支持数据恢复：在系统崩溃后，可以通过事务日志恢复数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务日志的存储&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务日志通常存储在磁盘上，以确保数据的安全性和持久性。每个 Server 都有自己的事务日志文件，通常位于配置文件&lt;br&gt;
 zoo.cfg&lt;br&gt;
 中指定的目录下。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务日志的格式&lt;/p&gt;
&lt;p&gt;事务日志文件通常以 .log 或 .txn 结尾。每个事务日志文件包含一系列事务记录，每条记录包含以下信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务类型：标识操作类型（如 create、delete、setData 等）。&lt;/li&gt;
&lt;li&gt;事务 ID（zxid）：唯一的事务标识符。&lt;/li&gt;
&lt;li&gt;操作详情：具体的操作内容（如节点路径、数据等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快照（Snapshot）&lt;/p&gt;
&lt;p&gt;快照是对 Zookeeper 数据树的一个完整备份。快照定期生成，以减少事务日志的大小，并提高恢复速度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;快照的作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速恢复数据：在系统崩溃后，可以通过快照快速恢复数据。&lt;/li&gt;
&lt;li&gt;减少事务日志大小：定期生成快照可以减少事务日志的大小，提高系统性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快照的存储&lt;/p&gt;
&lt;p&gt;快照通常也存储在磁盘上，与事务日志文件一起存放在配置文件 zoo.cfg 中指定的目录下。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快照的格式&lt;/p&gt;
&lt;p&gt;快照文件通常以 .snapshot 或 .snap 结尾。每个快照文件包含以下信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据树的完整状态：当前 Zookeeper 数据树的完整状态。&lt;/li&gt;
&lt;li&gt;事务 ID（zxid）：最后一个事务的 ID，用于标识快照的时间点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;恢复机制&lt;/p&gt;
&lt;p&gt;当 Zookeeper 服务器启动时，需要从磁盘上的事务日志和快照文件中恢复数据。恢复过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加载快照：服务器启动时，首先加载最新的快照文件，恢复数据树的基本状态。&lt;/li&gt;
&lt;li&gt;重放事务日志：从最新的快照时间点之后的事务日志开始重放，逐条执行事务日志中的操作，直到最新的事务日志为止。&lt;/li&gt;
&lt;li&gt;检查一致性：服务器会检查数据树的状态是否一致，确保没有遗漏的操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="后端" />
        <category term="java" />
        <category term="Zookeeper" />
        <updated>2024-09-24T03:39:53.000Z</updated>
    </entry>
    <entry>
        <id>https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Spring%E3%80%91Spring%E8%AF%A6%E8%A7%A3/</id>
        <title>【Spring】Spring详解</title>
        <link rel="alternate" href="https://silvercrow42.github.io/joker.github.io/2024/09/13/%E3%80%90Spring%E3%80%91Spring%E8%AF%A6%E8%A7%A3/"/>
        <content type="html">&lt;h2 id=&#34;spring的基本概念&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring的基本概念&#34;&gt;#&lt;/a&gt; Spring 的基本概念&lt;/h2&gt;
&lt;h3 id=&#34;1-spring-是什么&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-spring-是什么&#34;&gt;#&lt;/a&gt; 1、Spring 是什么？&lt;/h3&gt;
&lt;p&gt;Spring 是一个轻量级 Java 开发框架，最早有 Rod Johnson 创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的&lt;br&gt;
 JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发 Java 应用程序提供全面的基础架构支持。Spring 负责基础架构，因此 Java&lt;br&gt;
 开发者可以专注于应用程序的开发。Spring 最根本的使命是解决企业级应用开发的复杂性，即简化 Java 开发。&lt;/p&gt;
&lt;h3 id=&#34;2-spring-带来哪些好处&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-spring-带来哪些好处&#34;&gt;#&lt;/a&gt; 2、Spring 带来哪些好处？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基于 POJO 的轻量级和最小侵入性编程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DI 机制将对象之间的依赖关系交由框架处理，减低组件间的耦合性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于 AOP 技术支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于主流的应用框架提供了集成支持。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-说说-spring-有哪些模块&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#3-说说-spring-有哪些模块&#34;&gt;#&lt;/a&gt; 3、说说 Spring 有哪些模块？&lt;/h3&gt;
&lt;img data-src=&#34;/joker.github.io/2024/09/13/%E3%80%90Spring%E3%80%91Spring%E8%AF%A6%E8%A7%A3/26e3bd5f237ab05ae63f5a697805b33b.png&#34; class=&#34;&#34; title=&#34;Spring模块&#34;&gt;
&lt;p&gt;上图对应的是 Spring 4.x 版本的架构图，主要包括以下八个模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Spring Core&lt;/strong&gt;：基础，提供 IOC 和 DI 能力，可以说 Spring 其他所有的功能都依赖于该类库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Spring Aspects&lt;/strong&gt;：该模块为集成 AspectJ 提供支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Spring AOP&lt;/strong&gt;：提供面向方面的编程实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Spring JDBC&lt;/strong&gt;：Java 数据库连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Spring JMS&lt;/strong&gt;：Java 消息服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Spring ORM&lt;/strong&gt;：用于支持 Hibernate、Mybatis 等 ORM 工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Spring Web&lt;/strong&gt;：为创建 Web 应用程序提供支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Spring Test&lt;/strong&gt;：提供了对 JUnit 和 TestNG 测试框架的支持。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-spring-中使用了哪些设计模式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#4-spring-中使用了哪些设计模式&#34;&gt;#&lt;/a&gt; 4、Spring 中使用了哪些设计模式？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;工厂模式&lt;/strong&gt;：包括简单工厂和工厂方法，如通过 BeanFactory 或 ApplicationContext 创建 Bean 对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;单例模式&lt;/strong&gt;：Spring 中的 Bean 对象默认就是单例模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代理模式&lt;/strong&gt;：Spring AOP 就是基于代理实现的，包括 JDK 动态代理和 CGlib 技术。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模板方法模式&lt;/strong&gt;：Spring 中 jdbcTemplate 等以 Template 结尾对数据库操作的类就使用到模板模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;观察者模式&lt;/strong&gt;：Spring 事件驱动模型就是观察者模式很经典的应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;适配器模式&lt;/strong&gt;：Spring MVC 中，DispatcherServlet 根据请求解析到对应的 Handler（也就是我们常说的 Controller）后，开始由&lt;br&gt;
 HandlerAdapter 适配器处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;装饰者模式&lt;/strong&gt;：使用 DataSource 在不改动代码情况下切换数据源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;策略模式&lt;/strong&gt;：Spring 对资源的访问，如 Resource 接口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-spring-中有哪些不同类型事件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#5-spring-中有哪些不同类型事件&#34;&gt;#&lt;/a&gt; 5、Spring 中有哪些不同类型事件？&lt;/h3&gt;
&lt;p&gt;Spring 提供了以下 5 种标准的事件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上下文更新事件（ContextRefreshedEvent）&lt;/strong&gt;：在调用 ConfigurableApplicationContext 接口中的 refresh () 方法时被触发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上下文开始事件（ContextStartedEvent）&lt;/strong&gt;：当容器调用 ConfigurableApplicationContext 的 Start () 方法开始 / 重新开始容器时触发该事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上下文停止事件（ContextStoppedEvent）&lt;/strong&gt;：当容器调用 ConfigurableApplicationContext 的 Stop () 方法停止容器时触发该事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上下文关闭事件（ContextClosedEvent）&lt;/strong&gt;：当 ApplicationContext 被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;请求处理事件（RequestHandledEvent）&lt;/strong&gt;：在 Web 应用中，当一个 http 请求（request）结束触发该事件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至于如果监听这些事件：&lt;/p&gt;
&lt;p&gt;一个 Bean 实现了 ApplicationListener 接口，当一个 ApplicationEvent 被发布以后，Bean 会自动被通知。&lt;/p&gt;
&lt;h2 id=&#34;spring-ioc&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring-ioc&#34;&gt;#&lt;/a&gt; Spring IOC&lt;/h2&gt;
&lt;h3 id=&#34;1-什么是-ioc&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-什么是-ioc&#34;&gt;#&lt;/a&gt; 1、什么是 IOC？&lt;/h3&gt;
&lt;p&gt;IOC 是 Inversion of Control 的缩写，即控制反转。IOC 不是一项技术，而是一种设计思想。在 Java 开发中，Ioc 意味着你可以将设计好的对象交给&lt;br&gt;
 IOC 容器，完成初始化和管理，当你需要时由容器提供控制。&lt;/p&gt;
&lt;p&gt;Spring IOC 可谓是 Spring 的核心，对于 Spring 框架而言，所谓 IOC 就是由 Spring&lt;br&gt;
 来负责控制对象的生命周期和对象间的关系。正这个控制过程中，需要动态的向某个对象提供它所需要的其他对象，这一点是通过&lt;br&gt;
 DI（Dependency Injection，依赖注入）来实现的。&lt;/p&gt;
&lt;h3 id=&#34;2-ioc-的作用或好处&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-ioc-的作用或好处&#34;&gt;#&lt;/a&gt; 2、IOC 的作用或好处？&lt;/h3&gt;
&lt;p&gt;实现对象间的解耦，同时降低应用开发的代码量和复杂度，使开发人员更专注业务。&lt;/p&gt;
&lt;h3 id=&#34;3-ioc-的实现原理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#3-ioc-的实现原理&#34;&gt;#&lt;/a&gt; 3、IOC 的实现原理？&lt;/h3&gt;
&lt;p&gt;Spring 的 IOC 是基于工厂设计模式在加上反射实现。&lt;/p&gt;
&lt;h3 id=&#34;4-spring-有哪些容器类&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#4-spring-有哪些容器类&#34;&gt;#&lt;/a&gt; 4、Spring 有哪些容器类？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;BeanFactory&lt;/strong&gt;：这是一个最简单的容器，它主要的功能是为依赖注入（DI）提供支持。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ApplicationContext&lt;/strong&gt;：Application Context 是 Spring 中的高级容器。和 BeanFactory 类似，它可以加载和管理配置文件中定义的&lt;br&gt;
 Bean。 另外，它还增加了企业所需要的功能，比如，从属性文件中解析文本信息和将事件传递给所指定的监听器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一些常被使用的 ApplicationContext 实现类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;FileSystemXmlApplicationContext&lt;/strong&gt;：该容器从 XML 文件中加载已被定义的 Bean， 需要提供 XML 文件的完整路径。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ClassPathXmlApplicationContext&lt;/strong&gt;：同样从 XML 文件中加载已被定义的 Bean，但无需提供完整路径，因为它会从 CLASSPATH&lt;br&gt;
 中搜索配置文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WebXmlApplicationContext&lt;/strong&gt;：该容器会在一个 Web 应用程序的范围内加载在 XML 文件中已被定义的 Bean。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-beanfactory-和-applicationcontext-的区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#5-beanfactory-和-applicationcontext-的区别&#34;&gt;#&lt;/a&gt; 5、BeanFactory 和 ApplicationContext 的区别？&lt;/h3&gt;
&lt;p&gt;二者都是 Spring 框架的两大核心接口，都可以当做 Spring 的容器。其中 ApplicationContext 是 BeanFactory 的子接口。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;BeanFactory 是 Spring 里面最底层的接口，包含了各种 Bean 的定义，读取配置文档，管理 Bean 的加载、实例化，控制 Bean&lt;br&gt;
 的生命周期，维护对象之间的依赖关系等功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ApplicationContext 接口作为 BeanFactory 的派生，除了提供 BeanFactory 所具有的功能外，还提供了更完整的框架功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承 MessageSource，支持国际化。&lt;/li&gt;
&lt;li&gt;统一的资源文件访问方式。&lt;/li&gt;
&lt;li&gt;提供在监听器中注册 Bean 的事件。&lt;/li&gt;
&lt;li&gt;支持同时加载多个配置文件。&lt;/li&gt;
&lt;li&gt;载入多个（有继承关系）上下文，使得每一个上下文都专注于一个特定的层次，如应用的 Web 层。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;具体区别体现在以下三个方面：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;加载方式不同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;BeanFactroy 采用的懒加载方式注入 Bean，即只有在使用到某个 Bean 时才对该 Bean 实例化。这样，我们就不能在程序启动时发现一些存在的&lt;br&gt;
 Spring 的配置问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ApplicationContext 是在启动时一次性创建了所有的 Bean。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建方式不同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BeanFactory 通常以编程的方式被创建。&lt;/li&gt;
&lt;li&gt;ApplicationContext 还能以声明的方式创建，如使用 ContextLoader。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注册方式不同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二者都支持 BeanPostProcessor、BeanFactoryPostProcessor 的使用，但 BeanFactory 需要手动注册，而 ApplicationContext&lt;br&gt;
 则是自动注册。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;6-有哪些注入方式以及区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#6-有哪些注入方式以及区别&#34;&gt;#&lt;/a&gt; 6、有哪些注入方式以及区别？&lt;/h3&gt;
&lt;p&gt;Spring 支持多种依赖注入的方式，包括但不限于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造器注入（Constructor Injection）&lt;/li&gt;
&lt;li&gt;属性注入（Property or Setter Injection）&lt;/li&gt;
&lt;li&gt;字段注入（Field Injection）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;构造器注入&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#构造器注入&#34;&gt;#&lt;/a&gt; 构造器注入&lt;/h4&gt;
&lt;p&gt;构造器注入是指通过构造器参数来传递依赖项。这种方式可以确保依赖项在对象创建时就已经存在，有助于提高对象的不可变性和稳定性。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;SomeService&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;final&lt;/span&gt; SomeDependency dependency;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;SomeService&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(SomeDependency dependency)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;built_in&#34;&gt;this&lt;/span&gt;.dependency = Objects.requireNonNull(dependency, &lt;span class=&#34;string&#34;&gt;&amp;quot;dependency must not be null&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 Spring Boot 中，可以使用 @Autowired 注解来标记构造器，表明这是一个需要依赖注入的构造器。如果类中有多个构造器，那么需要显式地使用 @Autowired 注解来标注哪个构造器是注入构造器。&lt;/p&gt;
&lt;h4 id=&#34;属性注入&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#属性注入&#34;&gt;#&lt;/a&gt; 属性注入&lt;/h4&gt;
&lt;p&gt;属性注入是通过对象的 setter 方法来注入依赖项。这是最常用的一种方式，因为它允许在对象创建后注入依赖项，增加了灵活性。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;SomeService&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; SomeDependency dependency;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;setDependency&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(SomeDependency dependency)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;built_in&#34;&gt;this&lt;/span&gt;.dependency = Objects.requireNonNull(dependency, &lt;span class=&#34;string&#34;&gt;&amp;quot;dependency must not be null&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&#34;字段注入&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#字段注入&#34;&gt;#&lt;/a&gt; 字段注入&lt;/h4&gt;
&lt;p&gt;字段注入是通过直接在类成员变量上使用 @Autowired 注解来注入依赖项。这种方式简洁，但是不如构造器注入或属性注入那样清晰地表达依赖关系。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;SomeService&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; SomeDependency dependency;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&#34;一些使用上的规约&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一些使用上的规约&#34;&gt;#&lt;/a&gt; 一些使用上的规约&lt;/h4&gt;
&lt;p&gt;尽管 Spring 支持上述所有依赖注入方式，但 Spring 团队推荐使用构造器注入，特别是对于必填依赖项。构造器注入有助于确保依赖项在对象创建时已经就位，并且有助于提高对象的不可变性。此外，构造器注入使得依赖关系更加明确，便于阅读和理解代码。&lt;br&gt;
对于可选依赖项，可以使用属性注入或字段注入。然而，无论选择哪种方式，都应该遵循一些最佳实践：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免使用字段注入：除非你有非常明确的理由使用字段注入，否则应尽量避免使用。字段注入可能会导致依赖关系不明确，难以维护。&lt;/li&gt;
&lt;li&gt;使用构造器注入：对于必填依赖项，应该优先使用构造器注入。&lt;/li&gt;
&lt;li&gt;使用断言确保依赖项不为空：在构造器或 setter 方法中使用 Objects.requireNonNull () 或类似方法来确保依赖项不是空的。&lt;/li&gt;
&lt;li&gt;考虑使用 @Required 注解：虽然 Spring 现在主要使用 @Autowired，但在某些情况下，@Required 注解仍然有用，它可以用来标记 setter 方法，表示该方法必须被 Spring 的自动装配机制调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些依赖注入方式的选择取决于具体的应用场景和个人偏好。构造器注入通常被认为是更安全、更清晰的选择，而字段注入虽然简单，但在某些情况下可能会导致代码难以理解和维护。&lt;/p&gt;
&lt;h2 id=&#34;spring-bean&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring-bean&#34;&gt;#&lt;/a&gt; Spring Bean&lt;/h2&gt;
&lt;h3 id=&#34;1-spring-bean-有哪些作用域&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-spring-bean-有哪些作用域&#34;&gt;#&lt;/a&gt; 1、Spring Bean 有哪些作用域？&lt;/h3&gt;
&lt;p&gt;Spring 提供以下五种 Bean 的作用域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Singleton：单例模式，默认的作用域。在整个 Spring IoC 容器中，一个 Bean 定义对应一个实例。&lt;/li&gt;
&lt;li&gt;Prototype：原型模式。每次从容器中请求该 Bean 时都会创建一个新的实例。&lt;/li&gt;
&lt;li&gt;Request：对于每一个 HTTP 请求，都会创建一个新的 Bean 实例。这个作用域仅在 Web 环境中可用。&lt;/li&gt;
&lt;li&gt;Session：在一个 HTTP Session 中，一个 Bean 定义对应一个实例。这个作用域同样仅在 Web 环境中可用。&lt;/li&gt;
&lt;li&gt;Global-session：在一个全局的 HTTP Session 中，一个 Bean 定义对应一个实例。这个作用域主要用于 Portlet 环境。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;值的注意的是：使用 Prototype 作用域时需要慎重的思考，因为频繁创建和销毁 Bean 会带来很大的性能开销。&lt;/p&gt;
&lt;h4 id=&#34;spring-bean-作用域配置方式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring-bean-作用域配置方式&#34;&gt;#&lt;/a&gt; Spring Bean 作用域配置方式&lt;/h4&gt;
&lt;p&gt;Spring 提供了三种配置 Bean 作用域的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;XML 配置&lt;/p&gt;
&lt;p&gt;使用基于 XML 的配置文件时，可以通过&lt;bean&gt;标签的 scope 属性来指定 Bean 的作用域。&lt;/p&gt;
&lt;p&gt;例如，配置一个原型模式的 Bean：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&amp;lt;bean id=&lt;span class=&#34;string&#34;&gt;&amp;quot;exampleBean&amp;quot;&lt;/span&gt;class=&lt;span class=&#34;string&#34;&gt;&amp;quot;com.example.ExampleBean&amp;quot;&lt;/span&gt;scope=&lt;span class=&#34;string&#34;&gt;&amp;quot;prototype&amp;quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java 配置类配置&lt;/p&gt;
&lt;p&gt;使用 Java 配置类（通过 @Configuration 和 @Bean 注解）时，可以在 Bean 定义的方法上使用 @Scope 注解来指定作用域。&lt;/p&gt;
&lt;p&gt;例如，定义一个原型模式的 Bean：&lt;/p&gt;
  &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;AppConfig&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Scope(&amp;quot;prototype&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; ExampleBean &lt;span class=&#34;title function_&#34;&gt;exampleBean&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ExampleBean&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; ExampleSingletonBean &lt;span class=&#34;title function_&#34;&gt;exampleSingletonBean&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ExampleSingletonBean&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java 注解配置&lt;/p&gt;
&lt;p&gt;使用注解的方式配置 Bean 的作用域也很常见，特别是在组件扫描（Component Scanning）的情况下。可以直接在类或者方法级别使用 @Scope 注解。&lt;/p&gt;
&lt;p&gt;例如将一个 Service 组件设置为原型模式：&lt;/p&gt;
  &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Scope(&amp;quot;prototype&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ExampleBean&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-spring-的单例是否线程安全&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-spring-的单例是否线程安全&#34;&gt;#&lt;/a&gt; 2、Spring 的单例是否线程安全？&lt;/h3&gt;
&lt;p&gt;Spring 框架中的 Bean 默认是单例模式（Singleton），这意味着在整个应用上下文中只会存在一个 Bean 实例。&lt;/p&gt;
&lt;p&gt;对于无状态的服务层 Bean 来说，Spring 的单例模式本身是线程安全的，因为它们不保存任何实例变量的状态，所有操作都是基于输入参数进行计算。&lt;/p&gt;
&lt;p&gt;但是，如果单例 Bean 有实例变量，并且这些变量在多个线程间共享并且被修改，则可能会出现线程安全问题。&lt;/p&gt;
&lt;p&gt;如何保证线程安全&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免使用可变对象：尽量使用不可变对象或者确保对象在初始化之后不再改变其状态。&lt;/li&gt;
&lt;li&gt;同步访问：如果必须维护一些可变状态，可以通过同步方法或同步代码块来保证同一时间只有一个线程可以访问和修改这些状态。&lt;/li&gt;
&lt;li&gt;使用并发工具类：利用 Java 并发库中的工具类如 ConcurrentHashMap 等来管理共享资源。&lt;/li&gt;
&lt;li&gt;将 Bean 设计为原型模式：如果每个请求确实都需要独立的数据结构或状态，可以将 Bean 的作用域设置为&lt;br&gt;
 prototype，这样每次请求都会创建一个新的 Bean 实例，这样可能导致性能降低，但可以避免线程安全问题。&lt;/li&gt;
&lt;li&gt;使用 ThreadLocal：对于某些特定场景，可以使用 ThreadLocal 来实现线程之间的隔离，确保每个线程都有自己的独立副本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-spring-bean-的生命周期&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#3-spring-bean-的生命周期&#34;&gt;#&lt;/a&gt; 3、Spring Bean 的生命周期？&lt;/h3&gt;
&lt;img data-src=&#34;/joker.github.io/2024/09/13/%E3%80%90Spring%E3%80%91Spring%E8%AF%A6%E8%A7%A3/0cb7664ed7f4ec62270c528f298e03a3.png&#34; class=&#34;&#34; title=&#34;Spring Bean 生命周期&#34;&gt;
&lt;p&gt;Bean 在 Spring 容器中从创建到销毁经历了若干阶段，每一阶段都可以进行个性化定制。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Spring 对 Bean 进行实例化；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Spring 将配置和 Bean 的引用注入到对应的属性中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 Bean 实现了 BeanNameAware 接口，Spring 将 Bean 的 ID 传递给 setBeanName () 方法；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 Bean 实现了 BeanFactoryAware 接口，Spring 将调用 setBeanFactory () 方法将 BeanFactory 容器实例传入；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 Bean 实现了 ApplicationContextAware 接口，Spring 将调用 setApplicationContext () 方法将 Bean 所在的应用上下文的引用传入进来；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 Bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 postProcessBeforeInitialization () 方法；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 Bean 实现了 InitializingBean 接口，Spring 将调用它们的 afterPropertiesSet () 方法。类似地，如果 Bean 使用 initmethod&lt;br&gt;
 声明了初始化方法，该方法也会被调用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 Bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 postProcessAfterInitialization () 方法；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时，Bean 已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 Bean 实现了 DisposableBean 接口，Spring 将调用它的 destroy () 接口方法。同样，如果使用 destroymethod&lt;br&gt;
 声明了销毁方法，该方法也会被调用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;spring-aop&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring-aop&#34;&gt;#&lt;/a&gt; Spring AOP&lt;/h2&gt;
&lt;h3 id=&#34;1-什么是-aop-以及作用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-什么是-aop-以及作用&#34;&gt;#&lt;/a&gt; 1、什么是 AOP 以及作用？&lt;/h3&gt;
&lt;p&gt;AOP（Aspect Oriented Programming）是面向切面编程，是 OOP 的一个补充，它允许我们通过引入新的模块，来分离业务逻辑与非业务逻辑，从而实现代码复用。&lt;/p&gt;
&lt;p&gt;传统的 OOP 开发中代码逻辑是至上而下的过程中会长生一些横切性问题（大量与业务无关的重复代码），这些横切问题会散落在代码的各个地方且难以维护。AOP&lt;br&gt;
 的编程思想就是把业务逻辑和横切的问题进行分离，从而达到解耦的目的，使代码的重用性和开发效率高（目的是重用代码，把公共的代码抽取出来）。&lt;/p&gt;
&lt;p&gt;即 AOP 的作用是对业务逻辑的各个部分进行隔离，降低业务逻辑的耦合性，提高程序的可重用型和开发效率。&lt;/p&gt;
&lt;h3 id=&#34;2-有哪些应用场景&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-有哪些应用场景&#34;&gt;#&lt;/a&gt; 2、有哪些应用场景？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;事务管理：在多个服务或方法调用中需要统一管理事务的开始、提交或回滚。Spring AOP 可以通过声明式事务管理（例如使用&lt;br&gt;
 @Transactional 注解）来简化事务的控制逻辑。&lt;/li&gt;
&lt;li&gt;日志记录：对系统中的关键方法或接口的日志记录，包括方法调用前后的日志打印，以及异常捕获时的日志记录。这可以通过定义一个切面，在方法执行前后插入日志记录的逻辑来实现。&lt;/li&gt;
&lt;li&gt;权限验证：在调用某些敏感操作之前，需要进行权限验证。通过 AOP 可以在方法调用前进行权限检查，从而确保只有授权用户才能访问特定功能。&lt;/li&gt;
&lt;li&gt;性能监控：监控应用程序中方法的执行时间和资源消耗情况，这对于性能瓶颈分析非常有用。可以定义一个切面来记录方法执行的开始时间和结束时间，并计算执行时间。&lt;/li&gt;
&lt;li&gt;缓存操作：对数据访问操作的结果进行缓存，以减少数据库访问次数，提高响应速度。使用 AOP&lt;br&gt;
 可以在方法执行前检查缓存，如果缓存中有数据则直接返回，否则执行方法并将结果存入缓存。&lt;/li&gt;
&lt;li&gt;输入输出参数校验：在方法执行前对传入的参数进行校验，确保参数的有效性；在方法执行后对返回值进行校验，确保返回值的正确性。&lt;/li&gt;
&lt;li&gt;资源锁定：在多线程环境中，为了防止资源竞争，可以使用 AOP 来添加锁定逻辑，确保资源的一致性和完整性。&lt;/li&gt;
&lt;li&gt;自定义注解：定义自定义注解，并通过 AOP 处理这些注解，实现特定的行为，如日志记录、性能统计等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-切面-切点-连接点-通知以及四者的关系&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#3-切面-切点-连接点-通知以及四者的关系&#34;&gt;#&lt;/a&gt; 3、切面、切点、连接点、通知以及四者的关系？&lt;/h3&gt;
&lt;p&gt;在 Spring AOP 中，切面（Aspect）、切点（Pointcut）、连接点（Joinpoint）和通知（Advice）是核心概念，它们共同协作来实现面向切面编程的功能。下面是这些概念之间的关系：&lt;/p&gt;
&lt;h4 id=&#34;1连接点-joinpoint&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1连接点-joinpoint&#34;&gt;#&lt;/a&gt; 1）连接点 (Joinpoint)&lt;/h4&gt;
&lt;h5 id=&#34;概念&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#概念&#34;&gt;#&lt;/a&gt; 概念&lt;/h5&gt;
&lt;p&gt;连接点是指程序执行过程中的某个特定点，比如方法执行、字段访问等。&lt;/p&gt;
&lt;h5 id=&#34;示例&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#示例&#34;&gt;#&lt;/a&gt; 示例&lt;/h5&gt;
&lt;p&gt;在代码中，连接点的具体表现形式通常是方法的调用。当你定义了一个方法，并且这个方法被 Spring AOP 所管理，那么这个方法的执行就是一个连接点。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;SomeService&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;doSomething&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 业务逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，doSomething () 方法的执行就是一个连接点。&lt;/p&gt;
&lt;p&gt;不是所有的连接点都可以被切面所使用，只有那些被切点表达式匹配上的连接点才是 AOP 能够织入的连接点。&lt;/p&gt;
&lt;h4 id=&#34;2切点-pointcut&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2切点-pointcut&#34;&gt;#&lt;/a&gt; 2）切点 (Pointcut)&lt;/h4&gt;
&lt;h5 id=&#34;概念-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#概念-2&#34;&gt;#&lt;/a&gt; 概念&lt;/h5&gt;
&lt;p&gt;切点（Pointcut）是 AOP 中的一个重要概念，它定义了哪些连接点（Joinpoint）会被切面（Aspect）所关注，确定哪些方法或类应该被切面所拦截。&lt;br&gt;
一个切点可以匹配多个连接点，而一个连接点也可以被多个切点所匹配。&lt;/p&gt;
&lt;p&gt;在 Spring AOP 中，切点的表现形式通常包括以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法执行切点：最常用的形式，用于指定特定的方法执行。&lt;/li&gt;
&lt;li&gt;类执行切点：用于指定特定类的所有方法执行。&lt;/li&gt;
&lt;li&gt;异常切点：用于指定方法抛出特定异常时的切点。&lt;/li&gt;
&lt;li&gt;构造函数切点：用于指定构造函数的执行。&lt;/li&gt;
&lt;li&gt;字段访问切点：用于指定字段的访问或修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spring AOP 支持使用 AspectJ 的切点表达式语法来定义切点。基本语法如下：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;execution(modifier-pattern?ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)&lt;span class=&#34;keyword&#34;&gt;throws&lt;/span&gt;-pattern?)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;modifiers-pattern：修饰符模式（可选）。&lt;/li&gt;
&lt;li&gt;ret-type-pattern：返回类型模式。&lt;/li&gt;
&lt;li&gt;declaring-type-pattern：声明类型模式（可选）。&lt;/li&gt;
&lt;li&gt;name-pattern：方法名称模式。&lt;/li&gt;
&lt;li&gt;param-pattern：参数模式。&lt;/li&gt;
&lt;li&gt;throws-pattern：抛出异常模式（可选）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;示例-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#示例-2&#34;&gt;#&lt;/a&gt; 示例&lt;/h5&gt;
&lt;p&gt;假设我们有一个 UserService 类，包含一个 login 方法：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;UserService&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;login&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(String username, String password)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 登录逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以通过注解表达式来定义切点：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Aspect&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Component&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;LoggingAspect&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Before(&amp;quot;execution(* com.example.service.UserService.login(..))&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;logBefore&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(JoinPoint joinPoint)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Logging before login&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Pointcut(&amp;quot;execution(* com.example.service.UserService.*(..))&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;userServiceMethods&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Before(&amp;quot;userServiceMethods()&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;logBeforeAllUserServiceMethods&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(JoinPoint joinPoint)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Logging before all UserService methods&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;execution(* com.example.service.UserService.login(..))&lt;/code&gt; ：表示拦截 UserService 类中的 login 方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;execution(* com.example.service.UserService.*(..))&lt;/code&gt; ：表示拦截 UserService 类中的所有方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;通知-advice&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#通知-advice&#34;&gt;#&lt;/a&gt; 通知 (Advice)&lt;/h4&gt;
&lt;h5 id=&#34;概念-3&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#概念-3&#34;&gt;#&lt;/a&gt; 概念&lt;/h5&gt;
&lt;p&gt;通知（Advice）是 Spring AOP&lt;br&gt;
 中的一个核心概念，它定义了在切点（Pointcut）匹配的连接点（Joinpoint）上执行的动作。通知可以分为多种类型，每种类型在不同的时机执行不同的逻辑。下面详细介绍通知的类型及其具体表现形式。&lt;/p&gt;
&lt;p&gt;Spring AOP 支持以下几种主要的通知类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前置通知（Before Advice）：在方法执行前执行（关键字: Before）。&lt;/li&gt;
&lt;li&gt;后置通知（After Returning Advice）：仅当方法正常返回时执行（关键字: AfterReturning）。&lt;/li&gt;
&lt;li&gt;最终通知（After Advice）：无论方法是否抛出异常，都会在方法执行后执行（关键字: After）。&lt;/li&gt;
&lt;li&gt;异常通知（After Throwing Advice）：仅当方法抛出异常时执行（关键字: AfterThrowing）。&lt;/li&gt;
&lt;li&gt;环绕通知（Around Advice）：环绕通知，在方法执行前后都可执行，并且可以决定是否继续执行方法（关键字: Around）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不同类型的 AOP 通知适用于不同的场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前置通知：适用于日志记录、权限验证、资源准备等。&lt;/li&gt;
&lt;li&gt;后置通知：适用于日志记录、资源释放、结果处理等。&lt;/li&gt;
&lt;li&gt;最终通知：适用于资源释放、日志记录等。&lt;/li&gt;
&lt;li&gt;异常通知：适用于异常记录、错误处理、资源释放等。&lt;/li&gt;
&lt;li&gt;环绕通知：适用于性能监控、事务管理、权限验证、资源控制等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;示例-3&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#示例-3&#34;&gt;#&lt;/a&gt; 示例&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;前置通知（Before Advice）&lt;/p&gt;
&lt;p&gt;前置通知是在方法执行前执行的通知。它可以用来进行一些准备工作，如日志记录、权限验证等。&lt;br&gt;
示例代码：&lt;/p&gt;
 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Aspect&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Component&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;LoggingAspect&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Before(&amp;quot;execution(* com.example.service.UserService.*(..))&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;logBefore&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(JoinPoint joinPoint)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;MethodSignature&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;signature&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; (MethodSignature) joinPoint.getSignature();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; signature.getMethod();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Executing: &amp;quot;&lt;/span&gt; + method.getName());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        Object[] args = joinPoint.getArgs();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (Object arg : args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Argument: &amp;quot;&lt;/span&gt; + arg);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，logBefore 方法是一个前置通知，它会在 UserService 类中的所有方法执行前被调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后置通知（After Returning Advice）&lt;/p&gt;
&lt;p&gt;后置通知是在方法正常返回后执行的通知。它可以用来进行一些清理工作，如关闭资源、记录日志等。&lt;br&gt;
示例代码：&lt;/p&gt;
 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Aspect&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Component&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;LoggingAspect&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@AfterReturning(pointcut = &amp;quot;execution(* com.example.service.UserService.*(..))&amp;quot;, returning = &amp;quot;result&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;logAfterReturning&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(JoinPoint joinPoint, Object result)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;MethodSignature&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;signature&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; (MethodSignature) joinPoint.getSignature();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; signature.getMethod();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Method &amp;quot;&lt;/span&gt; + method.getName() + &lt;span class=&#34;string&#34;&gt;&amp;quot; returned: &amp;quot;&lt;/span&gt; + result);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，logAfterReturning 方法是一个后置通知，它会在 UserService 类中的所有方法正常返回后被调用，并接收方法的返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最终通知（After Advice）&lt;/p&gt;
&lt;p&gt;最终通知是在方法执行后（无论方法是否正常返回或抛出异常）都会执行的通知。它可以用来进行一些必要的清理工作，如关闭资源等。&lt;br&gt;
示例代码：&lt;/p&gt;
 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Aspect&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Component&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;LoggingAspect&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@After(&amp;quot;execution(* com.example.service.UserService.*(..))&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;logFinally&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(JoinPoint joinPoint)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;MethodSignature&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;signature&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; (MethodSignature) joinPoint.getSignature();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; signature.getMethod();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Method &amp;quot;&lt;/span&gt; + method.getName() + &lt;span class=&#34;string&#34;&gt;&amp;quot; has been executed.&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，logFinally 方法是一个最终通知，它会在 UserService 类中的所有方法执行后被调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异常通知（After Throwing Advice）&lt;/p&gt;
&lt;p&gt;异常通知是在方法抛出异常后执行的通知。它可以用来记录异常信息、发送报警等。&lt;br&gt;
示例代码：&lt;/p&gt;
 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Aspect&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Component&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;LoggingAspect&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@AfterThrowing(pointcut = &amp;quot;execution(* com.example.service.UserService.*(..))&amp;quot;, throwing = &amp;quot;ex&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;logAfterThrowing&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(JoinPoint joinPoint, Exception ex)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;MethodSignature&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;signature&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; (MethodSignature) joinPoint.getSignature();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; signature.getMethod();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Method &amp;quot;&lt;/span&gt; + method.getName() + &lt;span class=&#34;string&#34;&gt;&amp;quot; threw exception: &amp;quot;&lt;/span&gt; + ex.getMessage());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，logAfterThrowing 方法是一个异常通知，它会在 UserService 类中的所有方法抛出异常后被调用，并接收异常对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;环绕通知（Around Advice）&lt;/p&gt;
&lt;p&gt;环绕通知是在方法执行前后都可执行的通知。它可以完全控制方法的执行流程，包括是否继续执行方法、如何执行等。&lt;br&gt;
示例代码：&lt;/p&gt;
 &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Aspect&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Component&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;LoggingAspect&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Around(&amp;quot;execution(* com.example.service.UserService.*(..))&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; Object &lt;span class=&#34;title function_&#34;&gt;logAround&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(ProceedingJoinPoint joinPoint)&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;throws&lt;/span&gt; Throwable &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;MethodSignature&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;signature&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; (MethodSignature) joinPoint.getSignature();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; signature.getMethod();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Before executing: &amp;quot;&lt;/span&gt; + method.getName());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;type&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; joinPoint.proceed(); &lt;span class=&#34;comment&#34;&gt;// 继续执行方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;After executing: &amp;quot;&lt;/span&gt; + method.getName());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125; &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Method &amp;quot;&lt;/span&gt; + method.getName() + &lt;span class=&#34;string&#34;&gt;&amp;quot; threw exception: &amp;quot;&lt;/span&gt; + e.getMessage());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;throw&lt;/span&gt; e;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，logAround 方法是一个环绕通知，它会在 UserService 类中的所有方法执行前后都被调用，并且可以控制方法的执行流程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;切面-aspect&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#切面-aspect&#34;&gt;#&lt;/a&gt; 切面 (Aspect)&lt;/h4&gt;
&lt;h5 id=&#34;概念-4&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#概念-4&#34;&gt;#&lt;/a&gt; 概念&lt;/h5&gt;
&lt;p&gt;切面（Aspect）是 Spring AOP 中的核心概念之一，它将横切关注点（Cross-cutting&lt;br&gt;
Concern）模块化为独立的组件。切面包含了多个通知（Advice）和切点（Pointcut），并通过这些通知和切点来实现特定的功能。下面详细介绍切面的概念、组成以及具体的应用场景。&lt;/p&gt;
&lt;p&gt;切面通常由以下几个部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;切点（Pointcut）：定义了哪些连接点（Joinpoint）会被切面所关注。&lt;/li&gt;
&lt;li&gt;通知（Advice）：定义了在切点匹配的连接点上执行的动作。&lt;/li&gt;
&lt;li&gt;引入（Introduction）：允许向现有类添加新的方法或属性。&lt;/li&gt;
&lt;li&gt;织入（Weaving）：将切面与应用程序的其他部分结合起来的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;示例-4&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#示例-4&#34;&gt;#&lt;/a&gt; 示例&lt;/h5&gt;
&lt;p&gt;在 Spring AOP 中，切面通常通过 @Aspect 注解来定义，并且可以包含多个切点和通知。&lt;br&gt;
示例代码：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;60&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Aspect&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Component&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;LoggingAspect&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 前置通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Before(&amp;quot;execution(* com.example.service.UserService.*(..))&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;logBefore&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(JoinPoint joinPoint)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;MethodSignature&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;signature&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; (MethodSignature) joinPoint.getSignature();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; signature.getMethod();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Executing: &amp;quot;&lt;/span&gt; + method.getName());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        Object[] args = joinPoint.getArgs();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (Object arg : args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Argument: &amp;quot;&lt;/span&gt; + arg);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 后置通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@AfterReturning(pointcut = &amp;quot;execution(* com.example.service.UserService.*(..))&amp;quot;, returning = &amp;quot;result&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;logAfterReturning&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(JoinPoint joinPoint, Object result)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;MethodSignature&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;signature&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; (MethodSignature) joinPoint.getSignature();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; signature.getMethod();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Method &amp;quot;&lt;/span&gt; + method.getName() + &lt;span class=&#34;string&#34;&gt;&amp;quot; returned: &amp;quot;&lt;/span&gt; + result);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 最终通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@After(&amp;quot;execution(* com.example.service.UserService.*(..))&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;logFinally&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(JoinPoint joinPoint)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;MethodSignature&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;signature&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; (MethodSignature) joinPoint.getSignature();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; signature.getMethod();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Method &amp;quot;&lt;/span&gt; + method.getName() + &lt;span class=&#34;string&#34;&gt;&amp;quot; has been executed.&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 异常通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@AfterThrowing(pointcut = &amp;quot;execution(* com.example.service.UserService.*(..))&amp;quot;, throwing = &amp;quot;ex&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;logAfterThrowing&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(JoinPoint joinPoint, Exception ex)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;MethodSignature&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;signature&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; (MethodSignature) joinPoint.getSignature();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; signature.getMethod();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Method &amp;quot;&lt;/span&gt; + method.getName() + &lt;span class=&#34;string&#34;&gt;&amp;quot; threw exception: &amp;quot;&lt;/span&gt; + ex.getMessage());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 环绕通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Around(&amp;quot;execution(* com.example.service.UserService.*(..))&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; Object &lt;span class=&#34;title function_&#34;&gt;logAround&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(ProceedingJoinPoint joinPoint)&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;throws&lt;/span&gt; Throwable &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;MethodSignature&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;signature&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; (MethodSignature) joinPoint.getSignature();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; signature.getMethod();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Before executing: &amp;quot;&lt;/span&gt; + method.getName());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;type&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;startTime&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; System.currentTimeMillis();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;type&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; joinPoint.proceed(); &lt;span class=&#34;comment&#34;&gt;// 继续执行方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;type&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;endTime&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; System.currentTimeMillis();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;After executing: &amp;quot;&lt;/span&gt; + method.getName() + &lt;span class=&#34;string&#34;&gt;&amp;quot; (Time: &amp;quot;&lt;/span&gt; + (endTime - startTime) + &lt;span class=&#34;string&#34;&gt;&amp;quot;ms)&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125; &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Method &amp;quot;&lt;/span&gt; + method.getName() + &lt;span class=&#34;string&#34;&gt;&amp;quot; threw exception: &amp;quot;&lt;/span&gt; + e.getMessage());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;throw&lt;/span&gt; e;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-aop-的实现原理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#4-aop-的实现原理&#34;&gt;#&lt;/a&gt; 4、AOP 的实现原理？&lt;/h3&gt;
&lt;p&gt;AOP 是基于代理实现的，Spring 提供了 JDK 动态代理和 CGlib 两种方式来生成代理对象。&lt;/p&gt;
&lt;p&gt;Spring AOP 会根据目标对象是否实现了接口来决定使用哪种代理策略：&lt;br&gt;
如果目标对象实现了接口，则使用 JDK 动态代理。&lt;br&gt;
如果目标对象没有实现任何接口，则使用 CGLIB 代理。&lt;br&gt;
这种策略使得 Spring AOP 能够灵活地适应不同的情况，并且保证了代理对象能够正确地执行增强逻辑。&lt;/p&gt;
&lt;p&gt;以下介绍两种不同的代理策略原理。&lt;/p&gt;
&lt;h4 id=&#34;jdk-动态代理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#jdk-动态代理&#34;&gt;#&lt;/a&gt; JDK 动态代理&lt;/h4&gt;
&lt;p&gt;JDK 动态代理是基于 Java 语言反射机制实现的。它要求被代理的对象必须实现一个或多个接口。Spring AOP 会利用这个特性，当目标对象实现了接口时，就会使用&lt;br&gt;
 JDK 动态代理来创建代理对象。&lt;/p&gt;
&lt;p&gt;工作原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个对象实现了某个接口时，Spring 会通过 java.lang.reflect.Proxy 类来创建一个代理对象。&lt;/li&gt;
&lt;li&gt;这个代理对象实现了相同的接口，并且其内部持有对原始对象的引用。&lt;/li&gt;
&lt;li&gt;代理对象通过 InvocationHandler 接口来处理方法调用，这样可以在方法调用前后添加额外的行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 假设有一个接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Service&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;doSomething&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 实现类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ServiceImpl&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Service&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;doSomething&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Doing something...&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 创建代理对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;Service&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;service&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ServiceImpl&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;Service&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;proxy&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; (Service) Proxy.newProxyInstance(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            Service.class.getClassLoader(),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Class&lt;/span&gt;&amp;lt;?&amp;gt;[]&amp;#123;Service.class&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;InvocationHandler&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;meta&#34;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; Object &lt;span class=&#34;title function_&#34;&gt;invoke&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(Object proxy, Method method, Object[] args)&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;throws&lt;/span&gt; Throwable &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Before method call&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;type&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; method.invoke(service, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;After method call&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;proxy.doSomething();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&#34;cglib&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#cglib&#34;&gt;#&lt;/a&gt; CGlib&lt;/h4&gt;
&lt;p&gt;CGLIB（Code Generation Library）是一个高性能的字节码生成库，它可以在运行时动态生成一个目标类的子类。这意味着即使目标对象没有实现任何接口，也可以通过&lt;br&gt;
 CGLIB 来创建代理对象。&lt;br&gt;
工作原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CGLIB 通过继承目标类来创建一个新的子类对象。&lt;/li&gt;
&lt;li&gt;在这个子类中，对父类的方法进行增强，也就是在方法调用前后添加额外的行为。&lt;/li&gt;
&lt;li&gt;这种方式不需要目标类实现任何接口，因此更加灵活。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 假设有一个未实现接口的类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Service&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;doSomething&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Doing something...&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 创建代理对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;Enhancer&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;enhancer&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Enhancer&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;enhancer.setSuperclass(Service.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        enhancer.setCallback(&lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MethodInterceptor&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; Object &lt;span class=&#34;title function_&#34;&gt;intercept&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(Object obj,Method method,Object[]args,MethodProxy proxy)&lt;/span&gt;&lt;span class=&#34;keyword&#34;&gt;throws&lt;/span&gt; Throwable&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Before method call&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        Object result=proxy.invokeSuper(obj,args);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;After method call&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        Service service=(Service)enhancer.create();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        service.doSomething();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
        <category term="后端" />
        <category term="java" />
        <category term="spring" />
        <updated>2024-09-13T03:24:41.000Z</updated>
    </entry>
</feed>
